// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tss/v1beta1/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	github_com_bandprotocol_chain_v2_pkg_tss "github.com/bandprotocol/chain/v2/pkg/tss"
	_ "github.com/cosmos/cosmos-proto"
	types1 "github.com/cosmos/cosmos-sdk/codec/types"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgCreateGroup is the Msg/CreateGroup request type.
type MsgCreateGroup struct {
	// members is a list of members in this group.
	Members []string `protobuf:"bytes,1,rep,name=members,proto3" json:"members,omitempty"`
	// threshold is a minimum number of members required to produce a signature.
	Threshold uint64 `protobuf:"varint,2,opt,name=threshold,proto3" json:"threshold,omitempty"`
	// fee is the tokens that will be paid per signing.
	Fee github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,3,rep,name=fee,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"fee"`
	// authority is the address that controls the module (defaults to x/gov unless overwritten).
	Authority string `protobuf:"bytes,4,opt,name=authority,proto3" json:"authority,omitempty"`
}

func (m *MsgCreateGroup) Reset()         { *m = MsgCreateGroup{} }
func (m *MsgCreateGroup) String() string { return proto.CompactTextString(m) }
func (*MsgCreateGroup) ProtoMessage()    {}
func (*MsgCreateGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_58d13e1023e3ffaf, []int{0}
}
func (m *MsgCreateGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateGroup.Merge(m, src)
}
func (m *MsgCreateGroup) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateGroup.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateGroup proto.InternalMessageInfo

func (m *MsgCreateGroup) GetMembers() []string {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *MsgCreateGroup) GetThreshold() uint64 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

func (m *MsgCreateGroup) GetFee() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Fee
	}
	return nil
}

func (m *MsgCreateGroup) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

// MsgCreateGroupResponse is the Msg/CreateGroup response type.
type MsgCreateGroupResponse struct {
}

func (m *MsgCreateGroupResponse) Reset()         { *m = MsgCreateGroupResponse{} }
func (m *MsgCreateGroupResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateGroupResponse) ProtoMessage()    {}
func (*MsgCreateGroupResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_58d13e1023e3ffaf, []int{1}
}
func (m *MsgCreateGroupResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateGroupResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateGroupResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateGroupResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateGroupResponse.Merge(m, src)
}
func (m *MsgCreateGroupResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateGroupResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateGroupResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateGroupResponse proto.InternalMessageInfo

// MsgReplaceGroup is the Msg/ReplaceGroup request type.
type MsgReplaceGroup struct {
	// from_group_id is the ID of the group that want to replace, and subsequently remove this group.
	FromGroupID github_com_bandprotocol_chain_v2_pkg_tss.GroupID `protobuf:"varint,1,opt,name=from_group_id,json=fromGroupId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.GroupID" json:"from_group_id,omitempty"`
	// to_group_id is the ID of the group that will take the place of another group.
	ToGroupID github_com_bandprotocol_chain_v2_pkg_tss.GroupID `protobuf:"varint,2,opt,name=to_group_id,json=toGroupId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.GroupID" json:"to_group_id,omitempty"`
	// exec_time is the time that will be substituted in place of the group.
	ExecTime time.Time `protobuf:"bytes,3,opt,name=exec_time,json=execTime,proto3,stdtime" json:"exec_time"`
	// authority is the address that controls the module (defaults to x/gov unless overwritten).
	Authority string `protobuf:"bytes,4,opt,name=authority,proto3" json:"authority,omitempty"`
}

func (m *MsgReplaceGroup) Reset()         { *m = MsgReplaceGroup{} }
func (m *MsgReplaceGroup) String() string { return proto.CompactTextString(m) }
func (*MsgReplaceGroup) ProtoMessage()    {}
func (*MsgReplaceGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_58d13e1023e3ffaf, []int{2}
}
func (m *MsgReplaceGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgReplaceGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgReplaceGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgReplaceGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgReplaceGroup.Merge(m, src)
}
func (m *MsgReplaceGroup) XXX_Size() int {
	return m.Size()
}
func (m *MsgReplaceGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgReplaceGroup.DiscardUnknown(m)
}

var xxx_messageInfo_MsgReplaceGroup proto.InternalMessageInfo

func (m *MsgReplaceGroup) GetFromGroupID() github_com_bandprotocol_chain_v2_pkg_tss.GroupID {
	if m != nil {
		return m.FromGroupID
	}
	return 0
}

func (m *MsgReplaceGroup) GetToGroupID() github_com_bandprotocol_chain_v2_pkg_tss.GroupID {
	if m != nil {
		return m.ToGroupID
	}
	return 0
}

func (m *MsgReplaceGroup) GetExecTime() time.Time {
	if m != nil {
		return m.ExecTime
	}
	return time.Time{}
}

func (m *MsgReplaceGroup) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

// MsgReplaceGroupResponse is the Msg/MsgReplaceGroupResponse response type.
type MsgReplaceGroupResponse struct {
}

func (m *MsgReplaceGroupResponse) Reset()         { *m = MsgReplaceGroupResponse{} }
func (m *MsgReplaceGroupResponse) String() string { return proto.CompactTextString(m) }
func (*MsgReplaceGroupResponse) ProtoMessage()    {}
func (*MsgReplaceGroupResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_58d13e1023e3ffaf, []int{3}
}
func (m *MsgReplaceGroupResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgReplaceGroupResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgReplaceGroupResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgReplaceGroupResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgReplaceGroupResponse.Merge(m, src)
}
func (m *MsgReplaceGroupResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgReplaceGroupResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgReplaceGroupResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgReplaceGroupResponse proto.InternalMessageInfo

// MsgUpdateGroupFee is the Msg/UpdateGroupFee request type.
type MsgUpdateGroupFee struct {
	// group_id is the ID of the group that want to update.
	GroupID github_com_bandprotocol_chain_v2_pkg_tss.GroupID `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.GroupID" json:"group_id,omitempty"`
	// fee is the tokens that will be paid per signing.
	Fee github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,3,rep,name=fee,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"fee"`
	// authority is the address that controls the module (defaults to x/gov unless overwritten).
	Authority string `protobuf:"bytes,4,opt,name=authority,proto3" json:"authority,omitempty"`
}

func (m *MsgUpdateGroupFee) Reset()         { *m = MsgUpdateGroupFee{} }
func (m *MsgUpdateGroupFee) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateGroupFee) ProtoMessage()    {}
func (*MsgUpdateGroupFee) Descriptor() ([]byte, []int) {
	return fileDescriptor_58d13e1023e3ffaf, []int{4}
}
func (m *MsgUpdateGroupFee) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateGroupFee) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateGroupFee.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateGroupFee) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateGroupFee.Merge(m, src)
}
func (m *MsgUpdateGroupFee) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateGroupFee) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateGroupFee.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateGroupFee proto.InternalMessageInfo

func (m *MsgUpdateGroupFee) GetGroupID() github_com_bandprotocol_chain_v2_pkg_tss.GroupID {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *MsgUpdateGroupFee) GetFee() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Fee
	}
	return nil
}

func (m *MsgUpdateGroupFee) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

// MsgUpdateGroupFeeResponse is the Msg/UpdateGroupFee response type.
type MsgUpdateGroupFeeResponse struct {
}

func (m *MsgUpdateGroupFeeResponse) Reset()         { *m = MsgUpdateGroupFeeResponse{} }
func (m *MsgUpdateGroupFeeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateGroupFeeResponse) ProtoMessage()    {}
func (*MsgUpdateGroupFeeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_58d13e1023e3ffaf, []int{5}
}
func (m *MsgUpdateGroupFeeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateGroupFeeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateGroupFeeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateGroupFeeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateGroupFeeResponse.Merge(m, src)
}
func (m *MsgUpdateGroupFeeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateGroupFeeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateGroupFeeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateGroupFeeResponse proto.InternalMessageInfo

// MsgSubmitDKGRound1 is the Msg/SubmitDKGRound1 request type.
type MsgSubmitDKGRound1 struct {
	// group_id is ID of the group.
	GroupID github_com_bandprotocol_chain_v2_pkg_tss.GroupID `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.GroupID" json:"group_id,omitempty"`
	// round1_info is all data that require to handle round 1.
	Round1Info Round1Info `protobuf:"bytes,2,opt,name=round1_info,json=round1Info,proto3" json:"round1_info"`
	// member is the signer of this message. Must be the member of this group.
	Member string `protobuf:"bytes,3,opt,name=member,proto3" json:"member,omitempty"`
}

func (m *MsgSubmitDKGRound1) Reset()         { *m = MsgSubmitDKGRound1{} }
func (m *MsgSubmitDKGRound1) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitDKGRound1) ProtoMessage()    {}
func (*MsgSubmitDKGRound1) Descriptor() ([]byte, []int) {
	return fileDescriptor_58d13e1023e3ffaf, []int{6}
}
func (m *MsgSubmitDKGRound1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitDKGRound1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitDKGRound1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitDKGRound1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitDKGRound1.Merge(m, src)
}
func (m *MsgSubmitDKGRound1) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitDKGRound1) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitDKGRound1.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitDKGRound1 proto.InternalMessageInfo

func (m *MsgSubmitDKGRound1) GetGroupID() github_com_bandprotocol_chain_v2_pkg_tss.GroupID {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *MsgSubmitDKGRound1) GetRound1Info() Round1Info {
	if m != nil {
		return m.Round1Info
	}
	return Round1Info{}
}

func (m *MsgSubmitDKGRound1) GetMember() string {
	if m != nil {
		return m.Member
	}
	return ""
}

// MsgSubmitDKGRound1Response is the Msg/SubmitDKGRound1 response type.
type MsgSubmitDKGRound1Response struct {
}

func (m *MsgSubmitDKGRound1Response) Reset()         { *m = MsgSubmitDKGRound1Response{} }
func (m *MsgSubmitDKGRound1Response) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitDKGRound1Response) ProtoMessage()    {}
func (*MsgSubmitDKGRound1Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_58d13e1023e3ffaf, []int{7}
}
func (m *MsgSubmitDKGRound1Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitDKGRound1Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitDKGRound1Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitDKGRound1Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitDKGRound1Response.Merge(m, src)
}
func (m *MsgSubmitDKGRound1Response) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitDKGRound1Response) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitDKGRound1Response.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitDKGRound1Response proto.InternalMessageInfo

// MsgSubmitDKGRound2 is the Msg/SubmitDKGRound2 request type.
type MsgSubmitDKGRound2 struct {
	// group_id is ID of the group.
	GroupID github_com_bandprotocol_chain_v2_pkg_tss.GroupID `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.GroupID" json:"group_id,omitempty"`
	// round2_info is all data that require to handle round 2.
	Round2Info Round2Info `protobuf:"bytes,2,opt,name=round2_info,json=round2Info,proto3" json:"round2_info"`
	// member is the signer of this message. Must be the member of this group.
	Member string `protobuf:"bytes,3,opt,name=member,proto3" json:"member,omitempty"`
}

func (m *MsgSubmitDKGRound2) Reset()         { *m = MsgSubmitDKGRound2{} }
func (m *MsgSubmitDKGRound2) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitDKGRound2) ProtoMessage()    {}
func (*MsgSubmitDKGRound2) Descriptor() ([]byte, []int) {
	return fileDescriptor_58d13e1023e3ffaf, []int{8}
}
func (m *MsgSubmitDKGRound2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitDKGRound2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitDKGRound2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitDKGRound2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitDKGRound2.Merge(m, src)
}
func (m *MsgSubmitDKGRound2) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitDKGRound2) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitDKGRound2.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitDKGRound2 proto.InternalMessageInfo

func (m *MsgSubmitDKGRound2) GetGroupID() github_com_bandprotocol_chain_v2_pkg_tss.GroupID {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *MsgSubmitDKGRound2) GetRound2Info() Round2Info {
	if m != nil {
		return m.Round2Info
	}
	return Round2Info{}
}

func (m *MsgSubmitDKGRound2) GetMember() string {
	if m != nil {
		return m.Member
	}
	return ""
}

// MsgSubmitDKGRound2Response is response data for MsgSubmitDKGRound2 message
type MsgSubmitDKGRound2Response struct {
}

func (m *MsgSubmitDKGRound2Response) Reset()         { *m = MsgSubmitDKGRound2Response{} }
func (m *MsgSubmitDKGRound2Response) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitDKGRound2Response) ProtoMessage()    {}
func (*MsgSubmitDKGRound2Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_58d13e1023e3ffaf, []int{9}
}
func (m *MsgSubmitDKGRound2Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitDKGRound2Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitDKGRound2Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitDKGRound2Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitDKGRound2Response.Merge(m, src)
}
func (m *MsgSubmitDKGRound2Response) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitDKGRound2Response) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitDKGRound2Response.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitDKGRound2Response proto.InternalMessageInfo

// MsgComplain is a message used to complain malicious actor in the group.
type MsgComplain struct {
	// group_id is ID of the group.
	GroupID github_com_bandprotocol_chain_v2_pkg_tss.GroupID `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.GroupID" json:"group_id,omitempty"`
	// complaints is a list of complains.
	Complaints []Complaint `protobuf:"bytes,2,rep,name=complaints,proto3" json:"complaints"`
	// member is the signer of this message. Must be the member of this group.
	Member string `protobuf:"bytes,3,opt,name=member,proto3" json:"member,omitempty"`
}

func (m *MsgComplain) Reset()         { *m = MsgComplain{} }
func (m *MsgComplain) String() string { return proto.CompactTextString(m) }
func (*MsgComplain) ProtoMessage()    {}
func (*MsgComplain) Descriptor() ([]byte, []int) {
	return fileDescriptor_58d13e1023e3ffaf, []int{10}
}
func (m *MsgComplain) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgComplain) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgComplain.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgComplain) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgComplain.Merge(m, src)
}
func (m *MsgComplain) XXX_Size() int {
	return m.Size()
}
func (m *MsgComplain) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgComplain.DiscardUnknown(m)
}

var xxx_messageInfo_MsgComplain proto.InternalMessageInfo

func (m *MsgComplain) GetGroupID() github_com_bandprotocol_chain_v2_pkg_tss.GroupID {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *MsgComplain) GetComplaints() []Complaint {
	if m != nil {
		return m.Complaints
	}
	return nil
}

func (m *MsgComplain) GetMember() string {
	if m != nil {
		return m.Member
	}
	return ""
}

// MsgComplainResponse is response data for MsgComplain message
type MsgComplainResponse struct {
}

func (m *MsgComplainResponse) Reset()         { *m = MsgComplainResponse{} }
func (m *MsgComplainResponse) String() string { return proto.CompactTextString(m) }
func (*MsgComplainResponse) ProtoMessage()    {}
func (*MsgComplainResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_58d13e1023e3ffaf, []int{11}
}
func (m *MsgComplainResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgComplainResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgComplainResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgComplainResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgComplainResponse.Merge(m, src)
}
func (m *MsgComplainResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgComplainResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgComplainResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgComplainResponse proto.InternalMessageInfo

// MsgConfirm is a message used to confirm own public key.
type MsgConfirm struct {
	// group_id is ID of the group.
	GroupID github_com_bandprotocol_chain_v2_pkg_tss.GroupID `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.GroupID" json:"group_id,omitempty"`
	// member_id is ID of the member.
	MemberID github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,2,opt,name=member_id,json=memberId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"member_id,omitempty"`
	// own_pub_key_sig is a signature of the member_i on its own PubKey to confirm
	// that the member is able to derive the PubKey.
	OwnPubKeySig github_com_bandprotocol_chain_v2_pkg_tss.Signature `protobuf:"bytes,3,opt,name=own_pub_key_sig,json=ownPubKeySig,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Signature" json:"own_pub_key_sig,omitempty"`
	// member is the signer of this message. Must be the member of this group.
	Member string `protobuf:"bytes,4,opt,name=member,proto3" json:"member,omitempty"`
}

func (m *MsgConfirm) Reset()         { *m = MsgConfirm{} }
func (m *MsgConfirm) String() string { return proto.CompactTextString(m) }
func (*MsgConfirm) ProtoMessage()    {}
func (*MsgConfirm) Descriptor() ([]byte, []int) {
	return fileDescriptor_58d13e1023e3ffaf, []int{12}
}
func (m *MsgConfirm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgConfirm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgConfirm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgConfirm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgConfirm.Merge(m, src)
}
func (m *MsgConfirm) XXX_Size() int {
	return m.Size()
}
func (m *MsgConfirm) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgConfirm.DiscardUnknown(m)
}

var xxx_messageInfo_MsgConfirm proto.InternalMessageInfo

func (m *MsgConfirm) GetGroupID() github_com_bandprotocol_chain_v2_pkg_tss.GroupID {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *MsgConfirm) GetMemberID() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.MemberID
	}
	return 0
}

func (m *MsgConfirm) GetOwnPubKeySig() github_com_bandprotocol_chain_v2_pkg_tss.Signature {
	if m != nil {
		return m.OwnPubKeySig
	}
	return nil
}

func (m *MsgConfirm) GetMember() string {
	if m != nil {
		return m.Member
	}
	return ""
}

// MsgConfirmResponse is response data for MsgConfirm message
type MsgConfirmResponse struct {
}

func (m *MsgConfirmResponse) Reset()         { *m = MsgConfirmResponse{} }
func (m *MsgConfirmResponse) String() string { return proto.CompactTextString(m) }
func (*MsgConfirmResponse) ProtoMessage()    {}
func (*MsgConfirmResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_58d13e1023e3ffaf, []int{13}
}
func (m *MsgConfirmResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgConfirmResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgConfirmResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgConfirmResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgConfirmResponse.Merge(m, src)
}
func (m *MsgConfirmResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgConfirmResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgConfirmResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgConfirmResponse proto.InternalMessageInfo

// MsgSubmitDEs is a message used to submit a list of DEs.
type MsgSubmitDEs struct {
	// des is a list of DE objects.
	DEs []DE `protobuf:"bytes,1,rep,name=des,proto3" json:"des"`
	// member is the signer of this submission message.
	Member string `protobuf:"bytes,2,opt,name=member,proto3" json:"member,omitempty"`
}

func (m *MsgSubmitDEs) Reset()         { *m = MsgSubmitDEs{} }
func (m *MsgSubmitDEs) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitDEs) ProtoMessage()    {}
func (*MsgSubmitDEs) Descriptor() ([]byte, []int) {
	return fileDescriptor_58d13e1023e3ffaf, []int{14}
}
func (m *MsgSubmitDEs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitDEs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitDEs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitDEs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitDEs.Merge(m, src)
}
func (m *MsgSubmitDEs) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitDEs) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitDEs.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitDEs proto.InternalMessageInfo

func (m *MsgSubmitDEs) GetDEs() []DE {
	if m != nil {
		return m.DEs
	}
	return nil
}

func (m *MsgSubmitDEs) GetMember() string {
	if m != nil {
		return m.Member
	}
	return ""
}

// MsgSubmitDEsResponse is response data for MsgSubmitDEs message
type MsgSubmitDEsResponse struct {
}

func (m *MsgSubmitDEsResponse) Reset()         { *m = MsgSubmitDEsResponse{} }
func (m *MsgSubmitDEsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitDEsResponse) ProtoMessage()    {}
func (*MsgSubmitDEsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_58d13e1023e3ffaf, []int{15}
}
func (m *MsgSubmitDEsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitDEsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitDEsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitDEsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitDEsResponse.Merge(m, src)
}
func (m *MsgSubmitDEsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitDEsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitDEsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitDEsResponse proto.InternalMessageInfo

// MsgRequestSignature is a request message used for initiating the signing process.
type MsgRequestSignature struct {
	// group_id is the unique identifier of the group.
	GroupID github_com_bandprotocol_chain_v2_pkg_tss.GroupID `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.GroupID" json:"group_id,omitempty"`
	// content defines an interface that a request signature type must implement.
	Content *types1.Any `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
	// feeLimit is the maximum tokens that will be paid for this request.
	FeeLimit github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,3,rep,name=fee_limit,json=feeLimit,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"fee_limit"`
	// sender is the requester of the signing process.
	Sender string `protobuf:"bytes,4,opt,name=sender,proto3" json:"sender,omitempty"`
}

func (m *MsgRequestSignature) Reset()         { *m = MsgRequestSignature{} }
func (m *MsgRequestSignature) String() string { return proto.CompactTextString(m) }
func (*MsgRequestSignature) ProtoMessage()    {}
func (*MsgRequestSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_58d13e1023e3ffaf, []int{16}
}
func (m *MsgRequestSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRequestSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRequestSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRequestSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRequestSignature.Merge(m, src)
}
func (m *MsgRequestSignature) XXX_Size() int {
	return m.Size()
}
func (m *MsgRequestSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRequestSignature.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRequestSignature proto.InternalMessageInfo

// MsgRequestSignatureResponse is response data for MsgRequestSignature message
type MsgRequestSignatureResponse struct {
}

func (m *MsgRequestSignatureResponse) Reset()         { *m = MsgRequestSignatureResponse{} }
func (m *MsgRequestSignatureResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRequestSignatureResponse) ProtoMessage()    {}
func (*MsgRequestSignatureResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_58d13e1023e3ffaf, []int{17}
}
func (m *MsgRequestSignatureResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRequestSignatureResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRequestSignatureResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRequestSignatureResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRequestSignatureResponse.Merge(m, src)
}
func (m *MsgRequestSignatureResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRequestSignatureResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRequestSignatureResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRequestSignatureResponse proto.InternalMessageInfo

// MsgSubmitSignature is a message used to submitting signature data.
type MsgSubmitSignature struct {
	// signing_id is the unique identifier of the signing process.
	SigningID github_com_bandprotocol_chain_v2_pkg_tss.SigningID `protobuf:"varint,1,opt,name=signing_id,json=signingId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.SigningID" json:"signing_id,omitempty"`
	// member_id is the unique identifier of the group member.
	MemberID github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,2,opt,name=member_id,json=memberId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"member_id,omitempty"`
	// signature is the signature produced by the member.
	Signature github_com_bandprotocol_chain_v2_pkg_tss.Signature `protobuf:"bytes,3,opt,name=signature,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Signature" json:"signature,omitempty"`
	// member is the signer of this signing message, who must be a member of the group.
	Member string `protobuf:"bytes,4,opt,name=member,proto3" json:"member,omitempty"`
}

func (m *MsgSubmitSignature) Reset()         { *m = MsgSubmitSignature{} }
func (m *MsgSubmitSignature) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitSignature) ProtoMessage()    {}
func (*MsgSubmitSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_58d13e1023e3ffaf, []int{18}
}
func (m *MsgSubmitSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitSignature.Merge(m, src)
}
func (m *MsgSubmitSignature) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitSignature.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitSignature proto.InternalMessageInfo

func (m *MsgSubmitSignature) GetSigningID() github_com_bandprotocol_chain_v2_pkg_tss.SigningID {
	if m != nil {
		return m.SigningID
	}
	return 0
}

func (m *MsgSubmitSignature) GetMemberID() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.MemberID
	}
	return 0
}

func (m *MsgSubmitSignature) GetSignature() github_com_bandprotocol_chain_v2_pkg_tss.Signature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *MsgSubmitSignature) GetMember() string {
	if m != nil {
		return m.Member
	}
	return ""
}

// MsgSubmitSignatureResponse is response data for MsgSubmitSignature message
type MsgSubmitSignatureResponse struct {
}

func (m *MsgSubmitSignatureResponse) Reset()         { *m = MsgSubmitSignatureResponse{} }
func (m *MsgSubmitSignatureResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitSignatureResponse) ProtoMessage()    {}
func (*MsgSubmitSignatureResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_58d13e1023e3ffaf, []int{19}
}
func (m *MsgSubmitSignatureResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitSignatureResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitSignatureResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitSignatureResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitSignatureResponse.Merge(m, src)
}
func (m *MsgSubmitSignatureResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitSignatureResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitSignatureResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitSignatureResponse proto.InternalMessageInfo

// MsgActivate is a message used to activate the status of the group's member.
type MsgActivate struct {
	// member is the signer of this message, who must be a member of the group.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *MsgActivate) Reset()         { *m = MsgActivate{} }
func (m *MsgActivate) String() string { return proto.CompactTextString(m) }
func (*MsgActivate) ProtoMessage()    {}
func (*MsgActivate) Descriptor() ([]byte, []int) {
	return fileDescriptor_58d13e1023e3ffaf, []int{20}
}
func (m *MsgActivate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgActivate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgActivate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgActivate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgActivate.Merge(m, src)
}
func (m *MsgActivate) XXX_Size() int {
	return m.Size()
}
func (m *MsgActivate) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgActivate.DiscardUnknown(m)
}

var xxx_messageInfo_MsgActivate proto.InternalMessageInfo

func (m *MsgActivate) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// MsgActivateResponse is response data for MsgActivate message
type MsgActivateResponse struct {
}

func (m *MsgActivateResponse) Reset()         { *m = MsgActivateResponse{} }
func (m *MsgActivateResponse) String() string { return proto.CompactTextString(m) }
func (*MsgActivateResponse) ProtoMessage()    {}
func (*MsgActivateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_58d13e1023e3ffaf, []int{21}
}
func (m *MsgActivateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgActivateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgActivateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgActivateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgActivateResponse.Merge(m, src)
}
func (m *MsgActivateResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgActivateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgActivateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgActivateResponse proto.InternalMessageInfo

// MsgActive is a message used to show if the member is still active.
type MsgActive struct {
	// member is the signer of this message, who must be a member of the group.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *MsgActive) Reset()         { *m = MsgActive{} }
func (m *MsgActive) String() string { return proto.CompactTextString(m) }
func (*MsgActive) ProtoMessage()    {}
func (*MsgActive) Descriptor() ([]byte, []int) {
	return fileDescriptor_58d13e1023e3ffaf, []int{22}
}
func (m *MsgActive) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgActive) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgActive.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgActive) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgActive.Merge(m, src)
}
func (m *MsgActive) XXX_Size() int {
	return m.Size()
}
func (m *MsgActive) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgActive.DiscardUnknown(m)
}

var xxx_messageInfo_MsgActive proto.InternalMessageInfo

func (m *MsgActive) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// MsgActiveResponse is response data for MsgActive message
type MsgActiveResponse struct {
}

func (m *MsgActiveResponse) Reset()         { *m = MsgActiveResponse{} }
func (m *MsgActiveResponse) String() string { return proto.CompactTextString(m) }
func (*MsgActiveResponse) ProtoMessage()    {}
func (*MsgActiveResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_58d13e1023e3ffaf, []int{23}
}
func (m *MsgActiveResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgActiveResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgActiveResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgActiveResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgActiveResponse.Merge(m, src)
}
func (m *MsgActiveResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgActiveResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgActiveResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgActiveResponse proto.InternalMessageInfo

// MsgUpdateParams is the Msg/UpdateParams request type.
//
// Since: cosmos-sdk 0.47
type MsgUpdateParams struct {
	// authority is the address of the governance account.
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// params defines the x/council parameters to update.
	//
	// NOTE: All parameters must be supplied.
	Params Params `protobuf:"bytes,2,opt,name=params,proto3" json:"params"`
}

func (m *MsgUpdateParams) Reset()         { *m = MsgUpdateParams{} }
func (m *MsgUpdateParams) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParams) ProtoMessage()    {}
func (*MsgUpdateParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_58d13e1023e3ffaf, []int{24}
}
func (m *MsgUpdateParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParams.Merge(m, src)
}
func (m *MsgUpdateParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo

func (m *MsgUpdateParams) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateParams) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

// MsgUpdateParamsResponse defines the response structure for executing a
// MsgUpdateParams message.
//
// Since: cosmos-sdk 0.47
type MsgUpdateParamsResponse struct {
}

func (m *MsgUpdateParamsResponse) Reset()         { *m = MsgUpdateParamsResponse{} }
func (m *MsgUpdateParamsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParamsResponse) ProtoMessage()    {}
func (*MsgUpdateParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_58d13e1023e3ffaf, []int{25}
}
func (m *MsgUpdateParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)
}
func (m *MsgUpdateParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgCreateGroup)(nil), "tss.v1beta1.MsgCreateGroup")
	proto.RegisterType((*MsgCreateGroupResponse)(nil), "tss.v1beta1.MsgCreateGroupResponse")
	proto.RegisterType((*MsgReplaceGroup)(nil), "tss.v1beta1.MsgReplaceGroup")
	proto.RegisterType((*MsgReplaceGroupResponse)(nil), "tss.v1beta1.MsgReplaceGroupResponse")
	proto.RegisterType((*MsgUpdateGroupFee)(nil), "tss.v1beta1.MsgUpdateGroupFee")
	proto.RegisterType((*MsgUpdateGroupFeeResponse)(nil), "tss.v1beta1.MsgUpdateGroupFeeResponse")
	proto.RegisterType((*MsgSubmitDKGRound1)(nil), "tss.v1beta1.MsgSubmitDKGRound1")
	proto.RegisterType((*MsgSubmitDKGRound1Response)(nil), "tss.v1beta1.MsgSubmitDKGRound1Response")
	proto.RegisterType((*MsgSubmitDKGRound2)(nil), "tss.v1beta1.MsgSubmitDKGRound2")
	proto.RegisterType((*MsgSubmitDKGRound2Response)(nil), "tss.v1beta1.MsgSubmitDKGRound2Response")
	proto.RegisterType((*MsgComplain)(nil), "tss.v1beta1.MsgComplain")
	proto.RegisterType((*MsgComplainResponse)(nil), "tss.v1beta1.MsgComplainResponse")
	proto.RegisterType((*MsgConfirm)(nil), "tss.v1beta1.MsgConfirm")
	proto.RegisterType((*MsgConfirmResponse)(nil), "tss.v1beta1.MsgConfirmResponse")
	proto.RegisterType((*MsgSubmitDEs)(nil), "tss.v1beta1.MsgSubmitDEs")
	proto.RegisterType((*MsgSubmitDEsResponse)(nil), "tss.v1beta1.MsgSubmitDEsResponse")
	proto.RegisterType((*MsgRequestSignature)(nil), "tss.v1beta1.MsgRequestSignature")
	proto.RegisterType((*MsgRequestSignatureResponse)(nil), "tss.v1beta1.MsgRequestSignatureResponse")
	proto.RegisterType((*MsgSubmitSignature)(nil), "tss.v1beta1.MsgSubmitSignature")
	proto.RegisterType((*MsgSubmitSignatureResponse)(nil), "tss.v1beta1.MsgSubmitSignatureResponse")
	proto.RegisterType((*MsgActivate)(nil), "tss.v1beta1.MsgActivate")
	proto.RegisterType((*MsgActivateResponse)(nil), "tss.v1beta1.MsgActivateResponse")
	proto.RegisterType((*MsgActive)(nil), "tss.v1beta1.MsgActive")
	proto.RegisterType((*MsgActiveResponse)(nil), "tss.v1beta1.MsgActiveResponse")
	proto.RegisterType((*MsgUpdateParams)(nil), "tss.v1beta1.MsgUpdateParams")
	proto.RegisterType((*MsgUpdateParamsResponse)(nil), "tss.v1beta1.MsgUpdateParamsResponse")
}

func init() { proto.RegisterFile("tss/v1beta1/tx.proto", fileDescriptor_58d13e1023e3ffaf) }

var fileDescriptor_58d13e1023e3ffaf = []byte{
	// 1410 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0x5f, 0x6f, 0x1b, 0x45,
	0x10, 0x8f, 0xed, 0x28, 0xf6, 0xcd, 0xa5, 0x4d, 0x7b, 0x71, 0x13, 0xe7, 0x92, 0xfa, 0x8c, 0x8b,
	0xa8, 0x55, 0x51, 0xbb, 0x39, 0xa4, 0x3e, 0x14, 0x04, 0xc4, 0xf9, 0x53, 0x55, 0x25, 0xa2, 0xba,
	0x14, 0x09, 0x15, 0xa8, 0x39, 0xdb, 0xeb, 0xcb, 0xa9, 0xb9, 0x5b, 0x73, 0xbb, 0x4e, 0x9b, 0x57,
	0x10, 0x02, 0x21, 0x24, 0xfa, 0x11, 0x78, 0x86, 0x97, 0x22, 0xf5, 0x43, 0x54, 0x3c, 0x55, 0x3c,
	0xf1, 0xe4, 0x22, 0xf7, 0xa1, 0x5f, 0x00, 0x21, 0x54, 0x09, 0x09, 0xdd, 0xde, 0xde, 0xf9, 0xfe,
	0x24, 0x76, 0x48, 0x94, 0x8a, 0x97, 0x38, 0xbb, 0x33, 0x3b, 0x33, 0xfb, 0xfb, 0xcd, 0xce, 0xcc,
	0x41, 0x9e, 0x12, 0x52, 0xdb, 0x5d, 0x6e, 0x22, 0xaa, 0x2f, 0xd7, 0xe8, 0x83, 0x6a, 0xd7, 0xc1,
	0x14, 0x4b, 0x22, 0x25, 0xa4, 0xca, 0x77, 0xe5, 0xbc, 0x81, 0x0d, 0xcc, 0xf6, 0x6b, 0xee, 0x7f,
	0x9e, 0x8a, 0xbc, 0x60, 0x60, 0x6c, 0xec, 0xa0, 0x1a, 0x5b, 0x35, 0x7b, 0x9d, 0x9a, 0x6e, 0xef,
	0x71, 0x91, 0x12, 0x17, 0x51, 0xd3, 0x42, 0x84, 0xea, 0x56, 0x97, 0x2b, 0x9c, 0xd5, 0x2d, 0xd3,
	0xc6, 0x35, 0xf6, 0x97, 0x6f, 0x15, 0x5b, 0x98, 0x58, 0x98, 0xd4, 0x9a, 0x3a, 0x41, 0x41, 0x3c,
	0x2d, 0x6c, 0xda, 0xbe, 0x3b, 0x4f, 0xde, 0xf0, 0xe2, 0xf0, 0x16, 0x5c, 0x34, 0xcf, 0x8f, 0x5a,
	0xc4, 0xa8, 0xed, 0x2e, 0xbb, 0x3f, 0x5c, 0x70, 0x2e, 0x72, 0x37, 0xe2, 0xeb, 0x2f, 0x84, 0xb7,
	0x0d, 0x64, 0x23, 0x62, 0x72, 0x51, 0xf9, 0xab, 0x34, 0x9c, 0xde, 0x24, 0xc6, 0xaa, 0x83, 0x74,
	0x8a, 0xae, 0x3b, 0xb8, 0xd7, 0x95, 0x0a, 0x90, 0xb5, 0x90, 0xd5, 0x44, 0x0e, 0x29, 0xa4, 0x4a,
	0x99, 0x8a, 0xa0, 0xf9, 0x4b, 0x69, 0x09, 0x04, 0xba, 0xed, 0x20, 0xb2, 0x8d, 0x77, 0xda, 0x85,
	0x74, 0x29, 0x55, 0x99, 0xd4, 0x86, 0x1b, 0xd2, 0x67, 0x90, 0xe9, 0x20, 0x54, 0xc8, 0x94, 0x32,
	0x15, 0x51, 0x5d, 0xa8, 0xf2, 0x88, 0xdd, 0xeb, 0xf9, 0xc0, 0x56, 0x57, 0xb1, 0x69, 0xd7, 0xaf,
	0x3c, 0xe9, 0x2b, 0x13, 0x3f, 0x3d, 0x53, 0x2a, 0x86, 0x49, 0xb7, 0x7b, 0xcd, 0x6a, 0x0b, 0x5b,
	0xfc, 0x7a, 0xfc, 0xe7, 0x32, 0x69, 0xdf, 0xab, 0xd1, 0xbd, 0x2e, 0x22, 0xec, 0x00, 0xd1, 0x5c,
	0xbb, 0xd2, 0x55, 0x10, 0xf4, 0x1e, 0xdd, 0xc6, 0x8e, 0x49, 0xf7, 0x0a, 0x93, 0xa5, 0x54, 0x45,
	0xa8, 0x17, 0x7e, 0x7b, 0x7c, 0x39, 0xcf, 0xfd, 0xac, 0xb4, 0xdb, 0x0e, 0x22, 0x64, 0x8b, 0x3a,
	0xa6, 0x6d, 0x68, 0x43, 0xd5, 0x6b, 0xe5, 0x2f, 0x5f, 0x3c, 0xba, 0x34, 0x5c, 0x7f, 0xf7, 0xe2,
	0xd1, 0xa5, 0x19, 0x17, 0x8f, 0xd0, 0x95, 0xcb, 0x05, 0x98, 0x8b, 0x82, 0xa0, 0x21, 0xd2, 0xc5,
	0x36, 0x41, 0xe5, 0x7f, 0xd2, 0x30, 0xb3, 0x49, 0x0c, 0x0d, 0x75, 0x77, 0xf4, 0x16, 0x07, 0xc8,
	0x80, 0x53, 0x1d, 0x07, 0x5b, 0x0d, 0xc3, 0x5d, 0x35, 0xcc, 0x76, 0x21, 0xe5, 0x42, 0x51, 0x5f,
	0x1d, 0xf4, 0x15, 0x71, 0xc3, 0xc1, 0x16, 0xd3, 0xba, 0xb1, 0xf6, 0xb2, 0xaf, 0x5c, 0x09, 0x5d,
	0xb1, 0xa9, 0xdb, 0x6d, 0x86, 0x79, 0x0b, 0xef, 0xd4, 0x5a, 0xdb, 0xba, 0x69, 0xd7, 0x76, 0xd5,
	0x5a, 0xf7, 0x9e, 0xc1, 0x88, 0xe2, 0x67, 0x34, 0xb1, 0x13, 0x18, 0x68, 0x4b, 0x3a, 0x88, 0x14,
	0x0f, 0xdd, 0x30, 0xc4, 0xeb, 0x2b, 0x83, 0xbe, 0x22, 0xdc, 0xc6, 0xc7, 0x71, 0x22, 0x50, 0xec,
	0xbb, 0x58, 0x01, 0x01, 0x3d, 0x40, 0xad, 0x86, 0x9b, 0xb0, 0x85, 0x4c, 0x29, 0x55, 0x11, 0x55,
	0xb9, 0xea, 0x65, 0x73, 0xd5, 0xcf, 0xe6, 0xea, 0x6d, 0x3f, 0x9b, 0xeb, 0x39, 0x97, 0xbb, 0x87,
	0xcf, 0x94, 0x94, 0x96, 0x73, 0x8f, 0xb9, 0x82, 0x23, 0x13, 0x73, 0x21, 0x49, 0xcc, 0x19, 0x97,
	0x98, 0x30, 0xd6, 0xe5, 0x05, 0x98, 0x8f, 0xc1, 0x1f, 0x50, 0xf3, 0x73, 0x1a, 0xce, 0x6e, 0x12,
	0xe3, 0xa3, 0x6e, 0xdb, 0x67, 0x6d, 0x03, 0x21, 0xe9, 0x0e, 0xe4, 0x62, 0xbc, 0xbc, 0x37, 0xe8,
	0x2b, 0xd9, 0xe3, 0xc0, 0x95, 0x35, 0x38, 0x58, 0xff, 0xd3, 0x0c, 0x3f, 0x14, 0x90, 0x8b, 0xb0,
	0x90, 0x00, 0x2b, 0x80, 0xf2, 0x9b, 0x34, 0x48, 0x9b, 0xc4, 0xd8, 0xea, 0x35, 0x2d, 0x93, 0xae,
	0xdd, 0xbc, 0xae, 0xe1, 0x9e, 0xdd, 0x5e, 0x3e, 0x51, 0x2c, 0xdf, 0x05, 0xd1, 0x61, 0x5e, 0x1a,
	0xa6, 0xdd, 0xc1, 0x2c, 0xb7, 0x45, 0x75, 0xbe, 0x1a, 0x2a, 0xc3, 0x55, 0x2f, 0x8a, 0x1b, 0x76,
	0x07, 0xd7, 0x27, 0x5d, 0x44, 0x35, 0x70, 0x82, 0x1d, 0xe9, 0x0a, 0x4c, 0x79, 0x65, 0x89, 0x65,
	0xed, 0x28, 0xa4, 0xb8, 0x9e, 0x07, 0x13, 0x5f, 0xb8, 0x18, 0xcd, 0xba, 0x18, 0xc5, 0xae, 0x5c,
	0x5e, 0x02, 0x39, 0x09, 0xc4, 0x68, 0x9c, 0xd4, 0x57, 0x82, 0x93, 0x3a, 0x06, 0x27, 0x35, 0x81,
	0x93, 0x7a, 0x72, 0x38, 0xa9, 0xfb, 0xe2, 0xa4, 0x06, 0x38, 0xfd, 0x9d, 0x02, 0xd1, 0x2d, 0xa8,
	0xd8, 0xea, 0xee, 0xe8, 0xa6, 0x7d, 0xa2, 0x00, 0xbd, 0x03, 0xd0, 0xe2, 0x7e, 0x28, 0x29, 0xa4,
	0xd9, 0xdb, 0x9c, 0x8b, 0xe0, 0xe3, 0x87, 0x41, 0x7d, 0x78, 0x86, 0xfa, 0x47, 0x80, 0xe7, 0x7c,
	0x0c, 0x9e, 0x53, 0xac, 0x99, 0xf8, 0x16, 0xcb, 0xe7, 0x60, 0x36, 0x74, 0xf3, 0x00, 0x91, 0xbf,
	0xd2, 0x00, 0x6c, 0xdf, 0xee, 0x98, 0x8e, 0x75, 0xa2, 0x80, 0xdc, 0x05, 0xc1, 0x8b, 0x2e, 0xda,
	0x33, 0x72, 0x9b, 0x6c, 0x93, 0x59, 0x5f, 0x3e, 0xb4, 0x75, 0xff, 0x90, 0x96, 0xf3, 0x6c, 0xb2,
	0x2a, 0x38, 0x83, 0xef, 0xdb, 0x8d, 0x6e, 0xaf, 0xd9, 0xb8, 0x87, 0xf6, 0x1a, 0xc4, 0x34, 0x18,
	0x76, 0xd3, 0xf5, 0xab, 0x2f, 0xfb, 0x8a, 0x7a, 0x68, 0xcb, 0x5b, 0xa6, 0x61, 0xeb, 0xb4, 0xe7,
	0x20, 0x6d, 0x1a, 0xdf, 0xb7, 0x6f, 0xf5, 0x9a, 0x37, 0xd1, 0xde, 0x96, 0x69, 0x84, 0x18, 0x99,
	0x3c, 0x24, 0x23, 0x8b, 0x31, 0x46, 0x44, 0x8f, 0x11, 0x86, 0x74, 0x39, 0xcf, 0x5e, 0x2c, 0x5f,
	0x05, 0x74, 0xfc, 0x90, 0x82, 0xe9, 0x61, 0xfe, 0xae, 0x13, 0xa9, 0x0a, 0x99, 0x36, 0xf2, 0x06,
	0x1e, 0x51, 0x9d, 0x89, 0xa4, 0xcf, 0xda, 0x7a, 0x5d, 0x74, 0xf3, 0x66, 0xd0, 0x57, 0x32, 0x6b,
	0xeb, 0x44, 0x73, 0x15, 0x43, 0x51, 0xa6, 0x8f, 0x93, 0x37, 0x41, 0x00, 0xe5, 0x39, 0xc8, 0x87,
	0x03, 0x0a, 0x22, 0xfd, 0x33, 0xcd, 0x12, 0x4a, 0x43, 0x5f, 0xf4, 0x10, 0xa1, 0x01, 0x68, 0x27,
	0x9a, 0x41, 0x6f, 0x43, 0xb6, 0x85, 0x6d, 0x8a, 0x6c, 0xca, 0xeb, 0x4d, 0x3e, 0x31, 0x12, 0xac,
	0xd8, 0x7b, 0x75, 0xf1, 0xd7, 0xc7, 0x97, 0xb3, 0xab, 0x9e, 0xa2, 0xe6, 0x9f, 0x90, 0xb6, 0x41,
	0xe8, 0x20, 0xd4, 0xd8, 0x31, 0x2d, 0x93, 0x9e, 0x44, 0xab, 0xcc, 0x75, 0x10, 0xfa, 0xc0, 0x35,
	0xee, 0x72, 0x40, 0x90, 0xdd, 0x3e, 0x4c, 0xa6, 0x78, 0x7a, 0xd7, 0x2a, 0xdf, 0xfe, 0xa8, 0x4c,
	0x30, 0x1e, 0xbc, 0x0d, 0x97, 0x87, 0xbc, 0xd7, 0x2a, 0xa3, 0xf0, 0x96, 0xcf, 0xc3, 0xe2, 0x3e,
	0xa8, 0x07, 0xac, 0x7c, 0x9d, 0x09, 0x35, 0x82, 0x21, 0x29, 0x4d, 0x00, 0x62, 0x1a, 0xb6, 0x69,
	0x1b, 0xd1, 0xb1, 0x50, 0xd8, 0xf2, 0x76, 0x19, 0x31, 0xff, 0xed, 0x89, 0xb0, 0x53, 0x9a, 0xc0,
	0xcd, 0xbe, 0x82, 0xe7, 0x7d, 0x1b, 0x98, 0x33, 0x76, 0xa1, 0x63, 0x3e, 0xec, 0xa1, 0xa1, 0x23,
	0xbc, 0xea, 0x11, 0x6d, 0x68, 0x48, 0x53, 0xb8, 0x0d, 0x25, 0x59, 0xfa, 0x9c, 0x75, 0xa1, 0x95,
	0x16, 0x35, 0x77, 0x75, 0x8a, 0x24, 0x15, 0xb2, 0xba, 0xe7, 0x8a, 0x51, 0x33, 0x2a, 0x08, 0x5f,
	0xd1, 0x7b, 0xb5, 0xfe, 0xca, 0x0d, 0x63, 0xda, 0x0d, 0xc3, 0x37, 0xc9, 0xab, 0xbd, 0xbf, 0x0c,
	0x1c, 0x7f, 0x0a, 0x82, 0xbf, 0x7d, 0x34, 0xb7, 0x8b, 0x71, 0xb7, 0x10, 0xb8, 0x45, 0xe5, 0x59,
	0x36, 0xf7, 0x7a, 0x8b, 0xc0, 0xe5, 0xf7, 0x29, 0xf6, 0xa1, 0xe2, 0x0d, 0x78, 0xb7, 0x74, 0x47,
	0xb7, 0x48, 0x74, 0xa0, 0x4c, 0x1d, 0x7a, 0xa0, 0x94, 0x96, 0x61, 0xaa, 0xcb, 0x2c, 0xf0, 0xe7,
	0x3f, 0x1b, 0xa9, 0x87, 0x9e, 0x71, 0xde, 0x4b, 0xb9, 0xe2, 0xb5, 0xd3, 0xd1, 0x19, 0x94, 0xcf,
	0xed, 0xe1, 0x68, 0xfc, 0x48, 0xd5, 0x5f, 0x72, 0x90, 0xd9, 0x24, 0x86, 0xf4, 0x21, 0x88, 0xe1,
	0xcf, 0xce, 0xc5, 0x88, 0x93, 0xe8, 0xe7, 0x98, 0x7c, 0x61, 0x84, 0xd0, 0x37, 0x2c, 0x69, 0x30,
	0x1d, 0xf9, 0x4e, 0x5b, 0x8a, 0x1f, 0x0a, 0x4b, 0xe5, 0xd7, 0x47, 0x49, 0x03, 0x9b, 0x1f, 0xc3,
	0xe9, 0xd8, 0x07, 0x46, 0x31, 0x7e, 0x2e, 0x2a, 0x97, 0xdf, 0x18, 0x2d, 0x0f, 0x2c, 0x7f, 0x02,
	0x33, 0xf1, 0x79, 0x5b, 0x89, 0x1f, 0x8d, 0x29, 0xc8, 0x17, 0xc7, 0x28, 0x1c, 0x6c, 0x5c, 0x1d,
	0x67, 0x5c, 0x1d, 0x67, 0x3c, 0x98, 0xee, 0xa4, 0x0d, 0xc8, 0x05, 0x93, 0x5d, 0x21, 0x41, 0x0c,
	0x97, 0xc8, 0xa5, 0x83, 0x24, 0x81, 0x9d, 0x55, 0xc8, 0xfa, 0xf3, 0xd0, 0x7c, 0x52, 0x99, 0x09,
	0x64, 0xe5, 0x00, 0x41, 0x60, 0xe4, 0x06, 0x08, 0xc3, 0x2e, 0xbe, 0x70, 0xc0, 0x15, 0xd6, 0x89,
	0xfc, 0xda, 0x81, 0xa2, 0xc0, 0xd4, 0x5d, 0x38, 0x93, 0x68, 0xb3, 0xa5, 0x64, 0x96, 0x44, 0x35,
	0xe4, 0xca, 0x38, 0x8d, 0x24, 0x29, 0x43, 0xf3, 0x07, 0x90, 0x32, 0xb4, 0x7e, 0x71, 0x8c, 0x42,
	0x98, 0x94, 0xa0, 0xd0, 0x25, 0x48, 0xf1, 0x25, 0x49, 0x52, 0xe2, 0xa5, 0x4b, 0x7a, 0x1f, 0xa6,
	0x78, 0xdd, 0x9a, 0xdb, 0x57, 0x17, 0xc9, 0xc5, 0xfd, 0xf7, 0xc3, 0xcf, 0x30, 0x52, 0x85, 0x96,
	0xf6, 0x7f, 0x10, 0x9e, 0x34, 0xf9, 0x0c, 0xf7, 0xab, 0x19, 0xf5, 0x8d, 0x27, 0x83, 0x62, 0xea,
	0xe9, 0xa0, 0x98, 0xfa, 0x63, 0x50, 0x4c, 0x3d, 0x7c, 0x5e, 0x9c, 0x78, 0xfa, 0xbc, 0x38, 0xf1,
	0xfb, 0xf3, 0xe2, 0xc4, 0x9d, 0x37, 0xc7, 0xf6, 0xa5, 0x07, 0x6e, 0x57, 0xf2, 0x46, 0x88, 0xe6,
	0x14, 0x13, 0xbf, 0xf5, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xd6, 0xe2, 0x86, 0xf6, 0x05, 0x14,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// CreateGroup creates a new group with a list of members.
	CreateGroup(ctx context.Context, in *MsgCreateGroup, opts ...grpc.CallOption) (*MsgCreateGroupResponse, error)
	// ReplaceGroup replaces the group with another group.
	ReplaceGroup(ctx context.Context, in *MsgReplaceGroup, opts ...grpc.CallOption) (*MsgReplaceGroupResponse, error)
	// UpdateGroupFee updates the group fee.
	UpdateGroupFee(ctx context.Context, in *MsgUpdateGroupFee, opts ...grpc.CallOption) (*MsgUpdateGroupFeeResponse, error)
	// SubmitDKGRound1 submits dkg for computing round 1.
	SubmitDKGRound1(ctx context.Context, in *MsgSubmitDKGRound1, opts ...grpc.CallOption) (*MsgSubmitDKGRound1Response, error)
	// SubmitDKGRound2 submits dkg for computing round 2.
	SubmitDKGRound2(ctx context.Context, in *MsgSubmitDKGRound2, opts ...grpc.CallOption) (*MsgSubmitDKGRound2Response, error)
	// Complain submits proof for complaining malicious.
	Complain(ctx context.Context, in *MsgComplain, opts ...grpc.CallOption) (*MsgComplainResponse, error)
	// Confirm submits own signature for proof that it can derive the secret.
	Confirm(ctx context.Context, in *MsgConfirm, opts ...grpc.CallOption) (*MsgConfirmResponse, error)
	// SubmitDEs submits list of pre-commits DE for signing process.
	SubmitDEs(ctx context.Context, in *MsgSubmitDEs, opts ...grpc.CallOption) (*MsgSubmitDEsResponse, error)
	// RequestSignature submits a general message to be signed by a specific group.
	RequestSignature(ctx context.Context, in *MsgRequestSignature, opts ...grpc.CallOption) (*MsgRequestSignatureResponse, error)
	// SubmitSignature submits signature on task participant need to do.
	SubmitSignature(ctx context.Context, in *MsgSubmitSignature, opts ...grpc.CallOption) (*MsgSubmitSignatureResponse, error)
	// Activate activates the status of the group's member.
	Activate(ctx context.Context, in *MsgActivate, opts ...grpc.CallOption) (*MsgActivateResponse, error)
	// Active marks last active of the mebmer.
	Active(ctx context.Context, in *MsgActive, opts ...grpc.CallOption) (*MsgActiveResponse, error)
	// UpdateParams defines a governance operation for updating the x/mint module
	// parameters.
	//
	// Since: cosmos-sdk 0.47
	UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) CreateGroup(ctx context.Context, in *MsgCreateGroup, opts ...grpc.CallOption) (*MsgCreateGroupResponse, error) {
	out := new(MsgCreateGroupResponse)
	err := c.cc.Invoke(ctx, "/tss.v1beta1.Msg/CreateGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ReplaceGroup(ctx context.Context, in *MsgReplaceGroup, opts ...grpc.CallOption) (*MsgReplaceGroupResponse, error) {
	out := new(MsgReplaceGroupResponse)
	err := c.cc.Invoke(ctx, "/tss.v1beta1.Msg/ReplaceGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateGroupFee(ctx context.Context, in *MsgUpdateGroupFee, opts ...grpc.CallOption) (*MsgUpdateGroupFeeResponse, error) {
	out := new(MsgUpdateGroupFeeResponse)
	err := c.cc.Invoke(ctx, "/tss.v1beta1.Msg/UpdateGroupFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitDKGRound1(ctx context.Context, in *MsgSubmitDKGRound1, opts ...grpc.CallOption) (*MsgSubmitDKGRound1Response, error) {
	out := new(MsgSubmitDKGRound1Response)
	err := c.cc.Invoke(ctx, "/tss.v1beta1.Msg/SubmitDKGRound1", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitDKGRound2(ctx context.Context, in *MsgSubmitDKGRound2, opts ...grpc.CallOption) (*MsgSubmitDKGRound2Response, error) {
	out := new(MsgSubmitDKGRound2Response)
	err := c.cc.Invoke(ctx, "/tss.v1beta1.Msg/SubmitDKGRound2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Complain(ctx context.Context, in *MsgComplain, opts ...grpc.CallOption) (*MsgComplainResponse, error) {
	out := new(MsgComplainResponse)
	err := c.cc.Invoke(ctx, "/tss.v1beta1.Msg/Complain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Confirm(ctx context.Context, in *MsgConfirm, opts ...grpc.CallOption) (*MsgConfirmResponse, error) {
	out := new(MsgConfirmResponse)
	err := c.cc.Invoke(ctx, "/tss.v1beta1.Msg/Confirm", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitDEs(ctx context.Context, in *MsgSubmitDEs, opts ...grpc.CallOption) (*MsgSubmitDEsResponse, error) {
	out := new(MsgSubmitDEsResponse)
	err := c.cc.Invoke(ctx, "/tss.v1beta1.Msg/SubmitDEs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RequestSignature(ctx context.Context, in *MsgRequestSignature, opts ...grpc.CallOption) (*MsgRequestSignatureResponse, error) {
	out := new(MsgRequestSignatureResponse)
	err := c.cc.Invoke(ctx, "/tss.v1beta1.Msg/RequestSignature", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitSignature(ctx context.Context, in *MsgSubmitSignature, opts ...grpc.CallOption) (*MsgSubmitSignatureResponse, error) {
	out := new(MsgSubmitSignatureResponse)
	err := c.cc.Invoke(ctx, "/tss.v1beta1.Msg/SubmitSignature", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Activate(ctx context.Context, in *MsgActivate, opts ...grpc.CallOption) (*MsgActivateResponse, error) {
	out := new(MsgActivateResponse)
	err := c.cc.Invoke(ctx, "/tss.v1beta1.Msg/Activate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Active(ctx context.Context, in *MsgActive, opts ...grpc.CallOption) (*MsgActiveResponse, error) {
	out := new(MsgActiveResponse)
	err := c.cc.Invoke(ctx, "/tss.v1beta1.Msg/Active", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/tss.v1beta1.Msg/UpdateParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// CreateGroup creates a new group with a list of members.
	CreateGroup(context.Context, *MsgCreateGroup) (*MsgCreateGroupResponse, error)
	// ReplaceGroup replaces the group with another group.
	ReplaceGroup(context.Context, *MsgReplaceGroup) (*MsgReplaceGroupResponse, error)
	// UpdateGroupFee updates the group fee.
	UpdateGroupFee(context.Context, *MsgUpdateGroupFee) (*MsgUpdateGroupFeeResponse, error)
	// SubmitDKGRound1 submits dkg for computing round 1.
	SubmitDKGRound1(context.Context, *MsgSubmitDKGRound1) (*MsgSubmitDKGRound1Response, error)
	// SubmitDKGRound2 submits dkg for computing round 2.
	SubmitDKGRound2(context.Context, *MsgSubmitDKGRound2) (*MsgSubmitDKGRound2Response, error)
	// Complain submits proof for complaining malicious.
	Complain(context.Context, *MsgComplain) (*MsgComplainResponse, error)
	// Confirm submits own signature for proof that it can derive the secret.
	Confirm(context.Context, *MsgConfirm) (*MsgConfirmResponse, error)
	// SubmitDEs submits list of pre-commits DE for signing process.
	SubmitDEs(context.Context, *MsgSubmitDEs) (*MsgSubmitDEsResponse, error)
	// RequestSignature submits a general message to be signed by a specific group.
	RequestSignature(context.Context, *MsgRequestSignature) (*MsgRequestSignatureResponse, error)
	// SubmitSignature submits signature on task participant need to do.
	SubmitSignature(context.Context, *MsgSubmitSignature) (*MsgSubmitSignatureResponse, error)
	// Activate activates the status of the group's member.
	Activate(context.Context, *MsgActivate) (*MsgActivateResponse, error)
	// Active marks last active of the mebmer.
	Active(context.Context, *MsgActive) (*MsgActiveResponse, error)
	// UpdateParams defines a governance operation for updating the x/mint module
	// parameters.
	//
	// Since: cosmos-sdk 0.47
	UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) CreateGroup(ctx context.Context, req *MsgCreateGroup) (*MsgCreateGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateGroup not implemented")
}
func (*UnimplementedMsgServer) ReplaceGroup(ctx context.Context, req *MsgReplaceGroup) (*MsgReplaceGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReplaceGroup not implemented")
}
func (*UnimplementedMsgServer) UpdateGroupFee(ctx context.Context, req *MsgUpdateGroupFee) (*MsgUpdateGroupFeeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGroupFee not implemented")
}
func (*UnimplementedMsgServer) SubmitDKGRound1(ctx context.Context, req *MsgSubmitDKGRound1) (*MsgSubmitDKGRound1Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitDKGRound1 not implemented")
}
func (*UnimplementedMsgServer) SubmitDKGRound2(ctx context.Context, req *MsgSubmitDKGRound2) (*MsgSubmitDKGRound2Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitDKGRound2 not implemented")
}
func (*UnimplementedMsgServer) Complain(ctx context.Context, req *MsgComplain) (*MsgComplainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Complain not implemented")
}
func (*UnimplementedMsgServer) Confirm(ctx context.Context, req *MsgConfirm) (*MsgConfirmResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Confirm not implemented")
}
func (*UnimplementedMsgServer) SubmitDEs(ctx context.Context, req *MsgSubmitDEs) (*MsgSubmitDEsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitDEs not implemented")
}
func (*UnimplementedMsgServer) RequestSignature(ctx context.Context, req *MsgRequestSignature) (*MsgRequestSignatureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestSignature not implemented")
}
func (*UnimplementedMsgServer) SubmitSignature(ctx context.Context, req *MsgSubmitSignature) (*MsgSubmitSignatureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitSignature not implemented")
}
func (*UnimplementedMsgServer) Activate(ctx context.Context, req *MsgActivate) (*MsgActivateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Activate not implemented")
}
func (*UnimplementedMsgServer) Active(ctx context.Context, req *MsgActive) (*MsgActiveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Active not implemented")
}
func (*UnimplementedMsgServer) UpdateParams(ctx context.Context, req *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_CreateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tss.v1beta1.Msg/CreateGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateGroup(ctx, req.(*MsgCreateGroup))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ReplaceGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgReplaceGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ReplaceGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tss.v1beta1.Msg/ReplaceGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ReplaceGroup(ctx, req.(*MsgReplaceGroup))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateGroupFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateGroupFee)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateGroupFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tss.v1beta1.Msg/UpdateGroupFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateGroupFee(ctx, req.(*MsgUpdateGroupFee))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitDKGRound1_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitDKGRound1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitDKGRound1(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tss.v1beta1.Msg/SubmitDKGRound1",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitDKGRound1(ctx, req.(*MsgSubmitDKGRound1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitDKGRound2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitDKGRound2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitDKGRound2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tss.v1beta1.Msg/SubmitDKGRound2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitDKGRound2(ctx, req.(*MsgSubmitDKGRound2))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Complain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgComplain)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Complain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tss.v1beta1.Msg/Complain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Complain(ctx, req.(*MsgComplain))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Confirm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgConfirm)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Confirm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tss.v1beta1.Msg/Confirm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Confirm(ctx, req.(*MsgConfirm))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitDEs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitDEs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitDEs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tss.v1beta1.Msg/SubmitDEs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitDEs(ctx, req.(*MsgSubmitDEs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RequestSignature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRequestSignature)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RequestSignature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tss.v1beta1.Msg/RequestSignature",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RequestSignature(ctx, req.(*MsgRequestSignature))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitSignature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitSignature)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitSignature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tss.v1beta1.Msg/SubmitSignature",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitSignature(ctx, req.(*MsgSubmitSignature))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Activate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgActivate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Activate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tss.v1beta1.Msg/Activate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Activate(ctx, req.(*MsgActivate))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Active_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgActive)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Active(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tss.v1beta1.Msg/Active",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Active(ctx, req.(*MsgActive))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tss.v1beta1.Msg/UpdateParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tss.v1beta1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateGroup",
			Handler:    _Msg_CreateGroup_Handler,
		},
		{
			MethodName: "ReplaceGroup",
			Handler:    _Msg_ReplaceGroup_Handler,
		},
		{
			MethodName: "UpdateGroupFee",
			Handler:    _Msg_UpdateGroupFee_Handler,
		},
		{
			MethodName: "SubmitDKGRound1",
			Handler:    _Msg_SubmitDKGRound1_Handler,
		},
		{
			MethodName: "SubmitDKGRound2",
			Handler:    _Msg_SubmitDKGRound2_Handler,
		},
		{
			MethodName: "Complain",
			Handler:    _Msg_Complain_Handler,
		},
		{
			MethodName: "Confirm",
			Handler:    _Msg_Confirm_Handler,
		},
		{
			MethodName: "SubmitDEs",
			Handler:    _Msg_SubmitDEs_Handler,
		},
		{
			MethodName: "RequestSignature",
			Handler:    _Msg_RequestSignature_Handler,
		},
		{
			MethodName: "SubmitSignature",
			Handler:    _Msg_SubmitSignature_Handler,
		},
		{
			MethodName: "Activate",
			Handler:    _Msg_Activate_Handler,
		},
		{
			MethodName: "Active",
			Handler:    _Msg_Active_Handler,
		},
		{
			MethodName: "UpdateParams",
			Handler:    _Msg_UpdateParams_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tss/v1beta1/tx.proto",
}

func (m *MsgCreateGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Fee) > 0 {
		for iNdEx := len(m.Fee) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fee[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Threshold != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Threshold))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Members[iNdEx])
			copy(dAtA[i:], m.Members[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.Members[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateGroupResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateGroupResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateGroupResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgReplaceGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgReplaceGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgReplaceGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0x22
	}
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ExecTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExecTime):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintTx(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x1a
	if m.ToGroupID != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ToGroupID))
		i--
		dAtA[i] = 0x10
	}
	if m.FromGroupID != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.FromGroupID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgReplaceGroupResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgReplaceGroupResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgReplaceGroupResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateGroupFee) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateGroupFee) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateGroupFee) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Fee) > 0 {
		for iNdEx := len(m.Fee) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fee[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.GroupID != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateGroupFeeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateGroupFeeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateGroupFeeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSubmitDKGRound1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitDKGRound1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitDKGRound1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Member) > 0 {
		i -= len(m.Member)
		copy(dAtA[i:], m.Member)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Member)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Round1Info.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.GroupID != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitDKGRound1Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitDKGRound1Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitDKGRound1Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSubmitDKGRound2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitDKGRound2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitDKGRound2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Member) > 0 {
		i -= len(m.Member)
		copy(dAtA[i:], m.Member)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Member)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Round2Info.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.GroupID != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitDKGRound2Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitDKGRound2Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitDKGRound2Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgComplain) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgComplain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgComplain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Member) > 0 {
		i -= len(m.Member)
		copy(dAtA[i:], m.Member)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Member)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Complaints) > 0 {
		for iNdEx := len(m.Complaints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Complaints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.GroupID != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgComplainResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgComplainResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgComplainResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgConfirm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgConfirm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgConfirm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Member) > 0 {
		i -= len(m.Member)
		copy(dAtA[i:], m.Member)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Member)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OwnPubKeySig) > 0 {
		i -= len(m.OwnPubKeySig)
		copy(dAtA[i:], m.OwnPubKeySig)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OwnPubKeySig)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MemberID != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.MemberID))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupID != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgConfirmResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgConfirmResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgConfirmResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSubmitDEs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitDEs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitDEs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Member) > 0 {
		i -= len(m.Member)
		copy(dAtA[i:], m.Member)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Member)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DEs) > 0 {
		for iNdEx := len(m.DEs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DEs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitDEsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitDEsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitDEsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgRequestSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRequestSignature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRequestSignature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FeeLimit) > 0 {
		for iNdEx := len(m.FeeLimit) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FeeLimit[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Content != nil {
		{
			size, err := m.Content.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.GroupID != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgRequestSignatureResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRequestSignatureResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRequestSignatureResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSubmitSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitSignature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitSignature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Member) > 0 {
		i -= len(m.Member)
		copy(dAtA[i:], m.Member)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Member)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MemberID != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.MemberID))
		i--
		dAtA[i] = 0x10
	}
	if m.SigningID != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SigningID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitSignatureResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitSignatureResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitSignatureResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgActivate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgActivate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgActivate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgActivateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgActivateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgActivateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgActive) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgActive) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgActive) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgActiveResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgActiveResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgActiveResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgCreateGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Members) > 0 {
		for _, s := range m.Members {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.Threshold != 0 {
		n += 1 + sovTx(uint64(m.Threshold))
	}
	if len(m.Fee) > 0 {
		for _, e := range m.Fee {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateGroupResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgReplaceGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FromGroupID != 0 {
		n += 1 + sovTx(uint64(m.FromGroupID))
	}
	if m.ToGroupID != 0 {
		n += 1 + sovTx(uint64(m.ToGroupID))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExecTime)
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgReplaceGroupResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateGroupFee) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupID != 0 {
		n += 1 + sovTx(uint64(m.GroupID))
	}
	if len(m.Fee) > 0 {
		for _, e := range m.Fee {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateGroupFeeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSubmitDKGRound1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupID != 0 {
		n += 1 + sovTx(uint64(m.GroupID))
	}
	l = m.Round1Info.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Member)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSubmitDKGRound1Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSubmitDKGRound2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupID != 0 {
		n += 1 + sovTx(uint64(m.GroupID))
	}
	l = m.Round2Info.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Member)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSubmitDKGRound2Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgComplain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupID != 0 {
		n += 1 + sovTx(uint64(m.GroupID))
	}
	if len(m.Complaints) > 0 {
		for _, e := range m.Complaints {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.Member)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgComplainResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgConfirm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupID != 0 {
		n += 1 + sovTx(uint64(m.GroupID))
	}
	if m.MemberID != 0 {
		n += 1 + sovTx(uint64(m.MemberID))
	}
	l = len(m.OwnPubKeySig)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Member)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgConfirmResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSubmitDEs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DEs) > 0 {
		for _, e := range m.DEs {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.Member)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSubmitDEsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgRequestSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupID != 0 {
		n += 1 + sovTx(uint64(m.GroupID))
	}
	if m.Content != nil {
		l = m.Content.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.FeeLimit) > 0 {
		for _, e := range m.FeeLimit {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRequestSignatureResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSubmitSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SigningID != 0 {
		n += 1 + sovTx(uint64(m.SigningID))
	}
	if m.MemberID != 0 {
		n += 1 + sovTx(uint64(m.MemberID))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Member)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSubmitSignatureResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgActivate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgActivateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgActive) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgActiveResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Params.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgCreateGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			m.Threshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Threshold |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fee = append(m.Fee, types.Coin{})
			if err := m.Fee[len(m.Fee)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateGroupResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateGroupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateGroupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgReplaceGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgReplaceGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgReplaceGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromGroupID", wireType)
			}
			m.FromGroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromGroupID |= github_com_bandprotocol_chain_v2_pkg_tss.GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToGroupID", wireType)
			}
			m.ToGroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToGroupID |= github_com_bandprotocol_chain_v2_pkg_tss.GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ExecTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgReplaceGroupResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgReplaceGroupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgReplaceGroupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateGroupFee) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateGroupFee: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateGroupFee: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= github_com_bandprotocol_chain_v2_pkg_tss.GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fee = append(m.Fee, types.Coin{})
			if err := m.Fee[len(m.Fee)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateGroupFeeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateGroupFeeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateGroupFeeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitDKGRound1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitDKGRound1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitDKGRound1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= github_com_bandprotocol_chain_v2_pkg_tss.GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round1Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Round1Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Member = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitDKGRound1Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitDKGRound1Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitDKGRound1Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitDKGRound2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitDKGRound2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitDKGRound2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= github_com_bandprotocol_chain_v2_pkg_tss.GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round2Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Round2Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Member = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitDKGRound2Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitDKGRound2Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitDKGRound2Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgComplain) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgComplain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgComplain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= github_com_bandprotocol_chain_v2_pkg_tss.GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Complaints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Complaints = append(m.Complaints, Complaint{})
			if err := m.Complaints[len(m.Complaints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Member = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgComplainResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgComplainResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgComplainResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgConfirm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgConfirm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgConfirm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= github_com_bandprotocol_chain_v2_pkg_tss.GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			m.MemberID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberID |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnPubKeySig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnPubKeySig = append(m.OwnPubKeySig[:0], dAtA[iNdEx:postIndex]...)
			if m.OwnPubKeySig == nil {
				m.OwnPubKeySig = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Member = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgConfirmResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgConfirmResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgConfirmResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitDEs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitDEs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitDEs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DEs = append(m.DEs, DE{})
			if err := m.DEs[len(m.DEs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Member = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitDEsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitDEsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitDEsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRequestSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRequestSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRequestSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= github_com_bandprotocol_chain_v2_pkg_tss.GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Content == nil {
				m.Content = &types1.Any{}
			}
			if err := m.Content.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeLimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeLimit = append(m.FeeLimit, types.Coin{})
			if err := m.FeeLimit[len(m.FeeLimit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRequestSignatureResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRequestSignatureResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRequestSignatureResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningID", wireType)
			}
			m.SigningID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SigningID |= github_com_bandprotocol_chain_v2_pkg_tss.SigningID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			m.MemberID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberID |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Member = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitSignatureResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitSignatureResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitSignatureResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgActivate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgActivate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgActivate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgActivateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgActivateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgActivateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgActive) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgActive: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgActive: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgActiveResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgActiveResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgActiveResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
