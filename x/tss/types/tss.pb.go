// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tss/v1beta1/tss.proto

package types

import (
	bytes "bytes"
	fmt "fmt"
	github_com_bandprotocol_chain_v2_pkg_tss "github.com/bandprotocol/chain/v2/pkg/tss"
	github_com_cometbft_cometbft_libs_bytes "github.com/cometbft/cometbft/libs/bytes"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ReplacementStatus is an enumeration of the possible statuses of a group replacement process.
type ReplacementStatus int32

const (
	// REPLACEMENT_STATUS_UNSPECIFIED is the status of a group replacement that has not been specified.
	REPLACEMENT_STATUS_UNSPECIFIED ReplacementStatus = 0
	// REPLACEMENT_STATUS_WAITING is the status of a group replacement that is waiting to be replaced in the
	// protocol.
	REPLACEMENT_STATUS_WAITING ReplacementStatus = 1
	// REPLACEMENT_STATUS_SUCCESS is the status of a group replacement that has success in the protocol.
	REPLACEMENT_STATUS_SUCCESS ReplacementStatus = 2
	// REPLACEMENT_STATUS_FALLEN is the status of a group replacement that has fallen out of the protocol.
	REPLACEMENT_STATUS_FALLEN ReplacementStatus = 3
)

var ReplacementStatus_name = map[int32]string{
	0: "REPLACEMENT_STATUS_UNSPECIFIED",
	1: "REPLACEMENT_STATUS_WAITING",
	2: "REPLACEMENT_STATUS_SUCCESS",
	3: "REPLACEMENT_STATUS_FALLEN",
}

var ReplacementStatus_value = map[string]int32{
	"REPLACEMENT_STATUS_UNSPECIFIED": 0,
	"REPLACEMENT_STATUS_WAITING":     1,
	"REPLACEMENT_STATUS_SUCCESS":     2,
	"REPLACEMENT_STATUS_FALLEN":      3,
}

func (x ReplacementStatus) String() string {
	return proto.EnumName(ReplacementStatus_name, int32(x))
}

func (ReplacementStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{0}
}

// SigningStatus is an enumeration of the possible statuses of a singing.
type SigningStatus int32

const (
	// SIGNING_STATUS_UNSPECIFIED is the status of a signing that has not been specified.
	SIGNING_STATUS_UNSPECIFIED SigningStatus = 0
	// SIGNING_STATUS_WAITING is the status of a signing that is waiting to be signed in the protocol.
	SIGNING_STATUS_WAITING SigningStatus = 1
	// SIGNING_STATUS_SUCCESS is the status of a signing that has success in the protocol.
	SIGNING_STATUS_SUCCESS SigningStatus = 2
	// SIGNING_STATUS_EXPIRED is the status of a signing that has expired in the protocol.
	SIGNING_STATUS_EXPIRED SigningStatus = 3
	// SIGNING_STATUS_FALLEN is the status of a signing that has fallen out of the protocol.
	SIGNING_STATUS_FALLEN SigningStatus = 4
)

var SigningStatus_name = map[int32]string{
	0: "SIGNING_STATUS_UNSPECIFIED",
	1: "SIGNING_STATUS_WAITING",
	2: "SIGNING_STATUS_SUCCESS",
	3: "SIGNING_STATUS_EXPIRED",
	4: "SIGNING_STATUS_FALLEN",
}

var SigningStatus_value = map[string]int32{
	"SIGNING_STATUS_UNSPECIFIED": 0,
	"SIGNING_STATUS_WAITING":     1,
	"SIGNING_STATUS_SUCCESS":     2,
	"SIGNING_STATUS_EXPIRED":     3,
	"SIGNING_STATUS_FALLEN":      4,
}

func (x SigningStatus) String() string {
	return proto.EnumName(SigningStatus_name, int32(x))
}

func (SigningStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{1}
}

// GroupStatus is an enumeration of the possible statuses of a group.
type GroupStatus int32

const (
	// GROUP_STATUS_UNSPECIFIED is the status of a group that has not been specified.
	GROUP_STATUS_UNSPECIFIED GroupStatus = 0
	// GROUP_STATUS_ROUND_1 is the status of a group that is in the first round of the protocol.
	GROUP_STATUS_ROUND_1 GroupStatus = 1
	// GROUP_STATUS_ROUND_2 is the status of a group that is in the second round of the protocol.
	GROUP_STATUS_ROUND_2 GroupStatus = 2
	// GROUP_STATUS_ROUND_3 is the status of a group that is in the third round of the protocol.
	GROUP_STATUS_ROUND_3 GroupStatus = 3
	// GROUP_STATUS_ACTIVE is the status of a group that is actively participating in the protocol.
	GROUP_STATUS_ACTIVE GroupStatus = 4
	// GROUP_STATUS_EXPIRED is the status of a group that has expired in the protocol.
	GROUP_STATUS_EXPIRED GroupStatus = 5
	// GROUP_STATUS_FALLEN is the status of a group that has fallen out of the protocol.
	GROUP_STATUS_FALLEN GroupStatus = 6
)

var GroupStatus_name = map[int32]string{
	0: "GROUP_STATUS_UNSPECIFIED",
	1: "GROUP_STATUS_ROUND_1",
	2: "GROUP_STATUS_ROUND_2",
	3: "GROUP_STATUS_ROUND_3",
	4: "GROUP_STATUS_ACTIVE",
	5: "GROUP_STATUS_EXPIRED",
	6: "GROUP_STATUS_FALLEN",
}

var GroupStatus_value = map[string]int32{
	"GROUP_STATUS_UNSPECIFIED": 0,
	"GROUP_STATUS_ROUND_1":     1,
	"GROUP_STATUS_ROUND_2":     2,
	"GROUP_STATUS_ROUND_3":     3,
	"GROUP_STATUS_ACTIVE":      4,
	"GROUP_STATUS_EXPIRED":     5,
	"GROUP_STATUS_FALLEN":      6,
}

func (x GroupStatus) String() string {
	return proto.EnumName(GroupStatus_name, int32(x))
}

func (GroupStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{2}
}

// ComplaintStatus represents the status of a complaint.
type ComplaintStatus int32

const (
	// COMPLAINT_STATUS_UNSPECIFIED represents an undefined status of the complaint.
	COMPLAINT_STATUS_UNSPECIFIED ComplaintStatus = 0
	// COMPLAINT_STATUS_SUCCESS represents a successful complaint.
	COMPLAINT_STATUS_SUCCESS ComplaintStatus = 1
	// COMPLAINT_STATUS_FAILED represents a failed complaint.
	COMPLAINT_STATUS_FAILED ComplaintStatus = 2
)

var ComplaintStatus_name = map[int32]string{
	0: "COMPLAINT_STATUS_UNSPECIFIED",
	1: "COMPLAINT_STATUS_SUCCESS",
	2: "COMPLAINT_STATUS_FAILED",
}

var ComplaintStatus_value = map[string]int32{
	"COMPLAINT_STATUS_UNSPECIFIED": 0,
	"COMPLAINT_STATUS_SUCCESS":     1,
	"COMPLAINT_STATUS_FAILED":      2,
}

func (x ComplaintStatus) String() string {
	return proto.EnumName(ComplaintStatus_name, int32(x))
}

func (ComplaintStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{3}
}

// PrefixMsgType is an enumeration of the possible prefixes of a singing msg.
type PrefixMsgType int32

const (
	// PREFIX_MSG_TYPE_UNSPECIFIED is the type of prefix that has not been specified.
	PREFIX_MSG_TYPE_UNSPECIFIED PrefixMsgType = 0
	// PREFIX_MSG_TYPE_TEXT is the type of prefix that signs a text msg in the protocol.
	PREFIX_MSG_TYPE_TEXT PrefixMsgType = 1
	// PREFIX_MSG_TYPE_REPLACE_GROUP is the type of prefix that signs a replace group msg in the protocol.
	PREFIX_MSG_TYPE_REPLACE_GROUP PrefixMsgType = 2
	// PREFIX_MSG_TYPE_ORACLE is the type of prefix that signs an oracle result msg in the protocol.
	PREFIX_MSG_TYPE_ORACLE PrefixMsgType = 3
)

var PrefixMsgType_name = map[int32]string{
	0: "PREFIX_MSG_TYPE_UNSPECIFIED",
	1: "PREFIX_MSG_TYPE_TEXT",
	2: "PREFIX_MSG_TYPE_REPLACE_GROUP",
	3: "PREFIX_MSG_TYPE_ORACLE",
}

var PrefixMsgType_value = map[string]int32{
	"PREFIX_MSG_TYPE_UNSPECIFIED":   0,
	"PREFIX_MSG_TYPE_TEXT":          1,
	"PREFIX_MSG_TYPE_REPLACE_GROUP": 2,
	"PREFIX_MSG_TYPE_ORACLE":        3,
}

func (x PrefixMsgType) String() string {
	return proto.EnumName(PrefixMsgType_name, int32(x))
}

func (PrefixMsgType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{4}
}

// Group is a type representing a participant group in a Distributed Key Generation or signing process.
type Group struct {
	// id is the unique identifier of the group.
	ID github_com_bandprotocol_chain_v2_pkg_tss.GroupID `protobuf:"varint,1,opt,name=id,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.GroupID" json:"id,omitempty"`
	// size is the number of members in the group.
	Size_ uint64 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	// threshold is the minimum number of members needed to generate a valid signature.
	Threshold uint64 `protobuf:"varint,3,opt,name=threshold,proto3" json:"threshold,omitempty"`
	// pub_key is the public key generated by the group after successful completion of the DKG process.
	PubKey github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,4,opt,name=pub_key,json=pubKey,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"pub_key,omitempty"`
	// status represents the current stage of the group in the DKG or signing process.
	Status GroupStatus `protobuf:"varint,5,opt,name=status,proto3,enum=tss.v1beta1.GroupStatus" json:"status,omitempty"`
	// latest_replacement_id is the latest replacement ID of the group.
	LatestReplacementID uint64 `protobuf:"varint,6,opt,name=latest_replacement_id,json=latestReplacementId,proto3" json:"latest_replacement_id,omitempty"`
	// created_height is the block height when the group was created.
	CreatedHeight uint64 `protobuf:"varint,7,opt,name=created_height,json=createdHeight,proto3" json:"created_height,omitempty"`
	// module_owner is the module that creates this group.
	ModuleOwner string `protobuf:"bytes,8,opt,name=module_owner,json=moduleOwner,proto3" json:"module_owner,omitempty"`
}

func (m *Group) Reset()         { *m = Group{} }
func (m *Group) String() string { return proto.CompactTextString(m) }
func (*Group) ProtoMessage()    {}
func (*Group) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{0}
}
func (m *Group) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Group) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Group.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Group) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Group.Merge(m, src)
}
func (m *Group) XXX_Size() int {
	return m.Size()
}
func (m *Group) XXX_DiscardUnknown() {
	xxx_messageInfo_Group.DiscardUnknown(m)
}

var xxx_messageInfo_Group proto.InternalMessageInfo

func (m *Group) GetID() github_com_bandprotocol_chain_v2_pkg_tss.GroupID {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Group) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *Group) GetThreshold() uint64 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

func (m *Group) GetPubKey() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.PubKey
	}
	return nil
}

func (m *Group) GetStatus() GroupStatus {
	if m != nil {
		return m.Status
	}
	return GROUP_STATUS_UNSPECIFIED
}

func (m *Group) GetLatestReplacementID() uint64 {
	if m != nil {
		return m.LatestReplacementID
	}
	return 0
}

func (m *Group) GetCreatedHeight() uint64 {
	if m != nil {
		return m.CreatedHeight
	}
	return 0
}

func (m *Group) GetModuleOwner() string {
	if m != nil {
		return m.ModuleOwner
	}
	return ""
}

// Replacement represents a group that will replaced with another group in the replacement process.
type Replacement struct {
	// id is the unique identifier of the replacement.
	ID uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// signing_id is the unique identifier of the signing process.
	SigningID github_com_bandprotocol_chain_v2_pkg_tss.SigningID `protobuf:"varint,2,opt,name=signing_id,json=signingId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.SigningID" json:"signing_id,omitempty"`
	// current_group_id is the ID of the group that will be replaced.
	CurrentGroupID github_com_bandprotocol_chain_v2_pkg_tss.GroupID `protobuf:"varint,3,opt,name=current_group_id,json=currentGroupId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.GroupID" json:"current_group_id,omitempty"`
	// current_pub_key is the public key pair that used for sign & verify replace group msg.
	CurrentPubKey github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,4,opt,name=current_pub_key,json=currentPubKey,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"current_pub_key,omitempty"`
	// new_group_id is the ID of the new group that be a new key candidate.
	NewGroupID github_com_bandprotocol_chain_v2_pkg_tss.GroupID `protobuf:"varint,5,opt,name=new_group_id,json=newGroupId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.GroupID" json:"new_group_id,omitempty"`
	// new_pub_key is the public key of the group that will be the next key of this group
	NewPubKey github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,6,opt,name=new_pub_key,json=newPubKey,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"new_pub_key,omitempty"`
	// status is an enumeration of the possible statuses of a group replacement process.
	Status ReplacementStatus `protobuf:"varint,7,opt,name=status,proto3,enum=tss.v1beta1.ReplacementStatus" json:"status,omitempty"`
	// exec_time is the time that will be substituted in place of the group.
	ExecTime time.Time `protobuf:"bytes,8,opt,name=exec_time,json=execTime,proto3,stdtime" json:"exec_time"`
}

func (m *Replacement) Reset()         { *m = Replacement{} }
func (m *Replacement) String() string { return proto.CompactTextString(m) }
func (*Replacement) ProtoMessage()    {}
func (*Replacement) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{1}
}
func (m *Replacement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Replacement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Replacement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Replacement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Replacement.Merge(m, src)
}
func (m *Replacement) XXX_Size() int {
	return m.Size()
}
func (m *Replacement) XXX_DiscardUnknown() {
	xxx_messageInfo_Replacement.DiscardUnknown(m)
}

var xxx_messageInfo_Replacement proto.InternalMessageInfo

func (m *Replacement) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Replacement) GetSigningID() github_com_bandprotocol_chain_v2_pkg_tss.SigningID {
	if m != nil {
		return m.SigningID
	}
	return 0
}

func (m *Replacement) GetCurrentGroupID() github_com_bandprotocol_chain_v2_pkg_tss.GroupID {
	if m != nil {
		return m.CurrentGroupID
	}
	return 0
}

func (m *Replacement) GetCurrentPubKey() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.CurrentPubKey
	}
	return nil
}

func (m *Replacement) GetNewGroupID() github_com_bandprotocol_chain_v2_pkg_tss.GroupID {
	if m != nil {
		return m.NewGroupID
	}
	return 0
}

func (m *Replacement) GetNewPubKey() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.NewPubKey
	}
	return nil
}

func (m *Replacement) GetStatus() ReplacementStatus {
	if m != nil {
		return m.Status
	}
	return REPLACEMENT_STATUS_UNSPECIFIED
}

func (m *Replacement) GetExecTime() time.Time {
	if m != nil {
		return m.ExecTime
	}
	return time.Time{}
}

// Round1Info contains all necessary information for handling round 1 of the DKG process.
type Round1Info struct {
	// member_id is the unique identifier of a group member.
	MemberID github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,1,opt,name=member_id,json=memberId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"member_id,omitempty"`
	// coefficients_commits is a list of commitments to the coefficients of the member's secret polynomial.
	CoefficientCommits github_com_bandprotocol_chain_v2_pkg_tss.Points `protobuf:"bytes,2,rep,name=coefficient_commits,json=coefficientCommits,proto3,castrepeated=github.com/bandprotocol/chain/v2/pkg/tss.Points" json:"coefficient_commits,omitempty"`
	// one_time_pub_key is the one-time public key used by the member to encrypt secret shares.
	OneTimePubKey github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,3,opt,name=one_time_pub_key,json=oneTimePubKey,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"one_time_pub_key,omitempty"`
	// a0_signature is the member's signature on the first coefficient of its secret polynomial.
	A0Signature github_com_bandprotocol_chain_v2_pkg_tss.Signature `protobuf:"bytes,4,opt,name=a0_signature,json=a0Signature,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Signature" json:"a0_signature,omitempty"`
	// one_time_signature is the member's signature on its one-time public key.
	OneTimeSignature github_com_bandprotocol_chain_v2_pkg_tss.Signature `protobuf:"bytes,5,opt,name=one_time_signature,json=oneTimeSignature,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Signature" json:"one_time_signature,omitempty"`
}

func (m *Round1Info) Reset()         { *m = Round1Info{} }
func (m *Round1Info) String() string { return proto.CompactTextString(m) }
func (*Round1Info) ProtoMessage()    {}
func (*Round1Info) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{2}
}
func (m *Round1Info) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Round1Info) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Round1Info.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Round1Info) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Round1Info.Merge(m, src)
}
func (m *Round1Info) XXX_Size() int {
	return m.Size()
}
func (m *Round1Info) XXX_DiscardUnknown() {
	xxx_messageInfo_Round1Info.DiscardUnknown(m)
}

var xxx_messageInfo_Round1Info proto.InternalMessageInfo

func (m *Round1Info) GetMemberID() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.MemberID
	}
	return 0
}

func (m *Round1Info) GetCoefficientCommits() github_com_bandprotocol_chain_v2_pkg_tss.Points {
	if m != nil {
		return m.CoefficientCommits
	}
	return nil
}

func (m *Round1Info) GetOneTimePubKey() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.OneTimePubKey
	}
	return nil
}

func (m *Round1Info) GetA0Signature() github_com_bandprotocol_chain_v2_pkg_tss.Signature {
	if m != nil {
		return m.A0Signature
	}
	return nil
}

func (m *Round1Info) GetOneTimeSignature() github_com_bandprotocol_chain_v2_pkg_tss.Signature {
	if m != nil {
		return m.OneTimeSignature
	}
	return nil
}

// Round2Info contains all necessary information for handling round 2 of the DKG process.
type Round2Info struct {
	// member_id is the unique identifier of a group member.
	MemberID github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,1,opt,name=member_id,json=memberId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"member_id,omitempty"`
	// encrypted_secret_shares is a list of secret shares encrypted under the public keys of other members.
	EncryptedSecretShares github_com_bandprotocol_chain_v2_pkg_tss.EncSecretShares `protobuf:"bytes,2,rep,name=encrypted_secret_shares,json=encryptedSecretShares,proto3,castrepeated=github.com/bandprotocol/chain/v2/pkg/tss.EncSecretShares" json:"encrypted_secret_shares,omitempty"`
}

func (m *Round2Info) Reset()         { *m = Round2Info{} }
func (m *Round2Info) String() string { return proto.CompactTextString(m) }
func (*Round2Info) ProtoMessage()    {}
func (*Round2Info) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{3}
}
func (m *Round2Info) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Round2Info) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Round2Info.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Round2Info) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Round2Info.Merge(m, src)
}
func (m *Round2Info) XXX_Size() int {
	return m.Size()
}
func (m *Round2Info) XXX_DiscardUnknown() {
	xxx_messageInfo_Round2Info.DiscardUnknown(m)
}

var xxx_messageInfo_Round2Info proto.InternalMessageInfo

func (m *Round2Info) GetMemberID() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.MemberID
	}
	return 0
}

func (m *Round2Info) GetEncryptedSecretShares() github_com_bandprotocol_chain_v2_pkg_tss.EncSecretShares {
	if m != nil {
		return m.EncryptedSecretShares
	}
	return nil
}

// DE contains the public parts of a member's decryption and encryption keys.
type DE struct {
	// pub_d is the public value of own commitment (D).
	PubD github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,1,opt,name=pub_d,json=pubD,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"pub_d,omitempty"`
	// pub_e is the public value of own commitment (E).
	PubE github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,2,opt,name=pub_e,json=pubE,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"pub_e,omitempty"`
}

func (m *DE) Reset()         { *m = DE{} }
func (m *DE) String() string { return proto.CompactTextString(m) }
func (*DE) ProtoMessage()    {}
func (*DE) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{4}
}
func (m *DE) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DE) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DE.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DE) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DE.Merge(m, src)
}
func (m *DE) XXX_Size() int {
	return m.Size()
}
func (m *DE) XXX_DiscardUnknown() {
	xxx_messageInfo_DE.DiscardUnknown(m)
}

var xxx_messageInfo_DE proto.InternalMessageInfo

func (m *DE) GetPubD() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.PubD
	}
	return nil
}

func (m *DE) GetPubE() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.PubE
	}
	return nil
}

// DEQueue is a simple queue data structure for holding DE objects.
type DEQueue struct {
	// address is the address of the de holder.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// head is the index of the first element in the queue.
	Head uint64 `protobuf:"varint,2,opt,name=head,proto3" json:"head,omitempty"`
	// tail is the index of the last element in the queue.
	Tail uint64 `protobuf:"varint,3,opt,name=tail,proto3" json:"tail,omitempty"`
}

func (m *DEQueue) Reset()         { *m = DEQueue{} }
func (m *DEQueue) String() string { return proto.CompactTextString(m) }
func (*DEQueue) ProtoMessage()    {}
func (*DEQueue) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{5}
}
func (m *DEQueue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DEQueue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DEQueue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DEQueue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DEQueue.Merge(m, src)
}
func (m *DEQueue) XXX_Size() int {
	return m.Size()
}
func (m *DEQueue) XXX_DiscardUnknown() {
	xxx_messageInfo_DEQueue.DiscardUnknown(m)
}

var xxx_messageInfo_DEQueue proto.InternalMessageInfo

func (m *DEQueue) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *DEQueue) GetHead() uint64 {
	if m != nil {
		return m.Head
	}
	return 0
}

func (m *DEQueue) GetTail() uint64 {
	if m != nil {
		return m.Tail
	}
	return 0
}

// Signing contains all necessary information for handling a signing request.
type Signing struct {
	// id is the unique identifier of the signing.
	ID github_com_bandprotocol_chain_v2_pkg_tss.SigningID `protobuf:"varint,1,opt,name=id,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.SigningID" json:"id,omitempty"`
	// group_id is the unique identifier of the group.
	GroupID github_com_bandprotocol_chain_v2_pkg_tss.GroupID `protobuf:"varint,2,opt,name=group_id,json=groupId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.GroupID" json:"group_id,omitempty"`
	// group_pub_key is the public key of the group that sign this message.
	GroupPubKey github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,3,opt,name=group_pub_key,json=groupPubKey,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"group_pub_key,omitempty"`
	// assigned_members is a list of members assigned to the signing process.
	AssignedMembers AssignedMembers `protobuf:"bytes,4,rep,name=assigned_members,json=assignedMembers,proto3,castrepeated=AssignedMembers" json:"assigned_members"`
	// message is the message to be signed.
	Message github_com_cometbft_cometbft_libs_bytes.HexBytes `protobuf:"bytes,5,opt,name=message,proto3,casttype=github.com/cometbft/cometbft/libs/bytes.HexBytes" json:"message,omitempty"`
	// group_pub_nonce is the public nonce generated by the group for this signing process.
	GroupPubNonce github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,6,opt,name=group_pub_nonce,json=groupPubNonce,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"group_pub_nonce,omitempty"`
	// signature is the group's signature on the message.
	Signature github_com_bandprotocol_chain_v2_pkg_tss.Signature `protobuf:"bytes,7,opt,name=signature,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Signature" json:"signature,omitempty"`
	// status represents the current stage of the signing in the signing process.
	Status SigningStatus `protobuf:"varint,8,opt,name=status,proto3,enum=tss.v1beta1.SigningStatus" json:"status,omitempty"`
	// created_height is the block height when the signing was created.
	CreatedHeight uint64 `protobuf:"varint,9,opt,name=created_height,json=createdHeight,proto3" json:"created_height,omitempty"`
}

func (m *Signing) Reset()         { *m = Signing{} }
func (m *Signing) String() string { return proto.CompactTextString(m) }
func (*Signing) ProtoMessage()    {}
func (*Signing) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{6}
}
func (m *Signing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Signing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Signing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Signing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signing.Merge(m, src)
}
func (m *Signing) XXX_Size() int {
	return m.Size()
}
func (m *Signing) XXX_DiscardUnknown() {
	xxx_messageInfo_Signing.DiscardUnknown(m)
}

var xxx_messageInfo_Signing proto.InternalMessageInfo

func (m *Signing) GetID() github_com_bandprotocol_chain_v2_pkg_tss.SigningID {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Signing) GetGroupID() github_com_bandprotocol_chain_v2_pkg_tss.GroupID {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *Signing) GetGroupPubKey() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.GroupPubKey
	}
	return nil
}

func (m *Signing) GetAssignedMembers() AssignedMembers {
	if m != nil {
		return m.AssignedMembers
	}
	return nil
}

func (m *Signing) GetMessage() github_com_cometbft_cometbft_libs_bytes.HexBytes {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *Signing) GetGroupPubNonce() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.GroupPubNonce
	}
	return nil
}

func (m *Signing) GetSignature() github_com_bandprotocol_chain_v2_pkg_tss.Signature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *Signing) GetStatus() SigningStatus {
	if m != nil {
		return m.Status
	}
	return SIGNING_STATUS_UNSPECIFIED
}

func (m *Signing) GetCreatedHeight() uint64 {
	if m != nil {
		return m.CreatedHeight
	}
	return 0
}

// AssignedMember is a type representing a member that has been assigned to a signing process.
type AssignedMember struct {
	// member_id is the unique identifier of the member.
	MemberID github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,1,opt,name=member_id,json=memberId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"member_id,omitempty"`
	// member is the human-readable name of the member.
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	// pub_key is the public part of a member.
	PubKey github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,3,opt,name=pub_key,json=pubKey,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"pub_key,omitempty"`
	// pub_d is the public part of a member's decryption key.
	PubD github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,4,opt,name=pub_d,json=pubD,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"pub_d,omitempty"`
	// pub_e is the public part of a member's encryption key.
	PubE github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,5,opt,name=pub_e,json=pubE,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"pub_e,omitempty"`
	// binding_factor is the binding factor of the member for the signing process.
	BindingFactor github_com_bandprotocol_chain_v2_pkg_tss.Scalar `protobuf:"bytes,6,opt,name=binding_factor,json=bindingFactor,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Scalar" json:"binding_factor,omitempty"`
	// pub_nonce is the public nonce of the member for the signing process.
	PubNonce github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,7,opt,name=pub_nonce,json=pubNonce,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"pub_nonce,omitempty"`
}

func (m *AssignedMember) Reset()         { *m = AssignedMember{} }
func (m *AssignedMember) String() string { return proto.CompactTextString(m) }
func (*AssignedMember) ProtoMessage()    {}
func (*AssignedMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{7}
}
func (m *AssignedMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssignedMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssignedMember.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssignedMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssignedMember.Merge(m, src)
}
func (m *AssignedMember) XXX_Size() int {
	return m.Size()
}
func (m *AssignedMember) XXX_DiscardUnknown() {
	xxx_messageInfo_AssignedMember.DiscardUnknown(m)
}

var xxx_messageInfo_AssignedMember proto.InternalMessageInfo

func (m *AssignedMember) GetMemberID() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.MemberID
	}
	return 0
}

func (m *AssignedMember) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *AssignedMember) GetPubKey() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.PubKey
	}
	return nil
}

func (m *AssignedMember) GetPubD() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.PubD
	}
	return nil
}

func (m *AssignedMember) GetPubE() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.PubE
	}
	return nil
}

func (m *AssignedMember) GetBindingFactor() github_com_bandprotocol_chain_v2_pkg_tss.Scalar {
	if m != nil {
		return m.BindingFactor
	}
	return nil
}

func (m *AssignedMember) GetPubNonce() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.PubNonce
	}
	return nil
}

// PendingSignings is a list of all signing processes that are currently pending.
type PendingSignings struct {
	// signing_ids is a list of identifiers for the signing processes.
	SigningIds []uint64 `protobuf:"varint,1,rep,packed,name=signing_ids,json=signingIds,proto3" json:"signing_ids,omitempty"`
}

func (m *PendingSignings) Reset()         { *m = PendingSignings{} }
func (m *PendingSignings) String() string { return proto.CompactTextString(m) }
func (*PendingSignings) ProtoMessage()    {}
func (*PendingSignings) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{8}
}
func (m *PendingSignings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PendingSignings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PendingSignings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PendingSignings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PendingSignings.Merge(m, src)
}
func (m *PendingSignings) XXX_Size() int {
	return m.Size()
}
func (m *PendingSignings) XXX_DiscardUnknown() {
	xxx_messageInfo_PendingSignings.DiscardUnknown(m)
}

var xxx_messageInfo_PendingSignings proto.InternalMessageInfo

func (m *PendingSignings) GetSigningIds() []uint64 {
	if m != nil {
		return m.SigningIds
	}
	return nil
}

// Member is a type representing a member of the group.
type Member struct {
	// id is the unique identifier of a member.
	ID github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,1,opt,name=id,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"id,omitempty"`
	// group_id is the group id of this member.
	GroupID github_com_bandprotocol_chain_v2_pkg_tss.GroupID `protobuf:"varint,2,opt,name=group_id,json=groupId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.GroupID" json:"group_id,omitempty"`
	// address is the address of the member.
	Address string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	// pub_key is the public key of the member.
	PubKey github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,4,opt,name=pub_key,json=pubKey,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"pub_key,omitempty"`
	// is_malicious is a boolean flag indicating whether the member is considered malicious.
	IsMalicious bool `protobuf:"varint,5,opt,name=is_malicious,json=isMalicious,proto3" json:"is_malicious,omitempty"`
	// is_active is a boolean flag indicating whether the member is currently active in the protocol.
	IsActive bool `protobuf:"varint,6,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
}

func (m *Member) Reset()         { *m = Member{} }
func (m *Member) String() string { return proto.CompactTextString(m) }
func (*Member) ProtoMessage()    {}
func (*Member) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{9}
}
func (m *Member) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Member) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Member.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Member) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Member.Merge(m, src)
}
func (m *Member) XXX_Size() int {
	return m.Size()
}
func (m *Member) XXX_DiscardUnknown() {
	xxx_messageInfo_Member.DiscardUnknown(m)
}

var xxx_messageInfo_Member proto.InternalMessageInfo

func (m *Member) GetID() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Member) GetGroupID() github_com_bandprotocol_chain_v2_pkg_tss.GroupID {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *Member) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Member) GetPubKey() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.PubKey
	}
	return nil
}

func (m *Member) GetIsMalicious() bool {
	if m != nil {
		return m.IsMalicious
	}
	return false
}

func (m *Member) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

// Confirm is a message type used to confirm participation in the protocol.
type Confirm struct {
	// member_id is the unique identifier of a group member.
	MemberID github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,1,opt,name=member_id,json=memberId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"member_id,omitempty"`
	// own_pub_key_sig is a signature over the member's own public key.
	OwnPubKeySig github_com_bandprotocol_chain_v2_pkg_tss.Signature `protobuf:"bytes,2,opt,name=own_pub_key_sig,json=ownPubKeySig,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Signature" json:"own_pub_key_sig,omitempty"`
}

func (m *Confirm) Reset()         { *m = Confirm{} }
func (m *Confirm) String() string { return proto.CompactTextString(m) }
func (*Confirm) ProtoMessage()    {}
func (*Confirm) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{10}
}
func (m *Confirm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Confirm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Confirm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Confirm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Confirm.Merge(m, src)
}
func (m *Confirm) XXX_Size() int {
	return m.Size()
}
func (m *Confirm) XXX_DiscardUnknown() {
	xxx_messageInfo_Confirm.DiscardUnknown(m)
}

var xxx_messageInfo_Confirm proto.InternalMessageInfo

func (m *Confirm) GetMemberID() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.MemberID
	}
	return 0
}

func (m *Confirm) GetOwnPubKeySig() github_com_bandprotocol_chain_v2_pkg_tss.Signature {
	if m != nil {
		return m.OwnPubKeySig
	}
	return nil
}

// Complaint is a message type used to issue a complaint against a member.
type Complaint struct {
	// complainant is the member issuing the complaint.
	Complainant github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,1,opt,name=complainant,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"complainant,omitempty"`
	// respondent is the member against whom the complaint is issued.
	Respondent github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,2,opt,name=respondent,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"respondent,omitempty"`
	// key_sym is a symmetric key between respondent's private key and respondent's public key.
	KeySym github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,3,opt,name=key_sym,json=keySym,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"key_sym,omitempty"`
	// signature is the complaint signature that can do a symmetric key validation and complaint verification.
	Signature github_com_bandprotocol_chain_v2_pkg_tss.ComplaintSignature `protobuf:"bytes,4,opt,name=signature,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.ComplaintSignature" json:"signature,omitempty"`
}

func (m *Complaint) Reset()         { *m = Complaint{} }
func (m *Complaint) String() string { return proto.CompactTextString(m) }
func (*Complaint) ProtoMessage()    {}
func (*Complaint) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{11}
}
func (m *Complaint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Complaint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Complaint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Complaint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Complaint.Merge(m, src)
}
func (m *Complaint) XXX_Size() int {
	return m.Size()
}
func (m *Complaint) XXX_DiscardUnknown() {
	xxx_messageInfo_Complaint.DiscardUnknown(m)
}

var xxx_messageInfo_Complaint proto.InternalMessageInfo

func (m *Complaint) GetComplainant() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.Complainant
	}
	return 0
}

func (m *Complaint) GetRespondent() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.Respondent
	}
	return 0
}

func (m *Complaint) GetKeySym() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.KeySym
	}
	return nil
}

func (m *Complaint) GetSignature() github_com_bandprotocol_chain_v2_pkg_tss.ComplaintSignature {
	if m != nil {
		return m.Signature
	}
	return nil
}

// ComplaintWithStatus contains information about a complaint with its status.
type ComplaintWithStatus struct {
	// complaint is the information about the complaint.
	Complaint Complaint `protobuf:"bytes,1,opt,name=complaint,proto3" json:"complaint"`
	// complaint_status is the status of the complaint.
	ComplaintStatus ComplaintStatus `protobuf:"varint,2,opt,name=complaint_status,json=complaintStatus,proto3,enum=tss.v1beta1.ComplaintStatus" json:"complaint_status,omitempty"`
}

func (m *ComplaintWithStatus) Reset()         { *m = ComplaintWithStatus{} }
func (m *ComplaintWithStatus) String() string { return proto.CompactTextString(m) }
func (*ComplaintWithStatus) ProtoMessage()    {}
func (*ComplaintWithStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{12}
}
func (m *ComplaintWithStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplaintWithStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplaintWithStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplaintWithStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplaintWithStatus.Merge(m, src)
}
func (m *ComplaintWithStatus) XXX_Size() int {
	return m.Size()
}
func (m *ComplaintWithStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplaintWithStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ComplaintWithStatus proto.InternalMessageInfo

func (m *ComplaintWithStatus) GetComplaint() Complaint {
	if m != nil {
		return m.Complaint
	}
	return Complaint{}
}

func (m *ComplaintWithStatus) GetComplaintStatus() ComplaintStatus {
	if m != nil {
		return m.ComplaintStatus
	}
	return COMPLAINT_STATUS_UNSPECIFIED
}

// ComplaintsWithStatus contains information about multiple complaints and their status from a single member.
type ComplaintsWithStatus struct {
	// member_id is the identifier of the member filing the complaints.
	MemberID github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,1,opt,name=member_id,json=memberId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"member_id,omitempty"`
	// complaints_with_status is the list of complaints with their status from this member.
	ComplaintsWithStatus []ComplaintWithStatus `protobuf:"bytes,2,rep,name=complaints_with_status,json=complaintsWithStatus,proto3" json:"complaints_with_status"`
}

func (m *ComplaintsWithStatus) Reset()         { *m = ComplaintsWithStatus{} }
func (m *ComplaintsWithStatus) String() string { return proto.CompactTextString(m) }
func (*ComplaintsWithStatus) ProtoMessage()    {}
func (*ComplaintsWithStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{13}
}
func (m *ComplaintsWithStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplaintsWithStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplaintsWithStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplaintsWithStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplaintsWithStatus.Merge(m, src)
}
func (m *ComplaintsWithStatus) XXX_Size() int {
	return m.Size()
}
func (m *ComplaintsWithStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplaintsWithStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ComplaintsWithStatus proto.InternalMessageInfo

func (m *ComplaintsWithStatus) GetMemberID() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.MemberID
	}
	return 0
}

func (m *ComplaintsWithStatus) GetComplaintsWithStatus() []ComplaintWithStatus {
	if m != nil {
		return m.ComplaintsWithStatus
	}
	return nil
}

// PendingProcessGroups is a list of groups that are waiting to be processed.
type PendingProcessGroups struct {
	// group_ids is a list of group IDs.
	GroupIDs []github_com_bandprotocol_chain_v2_pkg_tss.GroupID `protobuf:"varint,1,rep,packed,name=group_ids,json=groupIds,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.GroupID" json:"group_ids,omitempty"`
}

func (m *PendingProcessGroups) Reset()         { *m = PendingProcessGroups{} }
func (m *PendingProcessGroups) String() string { return proto.CompactTextString(m) }
func (*PendingProcessGroups) ProtoMessage()    {}
func (*PendingProcessGroups) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{14}
}
func (m *PendingProcessGroups) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PendingProcessGroups) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PendingProcessGroups.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PendingProcessGroups) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PendingProcessGroups.Merge(m, src)
}
func (m *PendingProcessGroups) XXX_Size() int {
	return m.Size()
}
func (m *PendingProcessGroups) XXX_DiscardUnknown() {
	xxx_messageInfo_PendingProcessGroups.DiscardUnknown(m)
}

var xxx_messageInfo_PendingProcessGroups proto.InternalMessageInfo

func (m *PendingProcessGroups) GetGroupIDs() []github_com_bandprotocol_chain_v2_pkg_tss.GroupID {
	if m != nil {
		return m.GroupIDs
	}
	return nil
}

// PendingProcessSignigns is a list of signings that are waiting to be processed.
type PendingProcessSignings struct {
	// signing_ids is a list of signing IDs.
	SigningIDs []github_com_bandprotocol_chain_v2_pkg_tss.SigningID `protobuf:"varint,1,rep,packed,name=signing_ids,json=signingIds,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.SigningID" json:"signing_ids,omitempty"`
}

func (m *PendingProcessSignings) Reset()         { *m = PendingProcessSignings{} }
func (m *PendingProcessSignings) String() string { return proto.CompactTextString(m) }
func (*PendingProcessSignings) ProtoMessage()    {}
func (*PendingProcessSignings) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{15}
}
func (m *PendingProcessSignings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PendingProcessSignings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PendingProcessSignings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PendingProcessSignings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PendingProcessSignings.Merge(m, src)
}
func (m *PendingProcessSignings) XXX_Size() int {
	return m.Size()
}
func (m *PendingProcessSignings) XXX_DiscardUnknown() {
	xxx_messageInfo_PendingProcessSignings.DiscardUnknown(m)
}

var xxx_messageInfo_PendingProcessSignings proto.InternalMessageInfo

func (m *PendingProcessSignings) GetSigningIDs() []github_com_bandprotocol_chain_v2_pkg_tss.SigningID {
	if m != nil {
		return m.SigningIDs
	}
	return nil
}

// PartialSignature contains information about a member's partial signature.
type PartialSignature struct {
	// member_id is the identifier of the member providing the partial signature.
	MemberID github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,1,opt,name=member_id,json=memberId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"member_id,omitempty"`
	// signature is the partial signature provided by this member.
	Signature github_com_bandprotocol_chain_v2_pkg_tss.Signature `protobuf:"bytes,2,opt,name=signature,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Signature" json:"signature,omitempty"`
}

func (m *PartialSignature) Reset()         { *m = PartialSignature{} }
func (m *PartialSignature) String() string { return proto.CompactTextString(m) }
func (*PartialSignature) ProtoMessage()    {}
func (*PartialSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{16}
}
func (m *PartialSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartialSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartialSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartialSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartialSignature.Merge(m, src)
}
func (m *PartialSignature) XXX_Size() int {
	return m.Size()
}
func (m *PartialSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_PartialSignature.DiscardUnknown(m)
}

var xxx_messageInfo_PartialSignature proto.InternalMessageInfo

func (m *PartialSignature) GetMemberID() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.MemberID
	}
	return 0
}

func (m *PartialSignature) GetSignature() github_com_bandprotocol_chain_v2_pkg_tss.Signature {
	if m != nil {
		return m.Signature
	}
	return nil
}

// TextSignatureOrder defines a general text signature order.
type TextSignatureOrder struct {
	// message is the data that needs to be signed.
	Message github_com_cometbft_cometbft_libs_bytes.HexBytes `protobuf:"bytes,1,opt,name=message,proto3,casttype=github.com/cometbft/cometbft/libs/bytes.HexBytes" json:"message,omitempty"`
}

func (m *TextSignatureOrder) Reset()         { *m = TextSignatureOrder{} }
func (m *TextSignatureOrder) String() string { return proto.CompactTextString(m) }
func (*TextSignatureOrder) ProtoMessage()    {}
func (*TextSignatureOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{17}
}
func (m *TextSignatureOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TextSignatureOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TextSignatureOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TextSignatureOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TextSignatureOrder.Merge(m, src)
}
func (m *TextSignatureOrder) XXX_Size() int {
	return m.Size()
}
func (m *TextSignatureOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_TextSignatureOrder.DiscardUnknown(m)
}

var xxx_messageInfo_TextSignatureOrder proto.InternalMessageInfo

func (m *TextSignatureOrder) GetMessage() github_com_cometbft_cometbft_libs_bytes.HexBytes {
	if m != nil {
		return m.Message
	}
	return nil
}

// EVMSignature defines a signature in the EVM format.
type EVMSignature struct {
	// r_address is the address of the nonce for using in the contract.
	RAddress github_com_cometbft_cometbft_libs_bytes.HexBytes `protobuf:"bytes,1,opt,name=r_address,json=rAddress,proto3,casttype=github.com/cometbft/cometbft/libs/bytes.HexBytes" json:"r_address,omitempty"`
	// signature is the signature part for using in the contract.
	Signature github_com_cometbft_cometbft_libs_bytes.HexBytes `protobuf:"bytes,2,opt,name=signature,proto3,casttype=github.com/cometbft/cometbft/libs/bytes.HexBytes" json:"signature,omitempty"`
}

func (m *EVMSignature) Reset()         { *m = EVMSignature{} }
func (m *EVMSignature) String() string { return proto.CompactTextString(m) }
func (*EVMSignature) ProtoMessage()    {}
func (*EVMSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{18}
}
func (m *EVMSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EVMSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EVMSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EVMSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EVMSignature.Merge(m, src)
}
func (m *EVMSignature) XXX_Size() int {
	return m.Size()
}
func (m *EVMSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_EVMSignature.DiscardUnknown(m)
}

var xxx_messageInfo_EVMSignature proto.InternalMessageInfo

func (m *EVMSignature) GetRAddress() github_com_cometbft_cometbft_libs_bytes.HexBytes {
	if m != nil {
		return m.RAddress
	}
	return nil
}

func (m *EVMSignature) GetSignature() github_com_cometbft_cometbft_libs_bytes.HexBytes {
	if m != nil {
		return m.Signature
	}
	return nil
}

// SigningResult is a bandtss signing result from querying bandtss signing information.
type SigningResult struct {
	// signing is the tss signing result.
	Signing Signing `protobuf:"bytes,1,opt,name=signing,proto3" json:"signing"`
	// evm_signature is the signature in the format that can use directly in EVM.
	EVMSignature *EVMSignature `protobuf:"bytes,2,opt,name=evm_signature,json=evmSignature,proto3" json:"evm_signature,omitempty"`
	// received_partial_signatures is a list of received partial signatures.
	ReceivedPartialSignatures []PartialSignature `protobuf:"bytes,3,rep,name=received_partial_signatures,json=receivedPartialSignatures,proto3" json:"received_partial_signatures"`
}

func (m *SigningResult) Reset()         { *m = SigningResult{} }
func (m *SigningResult) String() string { return proto.CompactTextString(m) }
func (*SigningResult) ProtoMessage()    {}
func (*SigningResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{19}
}
func (m *SigningResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SigningResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SigningResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SigningResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SigningResult.Merge(m, src)
}
func (m *SigningResult) XXX_Size() int {
	return m.Size()
}
func (m *SigningResult) XXX_DiscardUnknown() {
	xxx_messageInfo_SigningResult.DiscardUnknown(m)
}

var xxx_messageInfo_SigningResult proto.InternalMessageInfo

func (m *SigningResult) GetSigning() Signing {
	if m != nil {
		return m.Signing
	}
	return Signing{}
}

func (m *SigningResult) GetEVMSignature() *EVMSignature {
	if m != nil {
		return m.EVMSignature
	}
	return nil
}

func (m *SigningResult) GetReceivedPartialSignatures() []PartialSignature {
	if m != nil {
		return m.ReceivedPartialSignatures
	}
	return nil
}

func init() {
	proto.RegisterEnum("tss.v1beta1.ReplacementStatus", ReplacementStatus_name, ReplacementStatus_value)
	proto.RegisterEnum("tss.v1beta1.SigningStatus", SigningStatus_name, SigningStatus_value)
	proto.RegisterEnum("tss.v1beta1.GroupStatus", GroupStatus_name, GroupStatus_value)
	proto.RegisterEnum("tss.v1beta1.ComplaintStatus", ComplaintStatus_name, ComplaintStatus_value)
	proto.RegisterEnum("tss.v1beta1.PrefixMsgType", PrefixMsgType_name, PrefixMsgType_value)
	proto.RegisterType((*Group)(nil), "tss.v1beta1.Group")
	proto.RegisterType((*Replacement)(nil), "tss.v1beta1.Replacement")
	proto.RegisterType((*Round1Info)(nil), "tss.v1beta1.Round1Info")
	proto.RegisterType((*Round2Info)(nil), "tss.v1beta1.Round2Info")
	proto.RegisterType((*DE)(nil), "tss.v1beta1.DE")
	proto.RegisterType((*DEQueue)(nil), "tss.v1beta1.DEQueue")
	proto.RegisterType((*Signing)(nil), "tss.v1beta1.Signing")
	proto.RegisterType((*AssignedMember)(nil), "tss.v1beta1.AssignedMember")
	proto.RegisterType((*PendingSignings)(nil), "tss.v1beta1.PendingSignings")
	proto.RegisterType((*Member)(nil), "tss.v1beta1.Member")
	proto.RegisterType((*Confirm)(nil), "tss.v1beta1.Confirm")
	proto.RegisterType((*Complaint)(nil), "tss.v1beta1.Complaint")
	proto.RegisterType((*ComplaintWithStatus)(nil), "tss.v1beta1.ComplaintWithStatus")
	proto.RegisterType((*ComplaintsWithStatus)(nil), "tss.v1beta1.ComplaintsWithStatus")
	proto.RegisterType((*PendingProcessGroups)(nil), "tss.v1beta1.PendingProcessGroups")
	proto.RegisterType((*PendingProcessSignings)(nil), "tss.v1beta1.PendingProcessSignings")
	proto.RegisterType((*PartialSignature)(nil), "tss.v1beta1.PartialSignature")
	proto.RegisterType((*TextSignatureOrder)(nil), "tss.v1beta1.TextSignatureOrder")
	proto.RegisterType((*EVMSignature)(nil), "tss.v1beta1.EVMSignature")
	proto.RegisterType((*SigningResult)(nil), "tss.v1beta1.SigningResult")
}

func init() { proto.RegisterFile("tss/v1beta1/tss.proto", fileDescriptor_321be6f53cb0491e) }

var fileDescriptor_321be6f53cb0491e = []byte{
	// 2022 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0xcd, 0x6f, 0xdb, 0xc8,
	0x15, 0x37, 0x25, 0xd9, 0x92, 0x9e, 0xfc, 0xa1, 0x4e, 0x9c, 0x58, 0xfe, 0x88, 0xe4, 0x08, 0x28,
	0x60, 0x2c, 0xba, 0x56, 0xac, 0x6c, 0x17, 0x45, 0x76, 0x81, 0xad, 0x3e, 0x68, 0xaf, 0x36, 0xb6,
	0xac, 0xa5, 0xe4, 0x24, 0x9b, 0x76, 0x4b, 0x50, 0xe4, 0x58, 0x22, 0x22, 0x92, 0x2a, 0x87, 0xf2,
	0x47, 0x2f, 0xbd, 0xf6, 0x50, 0xa0, 0x7b, 0xda, 0x43, 0xdb, 0x5b, 0x7b, 0x28, 0x72, 0xde, 0xfe,
	0x0f, 0x69, 0x7b, 0x59, 0x14, 0x3d, 0xec, 0x49, 0x29, 0x94, 0x43, 0xaf, 0x3d, 0x07, 0x3d, 0x14,
	0x43, 0x0e, 0x3f, 0xf4, 0x61, 0xd4, 0x91, 0xe2, 0xde, 0xc8, 0xf7, 0x66, 0x7e, 0xf3, 0xe6, 0xcd,
	0x6f, 0x7e, 0xef, 0x91, 0x70, 0xdb, 0x22, 0x24, 0x77, 0xb6, 0xd7, 0xc4, 0x96, 0xb4, 0x97, 0xb3,
	0x08, 0xd9, 0xed, 0x9a, 0x86, 0x65, 0xa0, 0x04, 0x7d, 0x64, 0xe6, 0x8d, 0xd5, 0x96, 0xd1, 0x32,
	0x6c, 0x7b, 0x8e, 0x3e, 0x39, 0x43, 0x36, 0x32, 0x2d, 0xc3, 0x68, 0x75, 0x70, 0xce, 0x7e, 0x6b,
	0xf6, 0x4e, 0x73, 0x96, 0xaa, 0x61, 0x62, 0x49, 0x5a, 0x97, 0x0d, 0x48, 0xcb, 0x06, 0xd1, 0x0c,
	0x92, 0x6b, 0x4a, 0x04, 0x7b, 0x4b, 0xc8, 0x86, 0xaa, 0x33, 0xff, 0xba, 0xe3, 0x17, 0x1d, 0x64,
	0xe7, 0xc5, 0x71, 0x65, 0x7f, 0x17, 0x86, 0xf9, 0x03, 0xd3, 0xe8, 0x75, 0xd1, 0x67, 0x10, 0x52,
	0x95, 0x14, 0xb7, 0xcd, 0xed, 0x44, 0x8a, 0x0f, 0x07, 0xfd, 0x4c, 0xa8, 0x52, 0x7e, 0xd3, 0xcf,
	0xdc, 0x6f, 0xa9, 0x56, 0xbb, 0xd7, 0xdc, 0x95, 0x0d, 0x2d, 0xd7, 0x94, 0x74, 0xc5, 0x9e, 0x25,
	0x1b, 0x9d, 0x9c, 0xdc, 0x96, 0x54, 0x3d, 0x77, 0x96, 0xcf, 0x75, 0x9f, 0xb7, 0xec, 0xed, 0xd8,
	0x28, 0x95, 0xb2, 0x10, 0x52, 0x15, 0x84, 0x20, 0x42, 0xd4, 0x5f, 0xe0, 0x54, 0x88, 0xa2, 0x09,
	0xf6, 0x33, 0xda, 0x82, 0xb8, 0xd5, 0x36, 0x31, 0x69, 0x1b, 0x1d, 0x25, 0x15, 0xb6, 0x1d, 0xbe,
	0x01, 0x3d, 0x82, 0x68, 0xb7, 0xd7, 0x14, 0x9f, 0xe3, 0xcb, 0x54, 0x64, 0x9b, 0xdb, 0x59, 0x2c,
	0xe6, 0xdf, 0xf4, 0x33, 0xbb, 0xd7, 0x5e, 0xbc, 0x66, 0xa8, 0xba, 0x25, 0x2c, 0x74, 0x7b, 0xcd,
	0x47, 0xf8, 0x12, 0xdd, 0x87, 0x05, 0x62, 0x49, 0x56, 0x8f, 0xa4, 0xe6, 0xb7, 0xb9, 0x9d, 0xe5,
	0x7c, 0x6a, 0x37, 0x90, 0x64, 0x27, 0xd0, 0xba, 0xed, 0x17, 0xd8, 0x38, 0xf4, 0x08, 0x6e, 0x77,
	0x24, 0x0b, 0x13, 0x4b, 0x34, 0x71, 0xb7, 0x23, 0xc9, 0x58, 0xc3, 0xba, 0x25, 0xaa, 0x4a, 0x6a,
	0xc1, 0xce, 0xc7, 0xda, 0xa0, 0x9f, 0xb9, 0x75, 0x68, 0x0f, 0x10, 0x7c, 0x7f, 0xa5, 0x2c, 0xdc,
	0xea, 0x8c, 0x19, 0x15, 0xf4, 0x7d, 0x58, 0x96, 0x4d, 0x2c, 0x59, 0x58, 0x11, 0xdb, 0x58, 0x6d,
	0xb5, 0xad, 0x54, 0xd4, 0xde, 0xee, 0x12, 0xb3, 0x7e, 0x6a, 0x1b, 0xd1, 0x3d, 0x58, 0xd4, 0x0c,
	0xa5, 0xd7, 0xc1, 0xa2, 0x71, 0xae, 0x63, 0x33, 0x15, 0xdb, 0xe6, 0x76, 0xe2, 0x42, 0xc2, 0xb1,
	0x1d, 0x53, 0x53, 0xf6, 0xd7, 0xf3, 0x90, 0x08, 0x60, 0xa3, 0x3b, 0x81, 0x33, 0x5a, 0x70, 0xce,
	0xc8, 0xce, 0x77, 0x13, 0x80, 0xa8, 0x2d, 0x5d, 0xd5, 0x5b, 0x34, 0x66, 0x3b, 0xeb, 0xc5, 0xd2,
	0xa0, 0x9f, 0x89, 0xd7, 0x1d, 0xab, 0x7d, 0x94, 0xf9, 0x6b, 0x67, 0xd3, 0x9b, 0x25, 0xc4, 0x19,
	0x6c, 0x45, 0x41, 0x5d, 0x48, 0xca, 0x3d, 0xd3, 0xa4, 0x79, 0x69, 0xd1, 0x0c, 0xd2, 0x95, 0xec,
	0x63, 0x2c, 0xee, 0x0f, 0xfa, 0x99, 0xe5, 0x92, 0xe3, 0x63, 0x2c, 0x98, 0x8a, 0x39, 0xcb, 0x72,
	0x10, 0x43, 0x41, 0xcf, 0x60, 0xc5, 0x5d, 0x71, 0x76, 0x6e, 0x2c, 0x31, 0xa8, 0x9a, 0x43, 0x11,
	0x05, 0x16, 0x75, 0x7c, 0xee, 0xef, 0x64, 0xde, 0xde, 0x49, 0x71, 0xd0, 0xcf, 0x40, 0x15, 0x9f,
	0xcf, 0xb2, 0x0b, 0xd0, 0xdd, 0xf9, 0x0a, 0x12, 0x20, 0x41, 0x57, 0x71, 0xa3, 0x5f, 0x98, 0x3a,
	0xfa, 0xb8, 0x8e, 0xcf, 0x59, 0xe4, 0x1f, 0x7a, 0xe4, 0x8e, 0xda, 0xe4, 0x4e, 0x0f, 0x91, 0x3b,
	0xc0, 0x96, 0x11, 0x8a, 0x17, 0x20, 0x8e, 0x2f, 0xb0, 0x2c, 0x52, 0xf1, 0xb0, 0xb9, 0x96, 0xc8,
	0x6f, 0xec, 0x3a, 0xca, 0xb2, 0xeb, 0x2a, 0xcb, 0x6e, 0xc3, 0x55, 0x96, 0x62, 0xec, 0x65, 0x3f,
	0x33, 0xf7, 0xd5, 0xab, 0x0c, 0x27, 0xc4, 0xe8, 0x34, 0xea, 0xc8, 0xfe, 0x3b, 0x0c, 0x20, 0x18,
	0x3d, 0x5d, 0xd9, 0xab, 0xe8, 0xa7, 0x06, 0xfa, 0x19, 0xc4, 0x35, 0xac, 0x35, 0xb1, 0x29, 0x7a,
	0xa4, 0x2c, 0x0c, 0xfa, 0x99, 0xd8, 0x91, 0x6d, 0xb4, 0xd3, 0xb7, 0x77, 0xed, 0x7d, 0xba, 0x93,
	0x84, 0x98, 0x83, 0x59, 0x51, 0x90, 0x02, 0xb7, 0x64, 0x03, 0x9f, 0x9e, 0xaa, 0xb2, 0x4a, 0x39,
	0x20, 0x1b, 0x9a, 0xa6, 0x5a, 0x24, 0x15, 0xda, 0x0e, 0xef, 0x2c, 0x16, 0x1f, 0xbc, 0x78, 0x95,
	0xc9, 0xbd, 0x5d, 0x16, 0x89, 0x80, 0x02, 0x78, 0x25, 0x07, 0x0e, 0xfd, 0x04, 0x92, 0x86, 0x8e,
	0xed, 0xb4, 0x78, 0x07, 0x15, 0x9e, 0x9e, 0x66, 0x86, 0x8e, 0x69, 0xae, 0xd8, 0x61, 0x7d, 0x01,
	0x8b, 0xd2, 0x7d, 0x91, 0x5e, 0x22, 0xc9, 0xea, 0x99, 0x98, 0xf1, 0xf7, 0xc3, 0xb7, 0xbe, 0x8d,
	0xf6, 0x6c, 0x21, 0x21, 0xdd, 0xf7, 0x5e, 0x90, 0x02, 0xc8, 0x8b, 0xdb, 0x5f, 0x60, 0x7e, 0xa6,
	0x05, 0x92, 0x2c, 0x7a, 0xcf, 0x92, 0x1d, 0x70, 0xec, 0xc8, 0xf3, 0xff, 0x97, 0x23, 0xb7, 0x60,
	0x0d, 0xeb, 0xb2, 0x79, 0xd9, 0xa5, 0xe2, 0x49, 0xb0, 0x6c, 0x62, 0x4b, 0x24, 0x6d, 0xc9, 0xc4,
	0xee, 0xb1, 0x7f, 0xfc, 0xe2, 0x55, 0xe6, 0x47, 0xd7, 0x5e, 0x81, 0xd7, 0xe5, 0xba, 0x0d, 0x52,
	0xb7, 0x31, 0x84, 0xdb, 0x1e, 0x78, 0xd0, 0x9c, 0xfd, 0x9a, 0x83, 0x50, 0x99, 0x47, 0x07, 0x30,
	0x4f, 0x09, 0xe0, 0x6c, 0x6c, 0xba, 0xe3, 0x8f, 0x74, 0x7b, 0xcd, 0xb2, 0x0b, 0xe4, 0xd4, 0xbf,
	0xe9, 0x81, 0xf8, 0x2c, 0x86, 0x68, 0x99, 0xff, 0xbc, 0x87, 0x7b, 0x18, 0xe5, 0x21, 0x2a, 0x29,
	0x8a, 0x89, 0x09, 0xb1, 0xc3, 0x8b, 0x17, 0x53, 0x7f, 0xff, 0xe6, 0xfd, 0x55, 0x56, 0xcb, 0x0b,
	0x8e, 0xa7, 0x6e, 0x99, 0xaa, 0xde, 0x12, 0xdc, 0x81, 0xb4, 0x0c, 0xb7, 0xb1, 0xa4, 0xb8, 0x65,
	0x98, 0x3e, 0x53, 0x9b, 0x25, 0xa9, 0x1d, 0x56, 0x81, 0xed, 0xe7, 0xec, 0x5f, 0xe6, 0x21, 0xca,
	0x34, 0x1f, 0x1d, 0x06, 0x4a, 0xcc, 0xc7, 0x5e, 0x1b, 0x30, 0x4d, 0xed, 0xa0, 0x85, 0xe9, 0x19,
	0xc4, 0x3c, 0x89, 0x75, 0xca, 0xd2, 0x27, 0x83, 0x7e, 0x26, 0x3a, 0x8b, 0xbe, 0x46, 0x5b, 0x4c,
	0x5c, 0x1f, 0xc3, 0x92, 0x83, 0x3d, 0xfb, 0xad, 0x4d, 0xd8, 0x40, 0xec, 0xce, 0x8a, 0x90, 0x94,
	0x08, 0xbd, 0x51, 0x58, 0x11, 0x1d, 0x62, 0x92, 0x54, 0x64, 0x3b, 0xbc, 0x93, 0xc8, 0x6f, 0x0e,
	0x49, 0x6d, 0x81, 0x0d, 0x72, 0x68, 0x5c, 0x5c, 0xa3, 0x82, 0xf9, 0xe2, 0x55, 0x66, 0x65, 0xd8,
	0x4e, 0x84, 0x15, 0x69, 0xd8, 0x80, 0xaa, 0x10, 0xd5, 0x30, 0x21, 0x52, 0xcb, 0xbd, 0xae, 0x1f,
	0x8c, 0x24, 0x42, 0x36, 0x34, 0x6c, 0x35, 0x4f, 0x2d, 0xff, 0xa1, 0xa3, 0x36, 0x49, 0xae, 0x79,
	0x69, 0x61, 0xb2, 0xfb, 0x29, 0xbe, 0x28, 0xd2, 0x07, 0xc1, 0x05, 0xa1, 0x75, 0xd2, 0x4f, 0x84,
	0x6e, 0xe8, 0x32, 0x9e, 0xa1, 0xd2, 0x2c, 0xb9, 0xa9, 0xa8, 0x52, 0x20, 0xd4, 0x80, 0xb8, 0x2f,
	0x2e, 0xd1, 0x99, 0xc4, 0xc5, 0x07, 0x42, 0x79, 0xaf, 0x86, 0xc5, 0xec, 0x1a, 0xb6, 0x31, 0x94,
	0x58, 0x46, 0xa1, 0x91, 0xfa, 0x35, 0xde, 0x55, 0xc5, 0x27, 0x74, 0x55, 0xd9, 0xaf, 0x23, 0xb0,
	0x3c, 0x7c, 0x02, 0x37, 0x2e, 0x5a, 0x29, 0xff, 0x6a, 0x86, 0xec, 0x1e, 0xce, 0xbb, 0x80, 0x81,
	0xae, 0x36, 0x3c, 0x73, 0x57, 0xeb, 0xc9, 0x53, 0xe4, 0x5d, 0xc9, 0xd3, 0xfc, 0x6c, 0xf2, 0x84,
	0x9e, 0xc1, 0x72, 0x53, 0xd5, 0x15, 0xda, 0x76, 0x9e, 0x4a, 0xb2, 0x65, 0x98, 0x8c, 0x77, 0x0f,
	0xde, 0xf4, 0xdf, 0xa2, 0x36, 0xd7, 0x65, 0xa9, 0x23, 0x99, 0xc2, 0x12, 0x83, 0xda, 0xb7, 0x91,
	0xd0, 0x31, 0xc4, 0x7d, 0x3a, 0x47, 0xa7, 0x0e, 0x34, 0xd6, 0x65, 0x4c, 0xce, 0xe6, 0x61, 0xa5,
	0x86, 0xed, 0x15, 0x18, 0xbf, 0x08, 0xca, 0x40, 0xc2, 0x6f, 0x9b, 0xa9, 0xae, 0x86, 0x77, 0x22,
	0x02, 0x78, 0x2d, 0x2f, 0xc9, 0x7e, 0x17, 0x82, 0x05, 0x46, 0xa2, 0x47, 0x01, 0x5d, 0xfc, 0xc8,
	0xd3, 0xc5, 0x29, 0x78, 0x73, 0xd3, 0xb2, 0x18, 0x60, 0x63, 0xf8, 0x4a, 0x36, 0xce, 0xfe, 0x8d,
	0x75, 0x0f, 0x16, 0x55, 0x22, 0x6a, 0x52, 0x47, 0x95, 0x55, 0x83, 0x7d, 0x69, 0xc5, 0x84, 0x84,
	0x4a, 0x8e, 0x5c, 0x13, 0xda, 0x84, 0xb8, 0x4a, 0x44, 0x49, 0xb6, 0xd4, 0x33, 0x47, 0x91, 0x62,
	0x42, 0x4c, 0x25, 0x05, 0xfb, 0x3d, 0xfb, 0x92, 0x83, 0x68, 0xc9, 0xd0, 0x4f, 0x55, 0x53, 0xbb,
	0xf1, 0x0b, 0xfa, 0x25, 0xac, 0x18, 0xe7, 0xba, 0x5b, 0x27, 0x68, 0xb7, 0xc4, 0x2a, 0xf3, 0xb4,
	0x52, 0xb6, 0x68, 0x9c, 0xeb, 0x4e, 0xb5, 0xa8, 0xab, 0xad, 0xec, 0xbf, 0x42, 0x10, 0x2f, 0x19,
	0x5a, 0xb7, 0x23, 0xa9, 0xba, 0x85, 0x9e, 0x40, 0x42, 0x66, 0x2f, 0x92, 0x6e, 0xb1, 0xed, 0xfc,
	0x70, 0xba, 0x2d, 0x04, 0x91, 0xd0, 0x09, 0x80, 0x89, 0x49, 0xd7, 0xd0, 0x15, 0xac, 0x5b, 0x8c,
	0x36, 0x53, 0xe2, 0x06, 0x80, 0x28, 0x2b, 0xec, 0xa4, 0x5c, 0x6a, 0xb3, 0x68, 0xd4, 0x73, 0x7c,
	0x59, 0xbf, 0xd4, 0xd0, 0x97, 0xc1, 0x72, 0xe1, 0x90, 0xec, 0x93, 0x37, 0xfd, 0xcc, 0x47, 0xd7,
	0x86, 0xf3, 0xf2, 0x38, 0xa9, 0x6e, 0x64, 0x7f, 0xcb, 0xc1, 0x2d, 0x6f, 0xc4, 0x13, 0xd5, 0x6a,
	0x3b, 0x35, 0x02, 0x3d, 0x84, 0xb8, 0x9b, 0x29, 0x27, 0xe3, 0x89, 0xfc, 0x9d, 0xa1, 0x92, 0xe2,
	0x4d, 0x2a, 0x46, 0x68, 0x99, 0x16, 0xfc, 0xe1, 0xe8, 0x00, 0x92, 0xde, 0x8b, 0xc8, 0xaa, 0x52,
	0xc8, 0xae, 0x4a, 0x5b, 0x93, 0x21, 0x58, 0x5d, 0x5a, 0x91, 0x87, 0x0d, 0xd9, 0x7f, 0x70, 0xb0,
	0xea, 0x0d, 0x22, 0x81, 0xe8, 0x6e, 0x9a, 0xde, 0x3f, 0x85, 0x3b, 0x5e, 0x2c, 0x44, 0x3c, 0x57,
	0xad, 0xb6, 0xbf, 0x0f, 0xda, 0xb6, 0x6c, 0x4f, 0xde, 0x87, 0x1f, 0x21, 0x4b, 0xca, 0xaa, 0x3c,
	0x21, 0xfa, 0x6c, 0x0f, 0x56, 0x99, 0x6e, 0xd6, 0x4c, 0x43, 0xc6, 0x84, 0xd8, 0x8a, 0x43, 0xe8,
	0x51, 0xbb, 0x1a, 0xc6, 0xa4, 0xb3, 0xf8, 0x63, 0xba, 0x2b, 0x26, 0x48, 0x64, 0x2a, 0x15, 0x8b,
	0x31, 0x15, 0x23, 0xd9, 0x5f, 0xc2, 0x9d, 0xe1, 0x65, 0x3d, 0xd5, 0xc6, 0x13, 0x54, 0xbb, 0x58,
	0xa6, 0x5f, 0xee, 0x5e, 0xef, 0x49, 0xa6, 0x6c, 0x59, 0x83, 0xda, 0xff, 0x92, 0x83, 0x64, 0x4d,
	0x32, 0x2d, 0x55, 0xea, 0xf8, 0x1f, 0x5d, 0x37, 0x7d, 0x94, 0x43, 0xed, 0x56, 0xe8, 0x1d, 0xb5,
	0x5b, 0xd9, 0x9f, 0x03, 0x6a, 0xe0, 0x0b, 0xff, 0x4a, 0x1d, 0x9b, 0x0a, 0x36, 0x83, 0x6d, 0x28,
	0xf7, 0x0e, 0xda, 0xd0, 0x87, 0x89, 0xbf, 0x7e, 0xf3, 0x3e, 0x95, 0x74, 0x0b, 0xeb, 0x56, 0xf6,
	0xcf, 0x1c, 0x2c, 0xf2, 0x8f, 0x8f, 0xfc, 0xcc, 0x7d, 0x0e, 0x71, 0x53, 0x0c, 0x7e, 0xc1, 0x4c,
	0xbb, 0x5e, 0xcc, 0x64, 0x5f, 0x3b, 0x48, 0x18, 0x4f, 0xd6, 0x74, 0x90, 0x81, 0x54, 0xfd, 0x87,
	0x83, 0x25, 0xc6, 0x07, 0x01, 0x93, 0x5e, 0xc7, 0x42, 0x1f, 0x40, 0x94, 0xb1, 0x82, 0x29, 0xcb,
	0xea, 0xa4, 0x66, 0x95, 0x5d, 0x21, 0x77, 0x28, 0xaa, 0xc1, 0x12, 0x3e, 0xd3, 0xc4, 0xe1, 0xf8,
	0x12, 0xf9, 0xf5, 0xa1, 0xb9, 0xc1, 0x04, 0x15, 0x93, 0x83, 0x7e, 0x66, 0x28, 0x65, 0xc2, 0x22,
	0x3e, 0xd3, 0xfc, 0x04, 0xca, 0xb0, 0x69, 0x62, 0x19, 0xab, 0x67, 0x58, 0x11, 0xbb, 0x0e, 0x2f,
	0x7d, 0x78, 0x5a, 0xeb, 0xe9, 0x55, 0xbf, 0x3b, 0x84, 0x3f, 0x4a, 0x5f, 0x16, 0xe4, 0xba, 0x8b,
	0x33, 0xea, 0x27, 0xef, 0xfd, 0x9e, 0x83, 0xef, 0x8d, 0xfd, 0x42, 0x42, 0x59, 0x48, 0x0b, 0x7c,
	0xed, 0xb0, 0x50, 0xe2, 0x8f, 0xf8, 0x6a, 0x43, 0xac, 0x37, 0x0a, 0x8d, 0x93, 0xba, 0x78, 0x52,
	0xad, 0xd7, 0xf8, 0x52, 0x65, 0xbf, 0xc2, 0x97, 0x93, 0x73, 0x28, 0x0d, 0x1b, 0x13, 0xc6, 0x3c,
	0x29, 0x54, 0x1a, 0x95, 0xea, 0x41, 0x92, 0xbb, 0xc2, 0x5f, 0x3f, 0x29, 0x95, 0xf8, 0x7a, 0x3d,
	0x19, 0x42, 0x77, 0x61, 0x7d, 0x82, 0x7f, 0xbf, 0x70, 0x78, 0xc8, 0x57, 0x93, 0xe1, 0x8d, 0xc8,
	0xaf, 0xfe, 0x90, 0x9e, 0x7b, 0xef, 0x8f, 0xfe, 0xe9, 0xb0, 0xd0, 0xd2, 0xb0, 0x51, 0xaf, 0x1c,
	0x54, 0x2b, 0xd5, 0x83, 0xc9, 0x61, 0x6d, 0xc0, 0x9d, 0x11, 0xbf, 0x1f, 0xd2, 0xb8, 0xcf, 0x0f,
	0x67, 0xdc, 0xc7, 0x3f, 0xad, 0x55, 0x04, 0xbe, 0x9c, 0x0c, 0xa3, 0x75, 0xb8, 0x3d, 0xe2, 0x63,
	0x61, 0x46, 0x58, 0x98, 0x7f, 0xe3, 0x20, 0x11, 0xf8, 0xcb, 0x8c, 0xb6, 0x20, 0x75, 0x20, 0x1c,
	0x9f, 0xd4, 0x26, 0x87, 0x98, 0x82, 0xd5, 0x21, 0xaf, 0x70, 0x7c, 0x52, 0x2d, 0x8b, 0x7b, 0x49,
	0xee, 0x0a, 0x4f, 0x3e, 0x19, 0xba, 0xc2, 0xf3, 0x20, 0x19, 0x46, 0x6b, 0x70, 0x6b, 0xc8, 0x53,
	0x28, 0x35, 0x2a, 0x8f, 0xf9, 0x64, 0x64, 0x6c, 0x8a, 0xbb, 0x9f, 0xf9, 0xb1, 0x29, 0x6c, 0x37,
	0x0b, 0x6c, 0x37, 0x16, 0xac, 0x8c, 0xd4, 0x3e, 0xb4, 0x0d, 0x5b, 0xa5, 0xe3, 0xa3, 0xda, 0x61,
	0xa1, 0x72, 0x15, 0x1d, 0xb6, 0x20, 0x35, 0x36, 0xc2, 0xcd, 0x2e, 0x87, 0x36, 0x61, 0x6d, 0xcc,
	0xbb, 0x5f, 0xa8, 0x1c, 0xf2, 0xe5, 0x64, 0x88, 0xad, 0xfa, 0x1b, 0x0e, 0x96, 0x6a, 0x26, 0x3e,
	0x55, 0x2f, 0x8e, 0x48, 0xab, 0x71, 0xd9, 0xc5, 0x28, 0x03, 0x9b, 0x35, 0x81, 0xdf, 0xaf, 0x3c,
	0x15, 0x8f, 0xea, 0x07, 0x62, 0xe3, 0x8b, 0x1a, 0x3f, 0x9e, 0xc8, 0xd1, 0x01, 0x0d, 0xfe, 0x69,
	0x23, 0xc9, 0xa1, 0x7b, 0x70, 0x77, 0xd4, 0xc3, 0xc8, 0x26, 0xda, 0x3b, 0x77, 0x0e, 0x7c, 0x74,
	0xc8, 0xb1, 0x50, 0x28, 0x1d, 0xf2, 0x2e, 0xf9, 0x8a, 0x9f, 0xfd, 0x69, 0x90, 0xe6, 0x5e, 0x0e,
	0xd2, 0xdc, 0xb7, 0x83, 0x34, 0xf7, 0xcf, 0x41, 0x9a, 0xfb, 0xea, 0x75, 0x7a, 0xee, 0xdb, 0xd7,
	0xe9, 0xb9, 0xef, 0x5e, 0xa7, 0xe7, 0x9e, 0xfd, 0xe0, 0x7f, 0x4a, 0xf4, 0x05, 0x15, 0xe8, 0x9c,
	0x75, 0xd9, 0xc5, 0xa4, 0xb9, 0x60, 0xbb, 0x1f, 0xfc, 0x37, 0x00, 0x00, 0xff, 0xff, 0x08, 0x40,
	0x77, 0x57, 0x15, 0x1a, 0x00, 0x00,
}

func (this *Group) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Group)
	if !ok {
		that2, ok := that.(Group)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if this.Size_ != that1.Size_ {
		return false
	}
	if this.Threshold != that1.Threshold {
		return false
	}
	if !bytes.Equal(this.PubKey, that1.PubKey) {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.LatestReplacementID != that1.LatestReplacementID {
		return false
	}
	if this.CreatedHeight != that1.CreatedHeight {
		return false
	}
	if this.ModuleOwner != that1.ModuleOwner {
		return false
	}
	return true
}
func (this *Replacement) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Replacement)
	if !ok {
		that2, ok := that.(Replacement)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if this.SigningID != that1.SigningID {
		return false
	}
	if this.CurrentGroupID != that1.CurrentGroupID {
		return false
	}
	if !bytes.Equal(this.CurrentPubKey, that1.CurrentPubKey) {
		return false
	}
	if this.NewGroupID != that1.NewGroupID {
		return false
	}
	if !bytes.Equal(this.NewPubKey, that1.NewPubKey) {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if !this.ExecTime.Equal(that1.ExecTime) {
		return false
	}
	return true
}
func (this *Round1Info) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Round1Info)
	if !ok {
		that2, ok := that.(Round1Info)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MemberID != that1.MemberID {
		return false
	}
	if len(this.CoefficientCommits) != len(that1.CoefficientCommits) {
		return false
	}
	for i := range this.CoefficientCommits {
		if !bytes.Equal(this.CoefficientCommits[i], that1.CoefficientCommits[i]) {
			return false
		}
	}
	if !bytes.Equal(this.OneTimePubKey, that1.OneTimePubKey) {
		return false
	}
	if !bytes.Equal(this.A0Signature, that1.A0Signature) {
		return false
	}
	if !bytes.Equal(this.OneTimeSignature, that1.OneTimeSignature) {
		return false
	}
	return true
}
func (this *Round2Info) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Round2Info)
	if !ok {
		that2, ok := that.(Round2Info)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MemberID != that1.MemberID {
		return false
	}
	if len(this.EncryptedSecretShares) != len(that1.EncryptedSecretShares) {
		return false
	}
	for i := range this.EncryptedSecretShares {
		if !bytes.Equal(this.EncryptedSecretShares[i], that1.EncryptedSecretShares[i]) {
			return false
		}
	}
	return true
}
func (this *DE) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DE)
	if !ok {
		that2, ok := that.(DE)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.PubD, that1.PubD) {
		return false
	}
	if !bytes.Equal(this.PubE, that1.PubE) {
		return false
	}
	return true
}
func (this *DEQueue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DEQueue)
	if !ok {
		that2, ok := that.(DEQueue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.Head != that1.Head {
		return false
	}
	if this.Tail != that1.Tail {
		return false
	}
	return true
}
func (this *Signing) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Signing)
	if !ok {
		that2, ok := that.(Signing)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if this.GroupID != that1.GroupID {
		return false
	}
	if !bytes.Equal(this.GroupPubKey, that1.GroupPubKey) {
		return false
	}
	if len(this.AssignedMembers) != len(that1.AssignedMembers) {
		return false
	}
	for i := range this.AssignedMembers {
		if !this.AssignedMembers[i].Equal(&that1.AssignedMembers[i]) {
			return false
		}
	}
	if !bytes.Equal(this.Message, that1.Message) {
		return false
	}
	if !bytes.Equal(this.GroupPubNonce, that1.GroupPubNonce) {
		return false
	}
	if !bytes.Equal(this.Signature, that1.Signature) {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.CreatedHeight != that1.CreatedHeight {
		return false
	}
	return true
}
func (this *AssignedMember) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AssignedMember)
	if !ok {
		that2, ok := that.(AssignedMember)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MemberID != that1.MemberID {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if !bytes.Equal(this.PubKey, that1.PubKey) {
		return false
	}
	if !bytes.Equal(this.PubD, that1.PubD) {
		return false
	}
	if !bytes.Equal(this.PubE, that1.PubE) {
		return false
	}
	if !bytes.Equal(this.BindingFactor, that1.BindingFactor) {
		return false
	}
	if !bytes.Equal(this.PubNonce, that1.PubNonce) {
		return false
	}
	return true
}
func (this *PendingSignings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PendingSignings)
	if !ok {
		that2, ok := that.(PendingSignings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.SigningIds) != len(that1.SigningIds) {
		return false
	}
	for i := range this.SigningIds {
		if this.SigningIds[i] != that1.SigningIds[i] {
			return false
		}
	}
	return true
}
func (this *Member) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Member)
	if !ok {
		that2, ok := that.(Member)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if this.GroupID != that1.GroupID {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if !bytes.Equal(this.PubKey, that1.PubKey) {
		return false
	}
	if this.IsMalicious != that1.IsMalicious {
		return false
	}
	if this.IsActive != that1.IsActive {
		return false
	}
	return true
}
func (this *Confirm) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Confirm)
	if !ok {
		that2, ok := that.(Confirm)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MemberID != that1.MemberID {
		return false
	}
	if !bytes.Equal(this.OwnPubKeySig, that1.OwnPubKeySig) {
		return false
	}
	return true
}
func (this *Complaint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Complaint)
	if !ok {
		that2, ok := that.(Complaint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Complainant != that1.Complainant {
		return false
	}
	if this.Respondent != that1.Respondent {
		return false
	}
	if !bytes.Equal(this.KeySym, that1.KeySym) {
		return false
	}
	if !bytes.Equal(this.Signature, that1.Signature) {
		return false
	}
	return true
}
func (this *ComplaintWithStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ComplaintWithStatus)
	if !ok {
		that2, ok := that.(ComplaintWithStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Complaint.Equal(&that1.Complaint) {
		return false
	}
	if this.ComplaintStatus != that1.ComplaintStatus {
		return false
	}
	return true
}
func (this *ComplaintsWithStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ComplaintsWithStatus)
	if !ok {
		that2, ok := that.(ComplaintsWithStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MemberID != that1.MemberID {
		return false
	}
	if len(this.ComplaintsWithStatus) != len(that1.ComplaintsWithStatus) {
		return false
	}
	for i := range this.ComplaintsWithStatus {
		if !this.ComplaintsWithStatus[i].Equal(&that1.ComplaintsWithStatus[i]) {
			return false
		}
	}
	return true
}
func (this *PendingProcessGroups) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PendingProcessGroups)
	if !ok {
		that2, ok := that.(PendingProcessGroups)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.GroupIDs) != len(that1.GroupIDs) {
		return false
	}
	for i := range this.GroupIDs {
		if this.GroupIDs[i] != that1.GroupIDs[i] {
			return false
		}
	}
	return true
}
func (this *PendingProcessSignings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PendingProcessSignings)
	if !ok {
		that2, ok := that.(PendingProcessSignings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.SigningIDs) != len(that1.SigningIDs) {
		return false
	}
	for i := range this.SigningIDs {
		if this.SigningIDs[i] != that1.SigningIDs[i] {
			return false
		}
	}
	return true
}
func (this *PartialSignature) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PartialSignature)
	if !ok {
		that2, ok := that.(PartialSignature)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MemberID != that1.MemberID {
		return false
	}
	if !bytes.Equal(this.Signature, that1.Signature) {
		return false
	}
	return true
}
func (this *TextSignatureOrder) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TextSignatureOrder)
	if !ok {
		that2, ok := that.(TextSignatureOrder)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Message, that1.Message) {
		return false
	}
	return true
}
func (this *EVMSignature) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EVMSignature)
	if !ok {
		that2, ok := that.(EVMSignature)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.RAddress, that1.RAddress) {
		return false
	}
	if !bytes.Equal(this.Signature, that1.Signature) {
		return false
	}
	return true
}
func (this *SigningResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SigningResult)
	if !ok {
		that2, ok := that.(SigningResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Signing.Equal(&that1.Signing) {
		return false
	}
	if !this.EVMSignature.Equal(that1.EVMSignature) {
		return false
	}
	if len(this.ReceivedPartialSignatures) != len(that1.ReceivedPartialSignatures) {
		return false
	}
	for i := range this.ReceivedPartialSignatures {
		if !this.ReceivedPartialSignatures[i].Equal(&that1.ReceivedPartialSignatures[i]) {
			return false
		}
	}
	return true
}
func (m *Group) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Group) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Group) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ModuleOwner) > 0 {
		i -= len(m.ModuleOwner)
		copy(dAtA[i:], m.ModuleOwner)
		i = encodeVarintTss(dAtA, i, uint64(len(m.ModuleOwner)))
		i--
		dAtA[i] = 0x42
	}
	if m.CreatedHeight != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.CreatedHeight))
		i--
		dAtA[i] = 0x38
	}
	if m.LatestReplacementID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.LatestReplacementID))
		i--
		dAtA[i] = 0x30
	}
	if m.Status != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintTss(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0x22
	}
	if m.Threshold != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Threshold))
		i--
		dAtA[i] = 0x18
	}
	if m.Size_ != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Replacement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Replacement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Replacement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ExecTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExecTime):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintTss(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x42
	if m.Status != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if len(m.NewPubKey) > 0 {
		i -= len(m.NewPubKey)
		copy(dAtA[i:], m.NewPubKey)
		i = encodeVarintTss(dAtA, i, uint64(len(m.NewPubKey)))
		i--
		dAtA[i] = 0x32
	}
	if m.NewGroupID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.NewGroupID))
		i--
		dAtA[i] = 0x28
	}
	if len(m.CurrentPubKey) > 0 {
		i -= len(m.CurrentPubKey)
		copy(dAtA[i:], m.CurrentPubKey)
		i = encodeVarintTss(dAtA, i, uint64(len(m.CurrentPubKey)))
		i--
		dAtA[i] = 0x22
	}
	if m.CurrentGroupID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.CurrentGroupID))
		i--
		dAtA[i] = 0x18
	}
	if m.SigningID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.SigningID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Round1Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Round1Info) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Round1Info) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OneTimeSignature) > 0 {
		i -= len(m.OneTimeSignature)
		copy(dAtA[i:], m.OneTimeSignature)
		i = encodeVarintTss(dAtA, i, uint64(len(m.OneTimeSignature)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.A0Signature) > 0 {
		i -= len(m.A0Signature)
		copy(dAtA[i:], m.A0Signature)
		i = encodeVarintTss(dAtA, i, uint64(len(m.A0Signature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OneTimePubKey) > 0 {
		i -= len(m.OneTimePubKey)
		copy(dAtA[i:], m.OneTimePubKey)
		i = encodeVarintTss(dAtA, i, uint64(len(m.OneTimePubKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CoefficientCommits) > 0 {
		for iNdEx := len(m.CoefficientCommits) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CoefficientCommits[iNdEx])
			copy(dAtA[i:], m.CoefficientCommits[iNdEx])
			i = encodeVarintTss(dAtA, i, uint64(len(m.CoefficientCommits[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.MemberID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.MemberID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Round2Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Round2Info) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Round2Info) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EncryptedSecretShares) > 0 {
		for iNdEx := len(m.EncryptedSecretShares) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EncryptedSecretShares[iNdEx])
			copy(dAtA[i:], m.EncryptedSecretShares[iNdEx])
			i = encodeVarintTss(dAtA, i, uint64(len(m.EncryptedSecretShares[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.MemberID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.MemberID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DE) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DE) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DE) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PubE) > 0 {
		i -= len(m.PubE)
		copy(dAtA[i:], m.PubE)
		i = encodeVarintTss(dAtA, i, uint64(len(m.PubE)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PubD) > 0 {
		i -= len(m.PubD)
		copy(dAtA[i:], m.PubD)
		i = encodeVarintTss(dAtA, i, uint64(len(m.PubD)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DEQueue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DEQueue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DEQueue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Tail != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Tail))
		i--
		dAtA[i] = 0x18
	}
	if m.Head != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Head))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Signing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Signing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Signing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreatedHeight != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.CreatedHeight))
		i--
		dAtA[i] = 0x48
	}
	if m.Status != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.GroupPubNonce) > 0 {
		i -= len(m.GroupPubNonce)
		copy(dAtA[i:], m.GroupPubNonce)
		i = encodeVarintTss(dAtA, i, uint64(len(m.GroupPubNonce)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AssignedMembers) > 0 {
		for iNdEx := len(m.AssignedMembers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AssignedMembers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTss(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.GroupPubKey) > 0 {
		i -= len(m.GroupPubKey)
		copy(dAtA[i:], m.GroupPubKey)
		i = encodeVarintTss(dAtA, i, uint64(len(m.GroupPubKey)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AssignedMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssignedMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssignedMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PubNonce) > 0 {
		i -= len(m.PubNonce)
		copy(dAtA[i:], m.PubNonce)
		i = encodeVarintTss(dAtA, i, uint64(len(m.PubNonce)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.BindingFactor) > 0 {
		i -= len(m.BindingFactor)
		copy(dAtA[i:], m.BindingFactor)
		i = encodeVarintTss(dAtA, i, uint64(len(m.BindingFactor)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.PubE) > 0 {
		i -= len(m.PubE)
		copy(dAtA[i:], m.PubE)
		i = encodeVarintTss(dAtA, i, uint64(len(m.PubE)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PubD) > 0 {
		i -= len(m.PubD)
		copy(dAtA[i:], m.PubD)
		i = encodeVarintTss(dAtA, i, uint64(len(m.PubD)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintTss(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if m.MemberID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.MemberID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PendingSignings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PendingSignings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PendingSignings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SigningIds) > 0 {
		dAtA3 := make([]byte, len(m.SigningIds)*10)
		var j2 int
		for _, num := range m.SigningIds {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintTss(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Member) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Member) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Member) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsActive {
		i--
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.IsMalicious {
		i--
		if m.IsMalicious {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintTss(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Confirm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Confirm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Confirm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OwnPubKeySig) > 0 {
		i -= len(m.OwnPubKeySig)
		copy(dAtA[i:], m.OwnPubKeySig)
		i = encodeVarintTss(dAtA, i, uint64(len(m.OwnPubKeySig)))
		i--
		dAtA[i] = 0x12
	}
	if m.MemberID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.MemberID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Complaint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Complaint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Complaint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.KeySym) > 0 {
		i -= len(m.KeySym)
		copy(dAtA[i:], m.KeySym)
		i = encodeVarintTss(dAtA, i, uint64(len(m.KeySym)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Respondent != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Respondent))
		i--
		dAtA[i] = 0x10
	}
	if m.Complainant != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Complainant))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ComplaintWithStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplaintWithStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplaintWithStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ComplaintStatus != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.ComplaintStatus))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Complaint.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTss(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ComplaintsWithStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplaintsWithStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplaintsWithStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ComplaintsWithStatus) > 0 {
		for iNdEx := len(m.ComplaintsWithStatus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ComplaintsWithStatus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTss(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.MemberID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.MemberID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PendingProcessGroups) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PendingProcessGroups) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PendingProcessGroups) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GroupIDs) > 0 {
		dAtA6 := make([]byte, len(m.GroupIDs)*10)
		var j5 int
		for _, num := range m.GroupIDs {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintTss(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PendingProcessSignings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PendingProcessSignings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PendingProcessSignings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SigningIDs) > 0 {
		dAtA8 := make([]byte, len(m.SigningIDs)*10)
		var j7 int
		for _, num := range m.SigningIDs {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintTss(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PartialSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartialSignature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartialSignature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if m.MemberID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.MemberID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TextSignatureOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TextSignatureOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TextSignatureOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EVMSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EVMSignature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EVMSignature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RAddress) > 0 {
		i -= len(m.RAddress)
		copy(dAtA[i:], m.RAddress)
		i = encodeVarintTss(dAtA, i, uint64(len(m.RAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SigningResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SigningResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SigningResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ReceivedPartialSignatures) > 0 {
		for iNdEx := len(m.ReceivedPartialSignatures) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ReceivedPartialSignatures[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTss(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.EVMSignature != nil {
		{
			size, err := m.EVMSignature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTss(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Signing.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTss(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintTss(dAtA []byte, offset int, v uint64) int {
	offset -= sovTss(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Group) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovTss(uint64(m.ID))
	}
	if m.Size_ != 0 {
		n += 1 + sovTss(uint64(m.Size_))
	}
	if m.Threshold != 0 {
		n += 1 + sovTss(uint64(m.Threshold))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTss(uint64(m.Status))
	}
	if m.LatestReplacementID != 0 {
		n += 1 + sovTss(uint64(m.LatestReplacementID))
	}
	if m.CreatedHeight != 0 {
		n += 1 + sovTss(uint64(m.CreatedHeight))
	}
	l = len(m.ModuleOwner)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func (m *Replacement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovTss(uint64(m.ID))
	}
	if m.SigningID != 0 {
		n += 1 + sovTss(uint64(m.SigningID))
	}
	if m.CurrentGroupID != 0 {
		n += 1 + sovTss(uint64(m.CurrentGroupID))
	}
	l = len(m.CurrentPubKey)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	if m.NewGroupID != 0 {
		n += 1 + sovTss(uint64(m.NewGroupID))
	}
	l = len(m.NewPubKey)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTss(uint64(m.Status))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExecTime)
	n += 1 + l + sovTss(uint64(l))
	return n
}

func (m *Round1Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemberID != 0 {
		n += 1 + sovTss(uint64(m.MemberID))
	}
	if len(m.CoefficientCommits) > 0 {
		for _, b := range m.CoefficientCommits {
			l = len(b)
			n += 1 + l + sovTss(uint64(l))
		}
	}
	l = len(m.OneTimePubKey)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.A0Signature)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.OneTimeSignature)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func (m *Round2Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemberID != 0 {
		n += 1 + sovTss(uint64(m.MemberID))
	}
	if len(m.EncryptedSecretShares) > 0 {
		for _, b := range m.EncryptedSecretShares {
			l = len(b)
			n += 1 + l + sovTss(uint64(l))
		}
	}
	return n
}

func (m *DE) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PubD)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.PubE)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func (m *DEQueue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	if m.Head != 0 {
		n += 1 + sovTss(uint64(m.Head))
	}
	if m.Tail != 0 {
		n += 1 + sovTss(uint64(m.Tail))
	}
	return n
}

func (m *Signing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovTss(uint64(m.ID))
	}
	if m.GroupID != 0 {
		n += 1 + sovTss(uint64(m.GroupID))
	}
	l = len(m.GroupPubKey)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	if len(m.AssignedMembers) > 0 {
		for _, e := range m.AssignedMembers {
			l = e.Size()
			n += 1 + l + sovTss(uint64(l))
		}
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.GroupPubNonce)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTss(uint64(m.Status))
	}
	if m.CreatedHeight != 0 {
		n += 1 + sovTss(uint64(m.CreatedHeight))
	}
	return n
}

func (m *AssignedMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemberID != 0 {
		n += 1 + sovTss(uint64(m.MemberID))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.PubD)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.PubE)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.BindingFactor)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.PubNonce)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func (m *PendingSignings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SigningIds) > 0 {
		l = 0
		for _, e := range m.SigningIds {
			l += sovTss(uint64(e))
		}
		n += 1 + sovTss(uint64(l)) + l
	}
	return n
}

func (m *Member) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovTss(uint64(m.ID))
	}
	if m.GroupID != 0 {
		n += 1 + sovTss(uint64(m.GroupID))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	if m.IsMalicious {
		n += 2
	}
	if m.IsActive {
		n += 2
	}
	return n
}

func (m *Confirm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemberID != 0 {
		n += 1 + sovTss(uint64(m.MemberID))
	}
	l = len(m.OwnPubKeySig)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func (m *Complaint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Complainant != 0 {
		n += 1 + sovTss(uint64(m.Complainant))
	}
	if m.Respondent != 0 {
		n += 1 + sovTss(uint64(m.Respondent))
	}
	l = len(m.KeySym)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func (m *ComplaintWithStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Complaint.Size()
	n += 1 + l + sovTss(uint64(l))
	if m.ComplaintStatus != 0 {
		n += 1 + sovTss(uint64(m.ComplaintStatus))
	}
	return n
}

func (m *ComplaintsWithStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemberID != 0 {
		n += 1 + sovTss(uint64(m.MemberID))
	}
	if len(m.ComplaintsWithStatus) > 0 {
		for _, e := range m.ComplaintsWithStatus {
			l = e.Size()
			n += 1 + l + sovTss(uint64(l))
		}
	}
	return n
}

func (m *PendingProcessGroups) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GroupIDs) > 0 {
		l = 0
		for _, e := range m.GroupIDs {
			l += sovTss(uint64(e))
		}
		n += 1 + sovTss(uint64(l)) + l
	}
	return n
}

func (m *PendingProcessSignings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SigningIDs) > 0 {
		l = 0
		for _, e := range m.SigningIDs {
			l += sovTss(uint64(e))
		}
		n += 1 + sovTss(uint64(l)) + l
	}
	return n
}

func (m *PartialSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemberID != 0 {
		n += 1 + sovTss(uint64(m.MemberID))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func (m *TextSignatureOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func (m *EVMSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RAddress)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func (m *SigningResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Signing.Size()
	n += 1 + l + sovTss(uint64(l))
	if m.EVMSignature != nil {
		l = m.EVMSignature.Size()
		n += 1 + l + sovTss(uint64(l))
	}
	if len(m.ReceivedPartialSignatures) > 0 {
		for _, e := range m.ReceivedPartialSignatures {
			l = e.Size()
			n += 1 + l + sovTss(uint64(l))
		}
	}
	return n
}

func sovTss(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTss(x uint64) (n int) {
	return sovTss(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Group) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= github_com_bandprotocol_chain_v2_pkg_tss.GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			m.Threshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Threshold |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= GroupStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestReplacementID", wireType)
			}
			m.LatestReplacementID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestReplacementID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedHeight", wireType)
			}
			m.CreatedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleOwner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleOwner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Replacement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Replacement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Replacement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningID", wireType)
			}
			m.SigningID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SigningID |= github_com_bandprotocol_chain_v2_pkg_tss.SigningID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentGroupID", wireType)
			}
			m.CurrentGroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentGroupID |= github_com_bandprotocol_chain_v2_pkg_tss.GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentPubKey = append(m.CurrentPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.CurrentPubKey == nil {
				m.CurrentPubKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewGroupID", wireType)
			}
			m.NewGroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewGroupID |= github_com_bandprotocol_chain_v2_pkg_tss.GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewPubKey = append(m.NewPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.NewPubKey == nil {
				m.NewPubKey = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ReplacementStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ExecTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Round1Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Round1Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Round1Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			m.MemberID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberID |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoefficientCommits", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoefficientCommits = append(m.CoefficientCommits, make([]byte, postIndex-iNdEx))
			copy(m.CoefficientCommits[len(m.CoefficientCommits)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneTimePubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OneTimePubKey = append(m.OneTimePubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.OneTimePubKey == nil {
				m.OneTimePubKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A0Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.A0Signature = append(m.A0Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.A0Signature == nil {
				m.A0Signature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneTimeSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OneTimeSignature = append(m.OneTimeSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.OneTimeSignature == nil {
				m.OneTimeSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Round2Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Round2Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Round2Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			m.MemberID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberID |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedSecretShares", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedSecretShares = append(m.EncryptedSecretShares, make([]byte, postIndex-iNdEx))
			copy(m.EncryptedSecretShares[len(m.EncryptedSecretShares)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DE) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DE: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DE: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubD", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubD = append(m.PubD[:0], dAtA[iNdEx:postIndex]...)
			if m.PubD == nil {
				m.PubD = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubE", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubE = append(m.PubE[:0], dAtA[iNdEx:postIndex]...)
			if m.PubE == nil {
				m.PubE = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DEQueue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DEQueue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DEQueue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			m.Head = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Head |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tail", wireType)
			}
			m.Tail = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tail |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Signing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Signing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Signing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= github_com_bandprotocol_chain_v2_pkg_tss.SigningID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= github_com_bandprotocol_chain_v2_pkg_tss.GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupPubKey = append(m.GroupPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupPubKey == nil {
				m.GroupPubKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignedMembers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssignedMembers = append(m.AssignedMembers, AssignedMember{})
			if err := m.AssignedMembers[len(m.AssignedMembers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = append(m.Message[:0], dAtA[iNdEx:postIndex]...)
			if m.Message == nil {
				m.Message = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupPubNonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupPubNonce = append(m.GroupPubNonce[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupPubNonce == nil {
				m.GroupPubNonce = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= SigningStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedHeight", wireType)
			}
			m.CreatedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssignedMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssignedMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssignedMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			m.MemberID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberID |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubD", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubD = append(m.PubD[:0], dAtA[iNdEx:postIndex]...)
			if m.PubD == nil {
				m.PubD = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubE", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubE = append(m.PubE[:0], dAtA[iNdEx:postIndex]...)
			if m.PubE == nil {
				m.PubE = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindingFactor", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BindingFactor = append(m.BindingFactor[:0], dAtA[iNdEx:postIndex]...)
			if m.BindingFactor == nil {
				m.BindingFactor = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubNonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubNonce = append(m.PubNonce[:0], dAtA[iNdEx:postIndex]...)
			if m.PubNonce == nil {
				m.PubNonce = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendingSignings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendingSignings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendingSignings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTss
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SigningIds = append(m.SigningIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTss
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTss
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTss
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SigningIds) == 0 {
					m.SigningIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTss
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SigningIds = append(m.SigningIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Member) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Member: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= github_com_bandprotocol_chain_v2_pkg_tss.GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMalicious", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMalicious = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Confirm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Confirm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Confirm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			m.MemberID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberID |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnPubKeySig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnPubKeySig = append(m.OwnPubKeySig[:0], dAtA[iNdEx:postIndex]...)
			if m.OwnPubKeySig == nil {
				m.OwnPubKeySig = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Complaint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Complaint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Complaint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Complainant", wireType)
			}
			m.Complainant = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Complainant |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Respondent", wireType)
			}
			m.Respondent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Respondent |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeySym", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeySym = append(m.KeySym[:0], dAtA[iNdEx:postIndex]...)
			if m.KeySym == nil {
				m.KeySym = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplaintWithStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplaintWithStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplaintWithStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Complaint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Complaint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComplaintStatus", wireType)
			}
			m.ComplaintStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComplaintStatus |= ComplaintStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplaintsWithStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplaintsWithStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplaintsWithStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			m.MemberID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberID |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComplaintsWithStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ComplaintsWithStatus = append(m.ComplaintsWithStatus, ComplaintWithStatus{})
			if err := m.ComplaintsWithStatus[len(m.ComplaintsWithStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendingProcessGroups) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendingProcessGroups: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendingProcessGroups: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v github_com_bandprotocol_chain_v2_pkg_tss.GroupID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTss
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_bandprotocol_chain_v2_pkg_tss.GroupID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GroupIDs = append(m.GroupIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTss
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTss
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTss
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.GroupIDs) == 0 {
					m.GroupIDs = make([]github_com_bandprotocol_chain_v2_pkg_tss.GroupID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_bandprotocol_chain_v2_pkg_tss.GroupID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTss
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_bandprotocol_chain_v2_pkg_tss.GroupID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GroupIDs = append(m.GroupIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendingProcessSignings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendingProcessSignings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendingProcessSignings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v github_com_bandprotocol_chain_v2_pkg_tss.SigningID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTss
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_bandprotocol_chain_v2_pkg_tss.SigningID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SigningIDs = append(m.SigningIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTss
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTss
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTss
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SigningIDs) == 0 {
					m.SigningIDs = make([]github_com_bandprotocol_chain_v2_pkg_tss.SigningID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_bandprotocol_chain_v2_pkg_tss.SigningID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTss
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_bandprotocol_chain_v2_pkg_tss.SigningID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SigningIDs = append(m.SigningIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartialSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartialSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartialSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			m.MemberID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberID |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TextSignatureOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TextSignatureOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TextSignatureOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = append(m.Message[:0], dAtA[iNdEx:postIndex]...)
			if m.Message == nil {
				m.Message = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EVMSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EVMSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EVMSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RAddress = append(m.RAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.RAddress == nil {
				m.RAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SigningResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SigningResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SigningResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Signing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EVMSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EVMSignature == nil {
				m.EVMSignature = &EVMSignature{}
			}
			if err := m.EVMSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceivedPartialSignatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReceivedPartialSignatures = append(m.ReceivedPartialSignatures, PartialSignature{})
			if err := m.ReceivedPartialSignatures[len(m.ReceivedPartialSignatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTss(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTss
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTss
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTss
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTss
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTss
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTss
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTss        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTss          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTss = fmt.Errorf("proto: unexpected end of group")
)
