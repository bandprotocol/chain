// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: oracle/v1/oracle.proto

package types

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/codec/types"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ResolveStatus encodes the status of an oracle request.
type ResolveStatus int32

const (
	// Open - the request is not yet resolved.
	RESOLVE_STATUS_OPEN ResolveStatus = 0
	// Success - the request has been resolved successfully with no errors.
	RESOLVE_STATUS_SUCCESS ResolveStatus = 1
	// Failure - an error occured during the request's resolve call.
	RESOLVE_STATUS_FAILURE ResolveStatus = 2
	// Expired - the request does not get enough reports from validator within the
	// timeframe.
	RESOLVE_STATUS_EXPIRED ResolveStatus = 3
)

var ResolveStatus_name = map[int32]string{
	0: "RESOLVE_STATUS_OPEN_UNSPECIFIED",
	1: "RESOLVE_STATUS_SUCCESS",
	2: "RESOLVE_STATUS_FAILURE",
	3: "RESOLVE_STATUS_EXPIRED",
}

var ResolveStatus_value = map[string]int32{
	"RESOLVE_STATUS_OPEN_UNSPECIFIED": 0,
	"RESOLVE_STATUS_SUCCESS":          1,
	"RESOLVE_STATUS_FAILURE":          2,
	"RESOLVE_STATUS_EXPIRED":          3,
}

func (x ResolveStatus) String() string {
	return proto.EnumName(ResolveStatus_name, int32(x))
}

func (ResolveStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{0}
}

// DataSource is the data structure for storing data sources in the storage.
type DataSource struct {
	Owner       string                                   `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	Name        string                                   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Description string                                   `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Filename    string                                   `protobuf:"bytes,4,opt,name=filename,proto3" json:"filename,omitempty"`
	Fee         github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,5,rep,name=fee,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"fee"`
}

func (m *DataSource) Reset()         { *m = DataSource{} }
func (m *DataSource) String() string { return proto.CompactTextString(m) }
func (*DataSource) ProtoMessage()    {}
func (*DataSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{0}
}
func (m *DataSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataSource.Merge(m, src)
}
func (m *DataSource) XXX_Size() int {
	return m.Size()
}
func (m *DataSource) XXX_DiscardUnknown() {
	xxx_messageInfo_DataSource.DiscardUnknown(m)
}

var xxx_messageInfo_DataSource proto.InternalMessageInfo

func (m *DataSource) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *DataSource) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DataSource) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *DataSource) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *DataSource) GetFee() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Fee
	}
	return nil
}

// OracleScript is the data structure for storing oracle scripts in the storage.
type OracleScript struct {
	Owner         string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	Name          string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Description   string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Filename      string `protobuf:"bytes,4,opt,name=filename,proto3" json:"filename,omitempty"`
	Schema        string `protobuf:"bytes,5,opt,name=schema,proto3" json:"schema,omitempty"`
	SourceCodeURL string `protobuf:"bytes,6,opt,name=source_code_url,json=sourceCodeUrl,proto3" json:"source_code_url,omitempty"`
}

func (m *OracleScript) Reset()         { *m = OracleScript{} }
func (m *OracleScript) String() string { return proto.CompactTextString(m) }
func (*OracleScript) ProtoMessage()    {}
func (*OracleScript) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{1}
}
func (m *OracleScript) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleScript) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleScript.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleScript) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleScript.Merge(m, src)
}
func (m *OracleScript) XXX_Size() int {
	return m.Size()
}
func (m *OracleScript) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleScript.DiscardUnknown(m)
}

var xxx_messageInfo_OracleScript proto.InternalMessageInfo

func (m *OracleScript) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *OracleScript) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OracleScript) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *OracleScript) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *OracleScript) GetSchema() string {
	if m != nil {
		return m.Schema
	}
	return ""
}

func (m *OracleScript) GetSourceCodeURL() string {
	if m != nil {
		return m.SourceCodeURL
	}
	return ""
}

// RawRequest is the data structure for storing raw requests in the storage.
type RawRequest struct {
	ExternalID   ExternalID   `protobuf:"varint,1,opt,name=external_id,json=externalId,proto3,casttype=ExternalID" json:"external_id,omitempty"`
	DataSourceID DataSourceID `protobuf:"varint,2,opt,name=data_source_id,json=dataSourceId,proto3,casttype=DataSourceID" json:"data_source_id,omitempty"`
	Calldata     []byte       `protobuf:"bytes,3,opt,name=calldata,proto3" json:"calldata,omitempty"`
}

func (m *RawRequest) Reset()         { *m = RawRequest{} }
func (m *RawRequest) String() string { return proto.CompactTextString(m) }
func (*RawRequest) ProtoMessage()    {}
func (*RawRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{2}
}
func (m *RawRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawRequest.Merge(m, src)
}
func (m *RawRequest) XXX_Size() int {
	return m.Size()
}
func (m *RawRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RawRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RawRequest proto.InternalMessageInfo

func (m *RawRequest) GetExternalID() ExternalID {
	if m != nil {
		return m.ExternalID
	}
	return 0
}

func (m *RawRequest) GetDataSourceID() DataSourceID {
	if m != nil {
		return m.DataSourceID
	}
	return 0
}

func (m *RawRequest) GetCalldata() []byte {
	if m != nil {
		return m.Calldata
	}
	return nil
}

// RawRequest is the data structure for storing raw reporter in the storage.
type RawReport struct {
	ExternalID ExternalID `protobuf:"varint,1,opt,name=external_id,json=externalId,proto3,casttype=ExternalID" json:"external_id,omitempty"`
	ExitCode   uint32     `protobuf:"varint,2,opt,name=exit_code,json=exitCode,proto3" json:"exit_code,omitempty"`
	Data       []byte     `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *RawReport) Reset()         { *m = RawReport{} }
func (m *RawReport) String() string { return proto.CompactTextString(m) }
func (*RawReport) ProtoMessage()    {}
func (*RawReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{3}
}
func (m *RawReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawReport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawReport.Merge(m, src)
}
func (m *RawReport) XXX_Size() int {
	return m.Size()
}
func (m *RawReport) XXX_DiscardUnknown() {
	xxx_messageInfo_RawReport.DiscardUnknown(m)
}

var xxx_messageInfo_RawReport proto.InternalMessageInfo

func (m *RawReport) GetExternalID() ExternalID {
	if m != nil {
		return m.ExternalID
	}
	return 0
}

func (m *RawReport) GetExitCode() uint32 {
	if m != nil {
		return m.ExitCode
	}
	return 0
}

func (m *RawReport) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// Request is the data structure for storing requests in the storage.
type Request struct {
	OracleScriptID      OracleScriptID `protobuf:"varint,1,opt,name=oracle_script_id,json=oracleScriptId,proto3,casttype=OracleScriptID" json:"oracle_script_id,omitempty"`
	Calldata            []byte         `protobuf:"bytes,2,opt,name=calldata,proto3" json:"calldata,omitempty"`
	RequestedValidators []string       `protobuf:"bytes,3,rep,name=requested_validators,json=requestedValidators,proto3" json:"requested_validators,omitempty"`
	MinCount            uint64         `protobuf:"varint,4,opt,name=min_count,json=minCount,proto3" json:"min_count,omitempty"`
	RequestHeight       int64          `protobuf:"varint,5,opt,name=request_height,json=requestHeight,proto3" json:"request_height,omitempty"`
	RequestTime         uint64         `protobuf:"varint,6,opt,name=request_time,json=requestTime,proto3" json:"request_time,omitempty"`
	ClientID            string         `protobuf:"bytes,7,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	RawRequests         []RawRequest   `protobuf:"bytes,8,rep,name=raw_requests,json=rawRequests,proto3" json:"raw_requests"`
	IBCSource           *IBCSource     `protobuf:"bytes,9,opt,name=ibc_source,json=ibcSource,proto3" json:"ibc_source,omitempty"`
	ExecuteGas          uint64         `protobuf:"varint,10,opt,name=execute_gas,json=executeGas,proto3" json:"execute_gas,omitempty"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{4}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetOracleScriptID() OracleScriptID {
	if m != nil {
		return m.OracleScriptID
	}
	return 0
}

func (m *Request) GetCalldata() []byte {
	if m != nil {
		return m.Calldata
	}
	return nil
}

func (m *Request) GetRequestedValidators() []string {
	if m != nil {
		return m.RequestedValidators
	}
	return nil
}

func (m *Request) GetMinCount() uint64 {
	if m != nil {
		return m.MinCount
	}
	return 0
}

func (m *Request) GetRequestHeight() int64 {
	if m != nil {
		return m.RequestHeight
	}
	return 0
}

func (m *Request) GetRequestTime() uint64 {
	if m != nil {
		return m.RequestTime
	}
	return 0
}

func (m *Request) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Request) GetRawRequests() []RawRequest {
	if m != nil {
		return m.RawRequests
	}
	return nil
}

func (m *Request) GetIBCSource() *IBCSource {
	if m != nil {
		return m.IBCSource
	}
	return nil
}

func (m *Request) GetExecuteGas() uint64 {
	if m != nil {
		return m.ExecuteGas
	}
	return 0
}

// Report is the data structure for storing reports in the storage.
type Report struct {
	Validator       string      `protobuf:"bytes,1,opt,name=validator,proto3" json:"validator,omitempty"`
	InBeforeResolve bool        `protobuf:"varint,2,opt,name=in_before_resolve,json=inBeforeResolve,proto3" json:"in_before_resolve,omitempty"`
	RawReports      []RawReport `protobuf:"bytes,3,rep,name=raw_reports,json=rawReports,proto3" json:"raw_reports"`
}

func (m *Report) Reset()         { *m = Report{} }
func (m *Report) String() string { return proto.CompactTextString(m) }
func (*Report) ProtoMessage()    {}
func (*Report) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{5}
}
func (m *Report) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Report) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Report.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Report) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Report.Merge(m, src)
}
func (m *Report) XXX_Size() int {
	return m.Size()
}
func (m *Report) XXX_DiscardUnknown() {
	xxx_messageInfo_Report.DiscardUnknown(m)
}

var xxx_messageInfo_Report proto.InternalMessageInfo

func (m *Report) GetValidator() string {
	if m != nil {
		return m.Validator
	}
	return ""
}

func (m *Report) GetInBeforeResolve() bool {
	if m != nil {
		return m.InBeforeResolve
	}
	return false
}

func (m *Report) GetRawReports() []RawReport {
	if m != nil {
		return m.RawReports
	}
	return nil
}

// OracleRequestPacketData encodes an oracle request sent from other blockchains
// to BandChain.
type OracleRequestPacketData struct {
	// ClientID is the unique identifier of this oracle request, as specified by
	// the client. This same unique ID will be sent back to the requester with the
	// oracle response.
	ClientID string `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	// OracleScriptID is the unique identifier of the oracle script to be
	// executed.
	OracleScriptID OracleScriptID `protobuf:"varint,2,opt,name=oracle_script_id,json=oracleScriptId,proto3,casttype=OracleScriptID" json:"oracle_script_id,omitempty"`
	// Calldata is the calldata bytes available for oracle executor to read.
	Calldata []byte `protobuf:"bytes,3,opt,name=calldata,proto3" json:"calldata,omitempty"`
	// AskCount is the number of validators that are requested to respond to this
	// oracle request. Higher value means more security, at a higher gas cost.
	AskCount uint64 `protobuf:"varint,4,opt,name=ask_count,json=askCount,proto3" json:"ask_count,omitempty"`
	// MinCount is the minimum number of validators necessary for the request to
	// proceed to the execution phase. Higher value means more security, at the
	// cost of liveness.
	MinCount uint64 `protobuf:"varint,5,opt,name=min_count,json=minCount,proto3" json:"min_count,omitempty"`
	// FeeLimit is the maximum tokens that will be paid to all data source
	// providers.
	FeeLimit github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,6,rep,name=fee_limit,json=feeLimit,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"fee_limit"`
	// RequestKey is the key from request chain to match data source fee payer on
	// Bandchain
	RequestKey string `protobuf:"bytes,7,opt,name=request_key,json=requestKey,proto3" json:"request_key,omitempty"`
	// PrepareGas is amount of gas to pay to prepare raw requests
	PrepareGas uint64 `protobuf:"varint,8,opt,name=prepare_gas,json=prepareGas,proto3" json:"prepare_gas,omitempty"`
	// ExecuteGas is amount of gas to reserve for executing
	ExecuteGas uint64 `protobuf:"varint,9,opt,name=execute_gas,json=executeGas,proto3" json:"execute_gas,omitempty"`
}

func (m *OracleRequestPacketData) Reset()         { *m = OracleRequestPacketData{} }
func (m *OracleRequestPacketData) String() string { return proto.CompactTextString(m) }
func (*OracleRequestPacketData) ProtoMessage()    {}
func (*OracleRequestPacketData) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{6}
}
func (m *OracleRequestPacketData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleRequestPacketData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleRequestPacketData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleRequestPacketData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleRequestPacketData.Merge(m, src)
}
func (m *OracleRequestPacketData) XXX_Size() int {
	return m.Size()
}
func (m *OracleRequestPacketData) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleRequestPacketData.DiscardUnknown(m)
}

var xxx_messageInfo_OracleRequestPacketData proto.InternalMessageInfo

func (m *OracleRequestPacketData) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *OracleRequestPacketData) GetOracleScriptID() OracleScriptID {
	if m != nil {
		return m.OracleScriptID
	}
	return 0
}

func (m *OracleRequestPacketData) GetCalldata() []byte {
	if m != nil {
		return m.Calldata
	}
	return nil
}

func (m *OracleRequestPacketData) GetAskCount() uint64 {
	if m != nil {
		return m.AskCount
	}
	return 0
}

func (m *OracleRequestPacketData) GetMinCount() uint64 {
	if m != nil {
		return m.MinCount
	}
	return 0
}

func (m *OracleRequestPacketData) GetFeeLimit() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.FeeLimit
	}
	return nil
}

func (m *OracleRequestPacketData) GetRequestKey() string {
	if m != nil {
		return m.RequestKey
	}
	return ""
}

func (m *OracleRequestPacketData) GetPrepareGas() uint64 {
	if m != nil {
		return m.PrepareGas
	}
	return 0
}

func (m *OracleRequestPacketData) GetExecuteGas() uint64 {
	if m != nil {
		return m.ExecuteGas
	}
	return 0
}

// OracleRequestPacketAcknowledgement encodes an oracle request acknowledgement
// send back to requester chain.
type OracleRequestPacketAcknowledgement struct {
	// RequestID is BandChain's unique identifier for this oracle request.
	RequestID RequestID `protobuf:"varint,1,opt,name=request_id,json=requestId,proto3,casttype=RequestID" json:"request_id,omitempty"`
}

func (m *OracleRequestPacketAcknowledgement) Reset()         { *m = OracleRequestPacketAcknowledgement{} }
func (m *OracleRequestPacketAcknowledgement) String() string { return proto.CompactTextString(m) }
func (*OracleRequestPacketAcknowledgement) ProtoMessage()    {}
func (*OracleRequestPacketAcknowledgement) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{7}
}
func (m *OracleRequestPacketAcknowledgement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleRequestPacketAcknowledgement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleRequestPacketAcknowledgement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleRequestPacketAcknowledgement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleRequestPacketAcknowledgement.Merge(m, src)
}
func (m *OracleRequestPacketAcknowledgement) XXX_Size() int {
	return m.Size()
}
func (m *OracleRequestPacketAcknowledgement) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleRequestPacketAcknowledgement.DiscardUnknown(m)
}

var xxx_messageInfo_OracleRequestPacketAcknowledgement proto.InternalMessageInfo

func (m *OracleRequestPacketAcknowledgement) GetRequestID() RequestID {
	if m != nil {
		return m.RequestID
	}
	return 0
}

// OracleResponsePacketData encodes an oracle response from BandChain to the
// requester.
type OracleResponsePacketData struct {
	// ClientID is the unique identifier matched with that of the oracle request
	// packet.
	ClientID string `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	// RequestID is BandChain's unique identifier for this oracle request.
	RequestID RequestID `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3,casttype=RequestID" json:"request_id,omitempty"`
	// AnsCount is the number of validators among to the asked validators that
	// actually responded to this oracle request prior to this oracle request
	// being resolved.
	AnsCount uint64 `protobuf:"varint,3,opt,name=ans_count,json=ansCount,proto3" json:"ans_count,omitempty"`
	// RequestTime is the UNIX epoch time at which the request was sent to
	// BandChain.
	RequestTime int64 `protobuf:"varint,4,opt,name=request_time,json=requestTime,proto3" json:"request_time,omitempty"`
	// ResolveTime is the UNIX epoch time at which the request was resolved to the
	// final result.
	ResolveTime int64 `protobuf:"varint,5,opt,name=resolve_time,json=resolveTime,proto3" json:"resolve_time,omitempty"`
	// ResolveStatus is the status of this oracle request, which can be OK,
	// FAILURE, or EXPIRED.
	ResolveStatus ResolveStatus `protobuf:"varint,6,opt,name=resolve_status,json=resolveStatus,proto3,enum=oracle.v1.ResolveStatus" json:"resolve_status,omitempty"`
	// Result is the final aggregated value only available if status if OK.
	Result []byte `protobuf:"bytes,7,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *OracleResponsePacketData) Reset()         { *m = OracleResponsePacketData{} }
func (m *OracleResponsePacketData) String() string { return proto.CompactTextString(m) }
func (*OracleResponsePacketData) ProtoMessage()    {}
func (*OracleResponsePacketData) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{8}
}
func (m *OracleResponsePacketData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleResponsePacketData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleResponsePacketData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleResponsePacketData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleResponsePacketData.Merge(m, src)
}
func (m *OracleResponsePacketData) XXX_Size() int {
	return m.Size()
}
func (m *OracleResponsePacketData) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleResponsePacketData.DiscardUnknown(m)
}

var xxx_messageInfo_OracleResponsePacketData proto.InternalMessageInfo

func (m *OracleResponsePacketData) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *OracleResponsePacketData) GetRequestID() RequestID {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *OracleResponsePacketData) GetAnsCount() uint64 {
	if m != nil {
		return m.AnsCount
	}
	return 0
}

func (m *OracleResponsePacketData) GetRequestTime() int64 {
	if m != nil {
		return m.RequestTime
	}
	return 0
}

func (m *OracleResponsePacketData) GetResolveTime() int64 {
	if m != nil {
		return m.ResolveTime
	}
	return 0
}

func (m *OracleResponsePacketData) GetResolveStatus() ResolveStatus {
	if m != nil {
		return m.ResolveStatus
	}
	return RESOLVE_STATUS_OPEN
}

func (m *OracleResponsePacketData) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

type RequestResult struct {
	RequestPacketData  *OracleRequestPacketData  `protobuf:"bytes,1,opt,name=request_packet_data,json=requestPacketData,proto3" json:"request_packet_data,omitempty"`
	ResponsePacketData *OracleResponsePacketData `protobuf:"bytes,2,opt,name=response_packet_data,json=responsePacketData,proto3" json:"response_packet_data,omitempty"`
}

func (m *RequestResult) Reset()         { *m = RequestResult{} }
func (m *RequestResult) String() string { return proto.CompactTextString(m) }
func (*RequestResult) ProtoMessage()    {}
func (*RequestResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{9}
}
func (m *RequestResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestResult.Merge(m, src)
}
func (m *RequestResult) XXX_Size() int {
	return m.Size()
}
func (m *RequestResult) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestResult.DiscardUnknown(m)
}

var xxx_messageInfo_RequestResult proto.InternalMessageInfo

func (m *RequestResult) GetRequestPacketData() *OracleRequestPacketData {
	if m != nil {
		return m.RequestPacketData
	}
	return nil
}

func (m *RequestResult) GetResponsePacketData() *OracleResponsePacketData {
	if m != nil {
		return m.ResponsePacketData
	}
	return nil
}

// Result encodes a result of request and store in chain
type Result struct {
	// ClientID is the unique identifier of this oracle request, as specified by
	// the client. This same unique ID will be sent back to the requester with the
	// oracle response.
	ClientID string `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	// OracleScriptID is the unique identifier of the oracle script to be
	// executed.
	OracleScriptID OracleScriptID `protobuf:"varint,2,opt,name=oracle_script_id,json=oracleScriptId,proto3,casttype=OracleScriptID" json:"oracle_script_id,omitempty"`
	// Calldata is the calldata bytes available for oracle executor to read.
	Calldata []byte `protobuf:"bytes,3,opt,name=calldata,proto3" json:"calldata,omitempty"`
	// AskCount is the number of validators that are requested to respond to this
	// oracle request. Higher value means more security, at a higher gas cost.
	AskCount uint64 `protobuf:"varint,4,opt,name=ask_count,json=askCount,proto3" json:"ask_count,omitempty"`
	// MinCount is the minimum number of validators necessary for the request to
	// proceed to the execution phase. Higher value means more security, at the
	// cost of liveness.
	MinCount uint64 `protobuf:"varint,5,opt,name=min_count,json=minCount,proto3" json:"min_count,omitempty"`
	// RequestID is BandChain's unique identifier for this oracle request.
	RequestID RequestID `protobuf:"varint,6,opt,name=request_id,json=requestId,proto3,casttype=RequestID" json:"request_id,omitempty"`
	// AnsCount is the number of validators among to the asked validators that
	// actually responded to this oracle request prior to this oracle request
	// being resolved.
	AnsCount uint64 `protobuf:"varint,7,opt,name=ans_count,json=ansCount,proto3" json:"ans_count,omitempty"`
	// RequestTime is the UNIX epoch time at which the request was sent to
	// BandChain.
	RequestTime int64 `protobuf:"varint,8,opt,name=request_time,json=requestTime,proto3" json:"request_time,omitempty"`
	// ResolveTime is the UNIX epoch time at which the request was resolved to the
	// final result.
	ResolveTime int64 `protobuf:"varint,9,opt,name=resolve_time,json=resolveTime,proto3" json:"resolve_time,omitempty"`
	// ResolveStatus is the status of this oracle request, which can be OK,
	// FAILURE, or EXPIRED.
	ResolveStatus ResolveStatus `protobuf:"varint,10,opt,name=resolve_status,json=resolveStatus,proto3,enum=oracle.v1.ResolveStatus" json:"resolve_status,omitempty"`
	// Result is the final aggregated value only available if status if OK.
	Result []byte `protobuf:"bytes,11,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *Result) Reset()         { *m = Result{} }
func (m *Result) String() string { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()    {}
func (*Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{10}
}
func (m *Result) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Result.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Result.Merge(m, src)
}
func (m *Result) XXX_Size() int {
	return m.Size()
}
func (m *Result) XXX_DiscardUnknown() {
	xxx_messageInfo_Result.DiscardUnknown(m)
}

var xxx_messageInfo_Result proto.InternalMessageInfo

func (m *Result) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Result) GetOracleScriptID() OracleScriptID {
	if m != nil {
		return m.OracleScriptID
	}
	return 0
}

func (m *Result) GetCalldata() []byte {
	if m != nil {
		return m.Calldata
	}
	return nil
}

func (m *Result) GetAskCount() uint64 {
	if m != nil {
		return m.AskCount
	}
	return 0
}

func (m *Result) GetMinCount() uint64 {
	if m != nil {
		return m.MinCount
	}
	return 0
}

func (m *Result) GetRequestID() RequestID {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *Result) GetAnsCount() uint64 {
	if m != nil {
		return m.AnsCount
	}
	return 0
}

func (m *Result) GetRequestTime() int64 {
	if m != nil {
		return m.RequestTime
	}
	return 0
}

func (m *Result) GetResolveTime() int64 {
	if m != nil {
		return m.ResolveTime
	}
	return 0
}

func (m *Result) GetResolveStatus() ResolveStatus {
	if m != nil {
		return m.ResolveStatus
	}
	return RESOLVE_STATUS_OPEN
}

func (m *Result) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

// ValidatorStatus maintains whether a validator is an active oracle provider.
type ValidatorStatus struct {
	IsActive bool      `protobuf:"varint,1,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
	Since    time.Time `protobuf:"bytes,2,opt,name=since,proto3,stdtime" json:"since"`
}

func (m *ValidatorStatus) Reset()         { *m = ValidatorStatus{} }
func (m *ValidatorStatus) String() string { return proto.CompactTextString(m) }
func (*ValidatorStatus) ProtoMessage()    {}
func (*ValidatorStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{11}
}
func (m *ValidatorStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorStatus.Merge(m, src)
}
func (m *ValidatorStatus) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorStatus proto.InternalMessageInfo

func (m *ValidatorStatus) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

func (m *ValidatorStatus) GetSince() time.Time {
	if m != nil {
		return m.Since
	}
	return time.Time{}
}

// PendingResolveList
type PendingResolveList struct {
	RequestIds []int64 `protobuf:"varint,1,rep,packed,name=request_ids,json=requestIds,proto3" json:"request_ids,omitempty"`
}

func (m *PendingResolveList) Reset()         { *m = PendingResolveList{} }
func (m *PendingResolveList) String() string { return proto.CompactTextString(m) }
func (*PendingResolveList) ProtoMessage()    {}
func (*PendingResolveList) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{12}
}
func (m *PendingResolveList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PendingResolveList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PendingResolveList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PendingResolveList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PendingResolveList.Merge(m, src)
}
func (m *PendingResolveList) XXX_Size() int {
	return m.Size()
}
func (m *PendingResolveList) XXX_DiscardUnknown() {
	xxx_messageInfo_PendingResolveList.DiscardUnknown(m)
}

var xxx_messageInfo_PendingResolveList proto.InternalMessageInfo

func (m *PendingResolveList) GetRequestIds() []int64 {
	if m != nil {
		return m.RequestIds
	}
	return nil
}

// IBCSource
type IBCSource struct {
	// SourceChannel
	SourceChannel string `protobuf:"bytes,1,opt,name=source_channel,json=sourceChannel,proto3" json:"source_channel,omitempty"`
	// SourcePort
	SourcePort string `protobuf:"bytes,2,opt,name=source_port,json=sourcePort,proto3" json:"source_port,omitempty"`
}

func (m *IBCSource) Reset()         { *m = IBCSource{} }
func (m *IBCSource) String() string { return proto.CompactTextString(m) }
func (*IBCSource) ProtoMessage()    {}
func (*IBCSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{13}
}
func (m *IBCSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IBCSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IBCSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IBCSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IBCSource.Merge(m, src)
}
func (m *IBCSource) XXX_Size() int {
	return m.Size()
}
func (m *IBCSource) XXX_DiscardUnknown() {
	xxx_messageInfo_IBCSource.DiscardUnknown(m)
}

var xxx_messageInfo_IBCSource proto.InternalMessageInfo

func (m *IBCSource) GetSourceChannel() string {
	if m != nil {
		return m.SourceChannel
	}
	return ""
}

func (m *IBCSource) GetSourcePort() string {
	if m != nil {
		return m.SourcePort
	}
	return ""
}

type OraclePool struct {
	DataProvidersPool github_com_cosmos_cosmos_sdk_types.DecCoins `protobuf:"bytes,1,rep,name=data_providers_pool,json=dataProvidersPool,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.DecCoins" json:"data_providers_pool"`
}

func (m *OraclePool) Reset()         { *m = OraclePool{} }
func (m *OraclePool) String() string { return proto.CompactTextString(m) }
func (*OraclePool) ProtoMessage()    {}
func (*OraclePool) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{14}
}
func (m *OraclePool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OraclePool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OraclePool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OraclePool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OraclePool.Merge(m, src)
}
func (m *OraclePool) XXX_Size() int {
	return m.Size()
}
func (m *OraclePool) XXX_DiscardUnknown() {
	xxx_messageInfo_OraclePool.DiscardUnknown(m)
}

var xxx_messageInfo_OraclePool proto.InternalMessageInfo

func (m *OraclePool) GetDataProvidersPool() github_com_cosmos_cosmos_sdk_types.DecCoins {
	if m != nil {
		return m.DataProvidersPool
	}
	return nil
}

type DataProviderAccumulatedReward struct {
	DataProvider       string                                      `protobuf:"bytes,1,opt,name=data_provider,json=dataProvider,proto3" json:"data_provider,omitempty"`
	DataProviderReward github_com_cosmos_cosmos_sdk_types.DecCoins `protobuf:"bytes,2,rep,name=data_provider_reward,json=dataProviderReward,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.DecCoins" json:"data_provider_reward"`
}

func (m *DataProviderAccumulatedReward) Reset()         { *m = DataProviderAccumulatedReward{} }
func (m *DataProviderAccumulatedReward) String() string { return proto.CompactTextString(m) }
func (*DataProviderAccumulatedReward) ProtoMessage()    {}
func (*DataProviderAccumulatedReward) Descriptor() ([]byte, []int) {
	return fileDescriptor_652b57db11528d07, []int{15}
}
func (m *DataProviderAccumulatedReward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataProviderAccumulatedReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataProviderAccumulatedReward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataProviderAccumulatedReward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataProviderAccumulatedReward.Merge(m, src)
}
func (m *DataProviderAccumulatedReward) XXX_Size() int {
	return m.Size()
}
func (m *DataProviderAccumulatedReward) XXX_DiscardUnknown() {
	xxx_messageInfo_DataProviderAccumulatedReward.DiscardUnknown(m)
}

var xxx_messageInfo_DataProviderAccumulatedReward proto.InternalMessageInfo

func (m *DataProviderAccumulatedReward) GetDataProvider() string {
	if m != nil {
		return m.DataProvider
	}
	return ""
}

func (m *DataProviderAccumulatedReward) GetDataProviderReward() github_com_cosmos_cosmos_sdk_types.DecCoins {
	if m != nil {
		return m.DataProviderReward
	}
	return nil
}

func init() {
	proto.RegisterEnum("oracle.v1.ResolveStatus", ResolveStatus_name, ResolveStatus_value)
	proto.RegisterType((*DataSource)(nil), "oracle.v1.DataSource")
	proto.RegisterType((*OracleScript)(nil), "oracle.v1.OracleScript")
	proto.RegisterType((*RawRequest)(nil), "oracle.v1.RawRequest")
	proto.RegisterType((*RawReport)(nil), "oracle.v1.RawReport")
	proto.RegisterType((*Request)(nil), "oracle.v1.Request")
	proto.RegisterType((*Report)(nil), "oracle.v1.Report")
	proto.RegisterType((*OracleRequestPacketData)(nil), "oracle.v1.OracleRequestPacketData")
	proto.RegisterType((*OracleRequestPacketAcknowledgement)(nil), "oracle.v1.OracleRequestPacketAcknowledgement")
	proto.RegisterType((*OracleResponsePacketData)(nil), "oracle.v1.OracleResponsePacketData")
	proto.RegisterType((*RequestResult)(nil), "oracle.v1.RequestResult")
	proto.RegisterType((*Result)(nil), "oracle.v1.Result")
	proto.RegisterType((*ValidatorStatus)(nil), "oracle.v1.ValidatorStatus")
	proto.RegisterType((*PendingResolveList)(nil), "oracle.v1.PendingResolveList")
	proto.RegisterType((*IBCSource)(nil), "oracle.v1.IBCSource")
	proto.RegisterType((*OraclePool)(nil), "oracle.v1.OraclePool")
	proto.RegisterType((*DataProviderAccumulatedReward)(nil), "oracle.v1.DataProviderAccumulatedReward")
}

func init() { proto.RegisterFile("oracle/v1/oracle.proto", fileDescriptor_652b57db11528d07) }

var fileDescriptor_652b57db11528d07 = []byte{
	// 1508 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x57, 0xcd, 0x6f, 0x1b, 0x45,
	0x14, 0xcf, 0x7a, 0x9d, 0xd4, 0x3b, 0x76, 0xd2, 0x64, 0x1b, 0xda, 0xad, 0x5b, 0x6c, 0x93, 0x82,
	0x14, 0x8a, 0x6a, 0x93, 0x54, 0x42, 0x6a, 0xcb, 0x87, 0xe2, 0x8f, 0x16, 0xab, 0x51, 0x6b, 0x8d,
	0x93, 0x0a, 0x90, 0xd0, 0x6a, 0xbc, 0x3b, 0x71, 0x46, 0x59, 0xef, 0x98, 0x9d, 0x75, 0xd2, 0x1c,
	0x2b, 0x2e, 0xa8, 0xa7, 0x5e, 0x90, 0x10, 0x52, 0xa5, 0x4a, 0xdc, 0xb8, 0x73, 0x44, 0x42, 0x9c,
	0x7a, 0xa3, 0x27, 0x04, 0x17, 0x17, 0xb9, 0x42, 0xe2, 0x6f, 0x80, 0x0b, 0x9a, 0x8f, 0xb5, 0xbd,
	0xae, 0x4b, 0x4b, 0x29, 0x1c, 0x38, 0x79, 0xdf, 0xef, 0xbd, 0x37, 0xf3, 0x3e, 0x7e, 0xf3, 0x66,
	0x0c, 0x8e, 0xd3, 0x00, 0x39, 0x1e, 0x2e, 0xed, 0xaf, 0x95, 0xe4, 0x57, 0xb1, 0x1b, 0xd0, 0x90,
	0x9a, 0x86, 0x92, 0xf6, 0xd7, 0xb2, 0xcb, 0x6d, 0xda, 0xa6, 0x02, 0x2d, 0xf1, 0x2f, 0x69, 0x90,
	0xcd, 0xb7, 0x29, 0x6d, 0x7b, 0xb8, 0x24, 0xa4, 0x56, 0x6f, 0xa7, 0x14, 0x92, 0x0e, 0x66, 0x21,
	0xea, 0x74, 0x95, 0xc1, 0xc9, 0x49, 0x03, 0xe4, 0x1f, 0x2a, 0x55, 0xce, 0xa1, 0xac, 0x43, 0x59,
	0xa9, 0x85, 0x18, 0xdf, 0xb9, 0x85, 0x43, 0xb4, 0x56, 0x72, 0x28, 0xf1, 0xa5, 0x7e, 0xe5, 0x67,
	0x0d, 0x80, 0x2a, 0x0a, 0x51, 0x93, 0xf6, 0x02, 0x07, 0x9b, 0xcb, 0x60, 0x96, 0x1e, 0xf8, 0x38,
	0xb0, 0xb4, 0x82, 0xb6, 0x6a, 0x40, 0x29, 0x98, 0x26, 0x48, 0xfa, 0xa8, 0x83, 0xad, 0x84, 0x00,
	0xc5, 0xb7, 0x59, 0x00, 0x69, 0x17, 0x33, 0x27, 0x20, 0xdd, 0x90, 0x50, 0xdf, 0xd2, 0x85, 0x6a,
	0x1c, 0x32, 0xb3, 0x20, 0xb5, 0x43, 0x3c, 0x2c, 0x3c, 0x93, 0x42, 0x3d, 0x94, 0xcd, 0x8f, 0x81,
	0xbe, 0x83, 0xb1, 0x35, 0x5b, 0xd0, 0x57, 0xd3, 0xeb, 0x27, 0x8b, 0x32, 0xc8, 0x22, 0x0f, 0xb2,
	0xa8, 0x82, 0x2c, 0x56, 0x28, 0xf1, 0xcb, 0x6f, 0xde, 0xef, 0xe7, 0x67, 0xbe, 0x7e, 0x98, 0x5f,
	0x6d, 0x93, 0x70, 0xb7, 0xd7, 0x2a, 0x3a, 0xb4, 0x53, 0x52, 0x19, 0xc9, 0x9f, 0x73, 0xcc, 0xdd,
	0x2b, 0x85, 0x87, 0x5d, 0xcc, 0x84, 0x03, 0x83, 0x7c, 0xdd, 0x8b, 0xc9, 0xdf, 0xee, 0xe5, 0xb5,
	0x95, 0x1f, 0x34, 0x90, 0xb9, 0x2e, 0x6a, 0xdb, 0x14, 0x41, 0xfd, 0x67, 0xd9, 0x1d, 0x07, 0x73,
	0xcc, 0xd9, 0xc5, 0x1d, 0x64, 0xcd, 0x0a, 0x8d, 0x92, 0xcc, 0x0b, 0xe0, 0x28, 0x13, 0x75, 0xb6,
	0x1d, 0xea, 0x62, 0xbb, 0x17, 0x78, 0xd6, 0x1c, 0x37, 0x28, 0x2f, 0x0d, 0xfa, 0xf9, 0x79, 0xd9,
	0x82, 0x0a, 0x75, 0xf1, 0x36, 0xdc, 0x84, 0xf3, 0x6c, 0x24, 0x06, 0x9e, 0xca, 0xe8, 0x1b, 0x0d,
	0x00, 0x88, 0x0e, 0x20, 0xfe, 0xa4, 0x87, 0x59, 0x68, 0xbe, 0x03, 0xd2, 0xf8, 0x66, 0x88, 0x03,
	0x1f, 0x79, 0x36, 0x71, 0x45, 0x56, 0x7a, 0xf9, 0xf4, 0xa0, 0x9f, 0x07, 0x35, 0x05, 0xd7, 0xab,
	0xbf, 0xc7, 0x24, 0x08, 0x22, 0x87, 0xba, 0x6b, 0x5e, 0x06, 0x0b, 0x2e, 0x0a, 0x91, 0xad, 0x62,
	0x22, 0xae, 0x28, 0x81, 0x5e, 0x2e, 0x0c, 0xfa, 0xf9, 0xcc, 0x88, 0x14, 0x62, 0x8d, 0x98, 0x0c,
	0x33, 0xee, 0x48, 0x72, 0x79, 0x29, 0x1c, 0xe4, 0x79, 0x1c, 0x13, 0x95, 0xca, 0xc0, 0xa1, 0xac,
	0xe2, 0xbe, 0xa5, 0x01, 0x43, 0xc4, 0xdd, 0xa5, 0xc1, 0x3f, 0x0e, 0xfb, 0x14, 0x30, 0xf0, 0x4d,
	0x12, 0x8a, 0x1a, 0x8a, 0x88, 0xe7, 0x61, 0x8a, 0x03, 0xbc, 0x54, 0xbc, 0x99, 0x63, 0x71, 0x24,
	0xc7, 0x62, 0xf8, 0x55, 0x07, 0x47, 0xa2, 0xc2, 0x5d, 0x03, 0x8b, 0xf2, 0xd0, 0xd9, 0xb2, 0xa1,
	0xa3, 0x30, 0x5e, 0x1d, 0xf4, 0xf3, 0x0b, 0xe3, 0xa4, 0x11, 0xa1, 0x4c, 0x20, 0x70, 0x81, 0x8e,
	0xcb, 0xf1, 0x0a, 0x24, 0xe2, 0x15, 0x30, 0xd7, 0xc0, 0x72, 0x20, 0xb7, 0xc5, 0xae, 0xbd, 0x8f,
	0x3c, 0xe2, 0xa2, 0x90, 0x06, 0xcc, 0xd2, 0x0b, 0xfa, 0xaa, 0x01, 0x8f, 0x0d, 0x75, 0x37, 0x86,
	0x2a, 0x9e, 0x61, 0x87, 0xf8, 0xb6, 0x43, 0x7b, 0x7e, 0x28, 0xc8, 0x95, 0x84, 0xa9, 0x0e, 0xf1,
	0x2b, 0x5c, 0x36, 0x5f, 0x03, 0x0b, 0xca, 0xc7, 0xde, 0xc5, 0xa4, 0xbd, 0x1b, 0x0a, 0x92, 0xe9,
	0x70, 0x5e, 0xa1, 0xef, 0x0b, 0xd0, 0x7c, 0x05, 0x64, 0x22, 0x33, 0x3e, 0x2e, 0x04, 0xd1, 0x92,
	0x30, 0xad, 0xb0, 0x2d, 0xd2, 0xc1, 0xe6, 0xeb, 0xc0, 0x70, 0x3c, 0x82, 0x7d, 0x91, 0xfe, 0x11,
	0x41, 0xc4, 0xcc, 0xa0, 0x9f, 0x4f, 0x55, 0x04, 0x58, 0xaf, 0xc2, 0x94, 0x54, 0xd7, 0x5d, 0xf3,
	0x5d, 0x90, 0x09, 0xd0, 0x81, 0xad, 0xbc, 0x99, 0x95, 0x12, 0x07, 0xf7, 0xa5, 0xe2, 0x70, 0x74,
	0x15, 0x47, 0xb4, 0x2c, 0x27, 0xf9, 0xa1, 0x85, 0xe9, 0x60, 0x88, 0x30, 0xb3, 0x0c, 0x00, 0x69,
	0x39, 0x8a, 0x69, 0x96, 0x51, 0xd0, 0x56, 0xd3, 0xeb, 0xcb, 0x63, 0xde, 0xf5, 0x72, 0x45, 0xd2,
	0xa9, 0x3c, 0x3f, 0xe8, 0xe7, 0x8d, 0xa1, 0x08, 0x0d, 0xd2, 0x72, 0xd4, 0x6c, 0xca, 0x73, 0xda,
	0x60, 0xa7, 0x17, 0x62, 0xbb, 0x8d, 0x98, 0x05, 0x44, 0x42, 0x40, 0x41, 0x57, 0x10, 0x53, 0x7d,
	0xfe, 0x5c, 0x03, 0x73, 0x8a, 0x68, 0xa7, 0x81, 0x31, 0x2c, 0xb8, 0x3a, 0xf3, 0x23, 0xc0, 0x3c,
	0x0b, 0x96, 0x88, 0x6f, 0xb7, 0xf0, 0x0e, 0x0d, 0xb0, 0x1d, 0x60, 0x46, 0xbd, 0x7d, 0xc9, 0xa7,
	0x14, 0x3c, 0x4a, 0xfc, 0xb2, 0xc0, 0xa1, 0x84, 0xcd, 0x4b, 0x20, 0x2d, 0xf3, 0xe7, 0xeb, 0xca,
	0xde, 0xc5, 0x13, 0x18, 0xb2, 0x5b, 0x65, 0x0f, 0x82, 0x08, 0x88, 0xe2, 0xfa, 0x56, 0x07, 0x27,
	0x24, 0x8d, 0x54, 0x55, 0x1a, 0xc8, 0xd9, 0xc3, 0x21, 0x3f, 0x57, 0xf1, 0x4e, 0x68, 0x7f, 0xd9,
	0x89, 0x69, 0xd4, 0x4d, 0xbc, 0x20, 0xea, 0x4e, 0x1c, 0x5e, 0xce, 0x43, 0xc4, 0xf6, 0xe2, 0x3c,
	0x44, 0x6c, 0x4f, 0xf2, 0x30, 0x46, 0xd2, 0xd9, 0x09, 0x92, 0xee, 0x02, 0x63, 0x07, 0x63, 0xdb,
	0x23, 0x1d, 0x12, 0x5a, 0x73, 0x2f, 0x7e, 0xca, 0xa7, 0x76, 0x30, 0xde, 0xe4, 0x8b, 0x73, 0x56,
	0x44, 0x3c, 0xdf, 0xc3, 0x87, 0x92, 0xc6, 0x10, 0x28, 0xe8, 0x2a, 0x3e, 0xe4, 0x06, 0xdd, 0x00,
	0x77, 0x51, 0x20, 0x69, 0x93, 0x92, 0xb4, 0x51, 0xd0, 0x15, 0xc4, 0x26, 0x79, 0x65, 0x3c, 0x81,
	0x57, 0x18, 0xac, 0x4c, 0x69, 0xdf, 0x86, 0xb3, 0xe7, 0xd3, 0x03, 0x0f, 0xbb, 0x6d, 0xdc, 0xc1,
	0x7e, 0x68, 0x5e, 0x00, 0xd1, 0xde, 0xa3, 0x99, 0x92, 0xe5, 0x94, 0x56, 0x5e, 0xa2, 0x27, 0x23,
	0x01, 0x1a, 0xca, 0xba, 0xee, 0xaa, 0x6d, 0xbe, 0x4f, 0x00, 0x2b, 0xda, 0x87, 0x75, 0xa9, 0xcf,
	0xf0, 0xf3, 0xf1, 0x24, 0x1e, 0x48, 0xe2, 0x6f, 0x04, 0x22, 0xda, 0xee, 0x33, 0xd5, 0x59, 0x5d,
	0xb5, 0xdd, 0x67, 0xb2, 0xb3, 0x93, 0x73, 0x25, 0x29, 0x86, 0x4f, 0x6c, 0xae, 0x08, 0x13, 0x71,
	0x6e, 0xa4, 0xc9, 0x6c, 0x64, 0x22, 0x30, 0x61, 0xf2, 0x1e, 0x1f, 0x62, 0xd2, 0x84, 0x85, 0x28,
	0xec, 0x31, 0x31, 0x9f, 0x16, 0xd6, 0xad, 0xf1, 0x23, 0x25, 0x0d, 0x9a, 0x42, 0xcf, 0xc7, 0xdb,
	0x98, 0xc8, 0xaf, 0xd8, 0x00, 0xb3, 0x9e, 0x17, 0x8a, 0x8e, 0x67, 0xa0, 0x92, 0x54, 0x11, 0xbf,
	0xd3, 0xc0, 0xbc, 0x4a, 0x0d, 0x0a, 0xdc, 0x84, 0x20, 0x9a, 0xb4, 0x76, 0x57, 0xd4, 0xd3, 0x16,
	0x8c, 0xd7, 0xc4, 0x24, 0x5a, 0x19, 0xdb, 0xf5, 0x09, 0x47, 0x14, 0x2e, 0x05, 0x8f, 0x9d, 0xda,
	0x6d, 0x3e, 0xd9, 0x65, 0x8f, 0x62, 0x8b, 0x26, 0xc4, 0xa2, 0x67, 0xa6, 0x2c, 0x3a, 0xd9, 0x50,
	0x68, 0x06, 0x8f, 0x61, 0x2a, 0x85, 0x1f, 0x75, 0x3e, 0xc6, 0x44, 0xec, 0xff, 0xbb, 0xe9, 0x10,
	0xe7, 0xe6, 0xdc, 0x73, 0x73, 0xf3, 0xc8, 0x53, 0xb8, 0x99, 0x7a, 0x3a, 0x37, 0x8d, 0x67, 0xe1,
	0x26, 0x78, 0x5e, 0x6e, 0xa6, 0xa7, 0x70, 0xb3, 0x0b, 0x8e, 0x0e, 0xaf, 0x7a, 0xe5, 0x70, 0x0a,
	0x18, 0x84, 0xd9, 0xc8, 0x09, 0xc9, 0x3e, 0x16, 0x0d, 0x4e, 0xc1, 0x14, 0x61, 0x1b, 0x42, 0x36,
	0x2f, 0x82, 0x59, 0x46, 0x7c, 0x07, 0x2b, 0x5a, 0x65, 0x8b, 0xf2, 0xb1, 0x5f, 0x8c, 0x1e, 0xfb,
	0xc5, 0xad, 0xe8, 0xdf, 0x40, 0x39, 0xc5, 0xe7, 0xe8, 0x9d, 0x87, 0x79, 0x0d, 0x4a, 0x17, 0xb5,
	0xe3, 0x25, 0x60, 0x36, 0xb0, 0xef, 0x12, 0xbf, 0xad, 0xc2, 0xde, 0x24, 0x2c, 0x36, 0x38, 0x89,
	0xcb, 0x2c, 0xad, 0xa0, 0xaf, 0xea, 0xc3, 0xc1, 0x59, 0x77, 0xa3, 0xb1, 0xf7, 0x21, 0x18, 0xdd,
	0xc6, 0xfc, 0xed, 0x11, 0x3d, 0x60, 0x77, 0x91, 0xef, 0x63, 0x4f, 0xdd, 0xaa, 0xd1, 0x63, 0x55,
	0x82, 0x7c, 0x69, 0x65, 0xc6, 0x2f, 0x40, 0xf5, 0xb0, 0x06, 0x12, 0x6a, 0xd0, 0x20, 0xaa, 0xc4,
	0x97, 0x1a, 0x00, 0x92, 0x7f, 0x0d, 0x4a, 0x3d, 0xf3, 0x96, 0x06, 0x8e, 0x89, 0xf7, 0x68, 0x37,
	0xa0, 0xfb, 0xc4, 0xc5, 0x01, 0xb3, 0xbb, 0x94, 0x7a, 0x22, 0xb2, 0xf4, 0xfa, 0xe9, 0xa9, 0xd7,
	0x47, 0x15, 0x3b, 0xe2, 0x06, 0x39, 0xaf, 0x6e, 0x90, 0x37, 0x9e, 0xe1, 0x06, 0x51, 0x3e, 0x0c,
	0x2e, 0xf1, 0xdd, 0x1a, 0xd1, 0x66, 0x3c, 0x86, 0x8b, 0xa9, 0x2f, 0xee, 0xe5, 0x35, 0x11, 0xdc,
	0x03, 0x0d, 0xbc, 0x5c, 0x1d, 0xd3, 0x6f, 0x38, 0x4e, 0xaf, 0xd3, 0xf3, 0x50, 0x88, 0x5d, 0x88,
	0x0f, 0x50, 0xe0, 0x9a, 0x67, 0xc0, 0x7c, 0x2c, 0x5c, 0x55, 0x8b, 0xcc, 0xf8, 0xaa, 0xe6, 0xa7,
	0x1a, 0x58, 0x8e, 0x59, 0xd9, 0x81, 0xf0, 0xb6, 0x12, 0xff, 0x56, 0x56, 0xe6, 0xf8, 0xfe, 0x32,
	0x54, 0x51, 0xef, 0x99, 0xb3, 0x7f, 0x88, 0xa9, 0x38, 0xce, 0xd4, 0xb7, 0x41, 0x1e, 0xd6, 0x9a,
	0xd7, 0x37, 0x6f, 0xd4, 0xec, 0xe6, 0xd6, 0xc6, 0xd6, 0x76, 0xd3, 0xbe, 0xde, 0xa8, 0x5d, 0xb3,
	0xb7, 0xaf, 0x35, 0x1b, 0xb5, 0x4a, 0xfd, 0x72, 0xbd, 0x56, 0x5d, 0x9c, 0xc9, 0x9e, 0xb8, 0x7d,
	0xb7, 0x70, 0x6c, 0x8a, 0x99, 0xf9, 0x16, 0x38, 0x3e, 0x01, 0x37, 0xb7, 0x2b, 0x95, 0x5a, 0xb3,
	0xb9, 0xa8, 0x65, 0xb3, 0xb7, 0xef, 0x16, 0x9e, 0xa0, 0x9d, 0xe2, 0x77, 0x79, 0xa3, 0xbe, 0xb9,
	0x0d, 0x6b, 0x8b, 0x89, 0xa9, 0x7e, 0x4a, 0x3b, 0xc5, 0xaf, 0xf6, 0x41, 0xa3, 0x0e, 0x6b, 0xd5,
	0x45, 0x7d, 0xaa, 0x9f, 0xd2, 0x66, 0x93, 0x9f, 0x7d, 0x95, 0x9b, 0x29, 0x5f, 0xbd, 0x3f, 0xc8,
	0x69, 0x0f, 0x06, 0x39, 0xed, 0x97, 0x41, 0x4e, 0xbb, 0xf3, 0x28, 0x37, 0xf3, 0xe0, 0x51, 0x6e,
	0xe6, 0xa7, 0x47, 0xb9, 0x99, 0x8f, 0xd6, 0xc6, 0xca, 0x7b, 0x05, 0xd3, 0x6a, 0xf9, 0x9c, 0x78,
	0x5a, 0x60, 0xb7, 0x44, 0x5d, 0xe2, 0x9f, 0x73, 0x68, 0x80, 0x4b, 0x37, 0xd5, 0x7f, 0x76, 0x59,
	0xed, 0xd6, 0x9c, 0x38, 0x7d, 0xe7, 0xff, 0x0c, 0x00, 0x00, 0xff, 0xff, 0x8b, 0x41, 0x2a, 0x73,
	0xd4, 0x0f, 0x00, 0x00,
}

func (this *DataSource) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataSource)
	if !ok {
		that2, ok := that.(DataSource)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Owner != that1.Owner {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Filename != that1.Filename {
		return false
	}
	if len(this.Fee) != len(that1.Fee) {
		return false
	}
	for i := range this.Fee {
		if !this.Fee[i].Equal(&that1.Fee[i]) {
			return false
		}
	}
	return true
}
func (this *OracleScript) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OracleScript)
	if !ok {
		that2, ok := that.(OracleScript)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Owner != that1.Owner {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Filename != that1.Filename {
		return false
	}
	if this.Schema != that1.Schema {
		return false
	}
	if this.SourceCodeURL != that1.SourceCodeURL {
		return false
	}
	return true
}
func (this *RawRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RawRequest)
	if !ok {
		that2, ok := that.(RawRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExternalID != that1.ExternalID {
		return false
	}
	if this.DataSourceID != that1.DataSourceID {
		return false
	}
	if !bytes.Equal(this.Calldata, that1.Calldata) {
		return false
	}
	return true
}
func (this *RawReport) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RawReport)
	if !ok {
		that2, ok := that.(RawReport)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExternalID != that1.ExternalID {
		return false
	}
	if this.ExitCode != that1.ExitCode {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (this *Request) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Request)
	if !ok {
		that2, ok := that.(Request)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OracleScriptID != that1.OracleScriptID {
		return false
	}
	if !bytes.Equal(this.Calldata, that1.Calldata) {
		return false
	}
	if len(this.RequestedValidators) != len(that1.RequestedValidators) {
		return false
	}
	for i := range this.RequestedValidators {
		if this.RequestedValidators[i] != that1.RequestedValidators[i] {
			return false
		}
	}
	if this.MinCount != that1.MinCount {
		return false
	}
	if this.RequestHeight != that1.RequestHeight {
		return false
	}
	if this.RequestTime != that1.RequestTime {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if len(this.RawRequests) != len(that1.RawRequests) {
		return false
	}
	for i := range this.RawRequests {
		if !this.RawRequests[i].Equal(&that1.RawRequests[i]) {
			return false
		}
	}
	if !this.IBCSource.Equal(that1.IBCSource) {
		return false
	}
	if this.ExecuteGas != that1.ExecuteGas {
		return false
	}
	return true
}
func (this *Report) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Report)
	if !ok {
		that2, ok := that.(Report)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Validator != that1.Validator {
		return false
	}
	if this.InBeforeResolve != that1.InBeforeResolve {
		return false
	}
	if len(this.RawReports) != len(that1.RawReports) {
		return false
	}
	for i := range this.RawReports {
		if !this.RawReports[i].Equal(&that1.RawReports[i]) {
			return false
		}
	}
	return true
}
func (this *OracleRequestPacketData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OracleRequestPacketData)
	if !ok {
		that2, ok := that.(OracleRequestPacketData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.OracleScriptID != that1.OracleScriptID {
		return false
	}
	if !bytes.Equal(this.Calldata, that1.Calldata) {
		return false
	}
	if this.AskCount != that1.AskCount {
		return false
	}
	if this.MinCount != that1.MinCount {
		return false
	}
	if len(this.FeeLimit) != len(that1.FeeLimit) {
		return false
	}
	for i := range this.FeeLimit {
		if !this.FeeLimit[i].Equal(&that1.FeeLimit[i]) {
			return false
		}
	}
	if this.RequestKey != that1.RequestKey {
		return false
	}
	if this.PrepareGas != that1.PrepareGas {
		return false
	}
	if this.ExecuteGas != that1.ExecuteGas {
		return false
	}
	return true
}
func (this *OracleRequestPacketAcknowledgement) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OracleRequestPacketAcknowledgement)
	if !ok {
		that2, ok := that.(OracleRequestPacketAcknowledgement)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	return true
}
func (this *OracleResponsePacketData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OracleResponsePacketData)
	if !ok {
		that2, ok := that.(OracleResponsePacketData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.AnsCount != that1.AnsCount {
		return false
	}
	if this.RequestTime != that1.RequestTime {
		return false
	}
	if this.ResolveTime != that1.ResolveTime {
		return false
	}
	if this.ResolveStatus != that1.ResolveStatus {
		return false
	}
	if !bytes.Equal(this.Result, that1.Result) {
		return false
	}
	return true
}
func (this *RequestResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestResult)
	if !ok {
		that2, ok := that.(RequestResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RequestPacketData.Equal(that1.RequestPacketData) {
		return false
	}
	if !this.ResponsePacketData.Equal(that1.ResponsePacketData) {
		return false
	}
	return true
}
func (this *Result) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Result)
	if !ok {
		that2, ok := that.(Result)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.OracleScriptID != that1.OracleScriptID {
		return false
	}
	if !bytes.Equal(this.Calldata, that1.Calldata) {
		return false
	}
	if this.AskCount != that1.AskCount {
		return false
	}
	if this.MinCount != that1.MinCount {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.AnsCount != that1.AnsCount {
		return false
	}
	if this.RequestTime != that1.RequestTime {
		return false
	}
	if this.ResolveTime != that1.ResolveTime {
		return false
	}
	if this.ResolveStatus != that1.ResolveStatus {
		return false
	}
	if !bytes.Equal(this.Result, that1.Result) {
		return false
	}
	return true
}
func (this *ValidatorStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ValidatorStatus)
	if !ok {
		that2, ok := that.(ValidatorStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IsActive != that1.IsActive {
		return false
	}
	if !this.Since.Equal(that1.Since) {
		return false
	}
	return true
}
func (this *PendingResolveList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PendingResolveList)
	if !ok {
		that2, ok := that.(PendingResolveList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.RequestIds) != len(that1.RequestIds) {
		return false
	}
	for i := range this.RequestIds {
		if this.RequestIds[i] != that1.RequestIds[i] {
			return false
		}
	}
	return true
}
func (this *IBCSource) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IBCSource)
	if !ok {
		that2, ok := that.(IBCSource)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SourceChannel != that1.SourceChannel {
		return false
	}
	if this.SourcePort != that1.SourcePort {
		return false
	}
	return true
}
func (this *OraclePool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OraclePool)
	if !ok {
		that2, ok := that.(OraclePool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.DataProvidersPool) != len(that1.DataProvidersPool) {
		return false
	}
	for i := range this.DataProvidersPool {
		if !this.DataProvidersPool[i].Equal(&that1.DataProvidersPool[i]) {
			return false
		}
	}
	return true
}
func (m *DataSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fee) > 0 {
		for iNdEx := len(m.Fee) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fee[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOracle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Filename) > 0 {
		i -= len(m.Filename)
		copy(dAtA[i:], m.Filename)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Filename)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OracleScript) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleScript) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleScript) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SourceCodeURL) > 0 {
		i -= len(m.SourceCodeURL)
		copy(dAtA[i:], m.SourceCodeURL)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.SourceCodeURL)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Schema) > 0 {
		i -= len(m.Schema)
		copy(dAtA[i:], m.Schema)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Schema)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Filename) > 0 {
		i -= len(m.Filename)
		copy(dAtA[i:], m.Filename)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Filename)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RawRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Calldata) > 0 {
		i -= len(m.Calldata)
		copy(dAtA[i:], m.Calldata)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Calldata)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DataSourceID != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.DataSourceID))
		i--
		dAtA[i] = 0x10
	}
	if m.ExternalID != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.ExternalID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RawReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ExitCode != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.ExitCode))
		i--
		dAtA[i] = 0x10
	}
	if m.ExternalID != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.ExternalID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExecuteGas != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.ExecuteGas))
		i--
		dAtA[i] = 0x50
	}
	if m.IBCSource != nil {
		{
			size, err := m.IBCSource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOracle(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.RawRequests) > 0 {
		for iNdEx := len(m.RawRequests) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RawRequests[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOracle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ClientID) > 0 {
		i -= len(m.ClientID)
		copy(dAtA[i:], m.ClientID)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.ClientID)))
		i--
		dAtA[i] = 0x3a
	}
	if m.RequestTime != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.RequestTime))
		i--
		dAtA[i] = 0x30
	}
	if m.RequestHeight != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.RequestHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.MinCount != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.MinCount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RequestedValidators) > 0 {
		for iNdEx := len(m.RequestedValidators) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RequestedValidators[iNdEx])
			copy(dAtA[i:], m.RequestedValidators[iNdEx])
			i = encodeVarintOracle(dAtA, i, uint64(len(m.RequestedValidators[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Calldata) > 0 {
		i -= len(m.Calldata)
		copy(dAtA[i:], m.Calldata)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Calldata)))
		i--
		dAtA[i] = 0x12
	}
	if m.OracleScriptID != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.OracleScriptID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Report) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Report) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Report) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RawReports) > 0 {
		for iNdEx := len(m.RawReports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RawReports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOracle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.InBeforeResolve {
		i--
		if m.InBeforeResolve {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OracleRequestPacketData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleRequestPacketData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleRequestPacketData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExecuteGas != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.ExecuteGas))
		i--
		dAtA[i] = 0x48
	}
	if m.PrepareGas != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.PrepareGas))
		i--
		dAtA[i] = 0x40
	}
	if len(m.RequestKey) > 0 {
		i -= len(m.RequestKey)
		copy(dAtA[i:], m.RequestKey)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.RequestKey)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.FeeLimit) > 0 {
		for iNdEx := len(m.FeeLimit) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FeeLimit[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOracle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.MinCount != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.MinCount))
		i--
		dAtA[i] = 0x28
	}
	if m.AskCount != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.AskCount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Calldata) > 0 {
		i -= len(m.Calldata)
		copy(dAtA[i:], m.Calldata)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Calldata)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OracleScriptID != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.OracleScriptID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ClientID) > 0 {
		i -= len(m.ClientID)
		copy(dAtA[i:], m.ClientID)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.ClientID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OracleRequestPacketAcknowledgement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleRequestPacketAcknowledgement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleRequestPacketAcknowledgement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequestID != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.RequestID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OracleResponsePacketData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleResponsePacketData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleResponsePacketData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ResolveStatus != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.ResolveStatus))
		i--
		dAtA[i] = 0x30
	}
	if m.ResolveTime != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.ResolveTime))
		i--
		dAtA[i] = 0x28
	}
	if m.RequestTime != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.RequestTime))
		i--
		dAtA[i] = 0x20
	}
	if m.AnsCount != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.AnsCount))
		i--
		dAtA[i] = 0x18
	}
	if m.RequestID != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.RequestID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ClientID) > 0 {
		i -= len(m.ClientID)
		copy(dAtA[i:], m.ClientID)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.ClientID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResponsePacketData != nil {
		{
			size, err := m.ResponsePacketData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOracle(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.RequestPacketData != nil {
		{
			size, err := m.RequestPacketData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOracle(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Result) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Result) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x5a
	}
	if m.ResolveStatus != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.ResolveStatus))
		i--
		dAtA[i] = 0x50
	}
	if m.ResolveTime != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.ResolveTime))
		i--
		dAtA[i] = 0x48
	}
	if m.RequestTime != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.RequestTime))
		i--
		dAtA[i] = 0x40
	}
	if m.AnsCount != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.AnsCount))
		i--
		dAtA[i] = 0x38
	}
	if m.RequestID != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.RequestID))
		i--
		dAtA[i] = 0x30
	}
	if m.MinCount != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.MinCount))
		i--
		dAtA[i] = 0x28
	}
	if m.AskCount != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.AskCount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Calldata) > 0 {
		i -= len(m.Calldata)
		copy(dAtA[i:], m.Calldata)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Calldata)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OracleScriptID != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.OracleScriptID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ClientID) > 0 {
		i -= len(m.ClientID)
		copy(dAtA[i:], m.ClientID)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.ClientID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n4, err4 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Since, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Since):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintOracle(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x12
	if m.IsActive {
		i--
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PendingResolveList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PendingResolveList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PendingResolveList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RequestIds) > 0 {
		dAtA6 := make([]byte, len(m.RequestIds)*10)
		var j5 int
		for _, num1 := range m.RequestIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintOracle(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IBCSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IBCSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IBCSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SourcePort) > 0 {
		i -= len(m.SourcePort)
		copy(dAtA[i:], m.SourcePort)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.SourcePort)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SourceChannel) > 0 {
		i -= len(m.SourceChannel)
		copy(dAtA[i:], m.SourceChannel)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.SourceChannel)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OraclePool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OraclePool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OraclePool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DataProvidersPool) > 0 {
		for iNdEx := len(m.DataProvidersPool) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DataProvidersPool[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOracle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DataProviderAccumulatedReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataProviderAccumulatedReward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataProviderAccumulatedReward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DataProviderReward) > 0 {
		for iNdEx := len(m.DataProviderReward) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DataProviderReward[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOracle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.DataProvider) > 0 {
		i -= len(m.DataProvider)
		copy(dAtA[i:], m.DataProvider)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.DataProvider)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintOracle(dAtA []byte, offset int, v uint64) int {
	offset -= sovOracle(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DataSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if len(m.Fee) > 0 {
		for _, e := range m.Fee {
			l = e.Size()
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	return n
}

func (m *OracleScript) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Schema)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.SourceCodeURL)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	return n
}

func (m *RawRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExternalID != 0 {
		n += 1 + sovOracle(uint64(m.ExternalID))
	}
	if m.DataSourceID != 0 {
		n += 1 + sovOracle(uint64(m.DataSourceID))
	}
	l = len(m.Calldata)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	return n
}

func (m *RawReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExternalID != 0 {
		n += 1 + sovOracle(uint64(m.ExternalID))
	}
	if m.ExitCode != 0 {
		n += 1 + sovOracle(uint64(m.ExitCode))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	return n
}

func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OracleScriptID != 0 {
		n += 1 + sovOracle(uint64(m.OracleScriptID))
	}
	l = len(m.Calldata)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if len(m.RequestedValidators) > 0 {
		for _, s := range m.RequestedValidators {
			l = len(s)
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	if m.MinCount != 0 {
		n += 1 + sovOracle(uint64(m.MinCount))
	}
	if m.RequestHeight != 0 {
		n += 1 + sovOracle(uint64(m.RequestHeight))
	}
	if m.RequestTime != 0 {
		n += 1 + sovOracle(uint64(m.RequestTime))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if len(m.RawRequests) > 0 {
		for _, e := range m.RawRequests {
			l = e.Size()
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	if m.IBCSource != nil {
		l = m.IBCSource.Size()
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.ExecuteGas != 0 {
		n += 1 + sovOracle(uint64(m.ExecuteGas))
	}
	return n
}

func (m *Report) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.InBeforeResolve {
		n += 2
	}
	if len(m.RawReports) > 0 {
		for _, e := range m.RawReports {
			l = e.Size()
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	return n
}

func (m *OracleRequestPacketData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.OracleScriptID != 0 {
		n += 1 + sovOracle(uint64(m.OracleScriptID))
	}
	l = len(m.Calldata)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.AskCount != 0 {
		n += 1 + sovOracle(uint64(m.AskCount))
	}
	if m.MinCount != 0 {
		n += 1 + sovOracle(uint64(m.MinCount))
	}
	if len(m.FeeLimit) > 0 {
		for _, e := range m.FeeLimit {
			l = e.Size()
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	l = len(m.RequestKey)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.PrepareGas != 0 {
		n += 1 + sovOracle(uint64(m.PrepareGas))
	}
	if m.ExecuteGas != 0 {
		n += 1 + sovOracle(uint64(m.ExecuteGas))
	}
	return n
}

func (m *OracleRequestPacketAcknowledgement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestID != 0 {
		n += 1 + sovOracle(uint64(m.RequestID))
	}
	return n
}

func (m *OracleResponsePacketData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.RequestID != 0 {
		n += 1 + sovOracle(uint64(m.RequestID))
	}
	if m.AnsCount != 0 {
		n += 1 + sovOracle(uint64(m.AnsCount))
	}
	if m.RequestTime != 0 {
		n += 1 + sovOracle(uint64(m.RequestTime))
	}
	if m.ResolveTime != 0 {
		n += 1 + sovOracle(uint64(m.ResolveTime))
	}
	if m.ResolveStatus != 0 {
		n += 1 + sovOracle(uint64(m.ResolveStatus))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	return n
}

func (m *RequestResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestPacketData != nil {
		l = m.RequestPacketData.Size()
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.ResponsePacketData != nil {
		l = m.ResponsePacketData.Size()
		n += 1 + l + sovOracle(uint64(l))
	}
	return n
}

func (m *Result) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.OracleScriptID != 0 {
		n += 1 + sovOracle(uint64(m.OracleScriptID))
	}
	l = len(m.Calldata)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.AskCount != 0 {
		n += 1 + sovOracle(uint64(m.AskCount))
	}
	if m.MinCount != 0 {
		n += 1 + sovOracle(uint64(m.MinCount))
	}
	if m.RequestID != 0 {
		n += 1 + sovOracle(uint64(m.RequestID))
	}
	if m.AnsCount != 0 {
		n += 1 + sovOracle(uint64(m.AnsCount))
	}
	if m.RequestTime != 0 {
		n += 1 + sovOracle(uint64(m.RequestTime))
	}
	if m.ResolveTime != 0 {
		n += 1 + sovOracle(uint64(m.ResolveTime))
	}
	if m.ResolveStatus != 0 {
		n += 1 + sovOracle(uint64(m.ResolveStatus))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	return n
}

func (m *ValidatorStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsActive {
		n += 2
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Since)
	n += 1 + l + sovOracle(uint64(l))
	return n
}

func (m *PendingResolveList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RequestIds) > 0 {
		l = 0
		for _, e := range m.RequestIds {
			l += sovOracle(uint64(e))
		}
		n += 1 + sovOracle(uint64(l)) + l
	}
	return n
}

func (m *IBCSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SourceChannel)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.SourcePort)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	return n
}

func (m *OraclePool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DataProvidersPool) > 0 {
		for _, e := range m.DataProvidersPool {
			l = e.Size()
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	return n
}

func (m *DataProviderAccumulatedReward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DataProvider)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if len(m.DataProviderReward) > 0 {
		for _, e := range m.DataProviderReward {
			l = e.Size()
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	return n
}

func sovOracle(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOracle(x uint64) (n int) {
	return sovOracle(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DataSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fee = append(m.Fee, types.Coin{})
			if err := m.Fee[len(m.Fee)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleScript) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleScript: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleScript: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceCodeURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceCodeURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalID", wireType)
			}
			m.ExternalID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalID |= ExternalID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSourceID", wireType)
			}
			m.DataSourceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSourceID |= DataSourceID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Calldata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Calldata = append(m.Calldata[:0], dAtA[iNdEx:postIndex]...)
			if m.Calldata == nil {
				m.Calldata = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalID", wireType)
			}
			m.ExternalID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalID |= ExternalID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitCode", wireType)
			}
			m.ExitCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExitCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScriptID", wireType)
			}
			m.OracleScriptID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScriptID |= OracleScriptID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Calldata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Calldata = append(m.Calldata[:0], dAtA[iNdEx:postIndex]...)
			if m.Calldata == nil {
				m.Calldata = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedValidators", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestedValidators = append(m.RequestedValidators, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinCount", wireType)
			}
			m.MinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeight", wireType)
			}
			m.RequestHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTime", wireType)
			}
			m.RequestTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawRequests = append(m.RawRequests, RawRequest{})
			if err := m.RawRequests[len(m.RawRequests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IBCSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IBCSource == nil {
				m.IBCSource = &IBCSource{}
			}
			if err := m.IBCSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecuteGas", wireType)
			}
			m.ExecuteGas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecuteGas |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Report) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Report: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Report: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InBeforeResolve", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InBeforeResolve = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawReports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawReports = append(m.RawReports, RawReport{})
			if err := m.RawReports[len(m.RawReports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleRequestPacketData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleRequestPacketData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleRequestPacketData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScriptID", wireType)
			}
			m.OracleScriptID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScriptID |= OracleScriptID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Calldata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Calldata = append(m.Calldata[:0], dAtA[iNdEx:postIndex]...)
			if m.Calldata == nil {
				m.Calldata = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskCount", wireType)
			}
			m.AskCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AskCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinCount", wireType)
			}
			m.MinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeLimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeLimit = append(m.FeeLimit, types.Coin{})
			if err := m.FeeLimit[len(m.FeeLimit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareGas", wireType)
			}
			m.PrepareGas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrepareGas |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecuteGas", wireType)
			}
			m.ExecuteGas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecuteGas |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleRequestPacketAcknowledgement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleRequestPacketAcknowledgement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleRequestPacketAcknowledgement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID |= RequestID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleResponsePacketData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleResponsePacketData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleResponsePacketData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID |= RequestID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnsCount", wireType)
			}
			m.AnsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnsCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTime", wireType)
			}
			m.RequestTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveTime", wireType)
			}
			m.ResolveTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResolveTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveStatus", wireType)
			}
			m.ResolveStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResolveStatus |= ResolveStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestPacketData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestPacketData == nil {
				m.RequestPacketData = &OracleRequestPacketData{}
			}
			if err := m.RequestPacketData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponsePacketData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResponsePacketData == nil {
				m.ResponsePacketData = &OracleResponsePacketData{}
			}
			if err := m.ResponsePacketData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScriptID", wireType)
			}
			m.OracleScriptID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScriptID |= OracleScriptID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Calldata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Calldata = append(m.Calldata[:0], dAtA[iNdEx:postIndex]...)
			if m.Calldata == nil {
				m.Calldata = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskCount", wireType)
			}
			m.AskCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AskCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinCount", wireType)
			}
			m.MinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID |= RequestID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnsCount", wireType)
			}
			m.AnsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnsCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTime", wireType)
			}
			m.RequestTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveTime", wireType)
			}
			m.ResolveTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResolveTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveStatus", wireType)
			}
			m.ResolveStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResolveStatus |= ResolveStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Since", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Since, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendingResolveList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendingResolveList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendingResolveList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOracle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RequestIds = append(m.RequestIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOracle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOracle
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOracle
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RequestIds) == 0 {
					m.RequestIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOracle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RequestIds = append(m.RequestIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IBCSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IBCSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IBCSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourcePort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourcePort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OraclePool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OraclePool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OraclePool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataProvidersPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataProvidersPool = append(m.DataProvidersPool, types.DecCoin{})
			if err := m.DataProvidersPool[len(m.DataProvidersPool)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataProviderAccumulatedReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataProviderAccumulatedReward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataProviderAccumulatedReward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataProvider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataProvider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataProviderReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataProviderReward = append(m.DataProviderReward, types.DecCoin{})
			if err := m.DataProviderReward[len(m.DataProviderReward)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOracle(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOracle
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOracle
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOracle
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOracle        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOracle          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOracle = fmt.Errorf("proto: unexpected end of group")
)
