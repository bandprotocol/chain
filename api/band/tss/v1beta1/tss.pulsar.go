// Code generated by protoc-gen-go-pulsar. DO NOT EDIT.
package tssv1beta1

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	runtime "github.com/cosmos/cosmos-proto/runtime"
	_ "github.com/cosmos/gogoproto/gogoproto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoiface "google.golang.org/protobuf/runtime/protoiface"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	reflect "reflect"
	sync "sync"
)

var (
	md_Group                protoreflect.MessageDescriptor
	fd_Group_id             protoreflect.FieldDescriptor
	fd_Group_size           protoreflect.FieldDescriptor
	fd_Group_threshold      protoreflect.FieldDescriptor
	fd_Group_pub_key        protoreflect.FieldDescriptor
	fd_Group_status         protoreflect.FieldDescriptor
	fd_Group_created_height protoreflect.FieldDescriptor
	fd_Group_module_owner   protoreflect.FieldDescriptor
)

func init() {
	file_band_tss_v1beta1_tss_proto_init()
	md_Group = File_band_tss_v1beta1_tss_proto.Messages().ByName("Group")
	fd_Group_id = md_Group.Fields().ByName("id")
	fd_Group_size = md_Group.Fields().ByName("size")
	fd_Group_threshold = md_Group.Fields().ByName("threshold")
	fd_Group_pub_key = md_Group.Fields().ByName("pub_key")
	fd_Group_status = md_Group.Fields().ByName("status")
	fd_Group_created_height = md_Group.Fields().ByName("created_height")
	fd_Group_module_owner = md_Group.Fields().ByName("module_owner")
}

var _ protoreflect.Message = (*fastReflection_Group)(nil)

type fastReflection_Group Group

func (x *Group) ProtoReflect() protoreflect.Message {
	return (*fastReflection_Group)(x)
}

func (x *Group) slowProtoReflect() protoreflect.Message {
	mi := &file_band_tss_v1beta1_tss_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_Group_messageType fastReflection_Group_messageType
var _ protoreflect.MessageType = fastReflection_Group_messageType{}

type fastReflection_Group_messageType struct{}

func (x fastReflection_Group_messageType) Zero() protoreflect.Message {
	return (*fastReflection_Group)(nil)
}
func (x fastReflection_Group_messageType) New() protoreflect.Message {
	return new(fastReflection_Group)
}
func (x fastReflection_Group_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_Group
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_Group) Descriptor() protoreflect.MessageDescriptor {
	return md_Group
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_Group) Type() protoreflect.MessageType {
	return _fastReflection_Group_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_Group) New() protoreflect.Message {
	return new(fastReflection_Group)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_Group) Interface() protoreflect.ProtoMessage {
	return (*Group)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_Group) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Id != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Id)
		if !f(fd_Group_id, value) {
			return
		}
	}
	if x.Size != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Size)
		if !f(fd_Group_size, value) {
			return
		}
	}
	if x.Threshold != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Threshold)
		if !f(fd_Group_threshold, value) {
			return
		}
	}
	if len(x.PubKey) != 0 {
		value := protoreflect.ValueOfBytes(x.PubKey)
		if !f(fd_Group_pub_key, value) {
			return
		}
	}
	if x.Status != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.Status))
		if !f(fd_Group_status, value) {
			return
		}
	}
	if x.CreatedHeight != uint64(0) {
		value := protoreflect.ValueOfUint64(x.CreatedHeight)
		if !f(fd_Group_created_height, value) {
			return
		}
	}
	if x.ModuleOwner != "" {
		value := protoreflect.ValueOfString(x.ModuleOwner)
		if !f(fd_Group_module_owner, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_Group) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "band.tss.v1beta1.Group.id":
		return x.Id != uint64(0)
	case "band.tss.v1beta1.Group.size":
		return x.Size != uint64(0)
	case "band.tss.v1beta1.Group.threshold":
		return x.Threshold != uint64(0)
	case "band.tss.v1beta1.Group.pub_key":
		return len(x.PubKey) != 0
	case "band.tss.v1beta1.Group.status":
		return x.Status != 0
	case "band.tss.v1beta1.Group.created_height":
		return x.CreatedHeight != uint64(0)
	case "band.tss.v1beta1.Group.module_owner":
		return x.ModuleOwner != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Group"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Group does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Group) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "band.tss.v1beta1.Group.id":
		x.Id = uint64(0)
	case "band.tss.v1beta1.Group.size":
		x.Size = uint64(0)
	case "band.tss.v1beta1.Group.threshold":
		x.Threshold = uint64(0)
	case "band.tss.v1beta1.Group.pub_key":
		x.PubKey = nil
	case "band.tss.v1beta1.Group.status":
		x.Status = 0
	case "band.tss.v1beta1.Group.created_height":
		x.CreatedHeight = uint64(0)
	case "band.tss.v1beta1.Group.module_owner":
		x.ModuleOwner = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Group"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Group does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_Group) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "band.tss.v1beta1.Group.id":
		value := x.Id
		return protoreflect.ValueOfUint64(value)
	case "band.tss.v1beta1.Group.size":
		value := x.Size
		return protoreflect.ValueOfUint64(value)
	case "band.tss.v1beta1.Group.threshold":
		value := x.Threshold
		return protoreflect.ValueOfUint64(value)
	case "band.tss.v1beta1.Group.pub_key":
		value := x.PubKey
		return protoreflect.ValueOfBytes(value)
	case "band.tss.v1beta1.Group.status":
		value := x.Status
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	case "band.tss.v1beta1.Group.created_height":
		value := x.CreatedHeight
		return protoreflect.ValueOfUint64(value)
	case "band.tss.v1beta1.Group.module_owner":
		value := x.ModuleOwner
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Group"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Group does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Group) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "band.tss.v1beta1.Group.id":
		x.Id = value.Uint()
	case "band.tss.v1beta1.Group.size":
		x.Size = value.Uint()
	case "band.tss.v1beta1.Group.threshold":
		x.Threshold = value.Uint()
	case "band.tss.v1beta1.Group.pub_key":
		x.PubKey = value.Bytes()
	case "band.tss.v1beta1.Group.status":
		x.Status = (GroupStatus)(value.Enum())
	case "band.tss.v1beta1.Group.created_height":
		x.CreatedHeight = value.Uint()
	case "band.tss.v1beta1.Group.module_owner":
		x.ModuleOwner = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Group"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Group does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Group) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.Group.id":
		panic(fmt.Errorf("field id of message band.tss.v1beta1.Group is not mutable"))
	case "band.tss.v1beta1.Group.size":
		panic(fmt.Errorf("field size of message band.tss.v1beta1.Group is not mutable"))
	case "band.tss.v1beta1.Group.threshold":
		panic(fmt.Errorf("field threshold of message band.tss.v1beta1.Group is not mutable"))
	case "band.tss.v1beta1.Group.pub_key":
		panic(fmt.Errorf("field pub_key of message band.tss.v1beta1.Group is not mutable"))
	case "band.tss.v1beta1.Group.status":
		panic(fmt.Errorf("field status of message band.tss.v1beta1.Group is not mutable"))
	case "band.tss.v1beta1.Group.created_height":
		panic(fmt.Errorf("field created_height of message band.tss.v1beta1.Group is not mutable"))
	case "band.tss.v1beta1.Group.module_owner":
		panic(fmt.Errorf("field module_owner of message band.tss.v1beta1.Group is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Group"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Group does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_Group) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.Group.id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "band.tss.v1beta1.Group.size":
		return protoreflect.ValueOfUint64(uint64(0))
	case "band.tss.v1beta1.Group.threshold":
		return protoreflect.ValueOfUint64(uint64(0))
	case "band.tss.v1beta1.Group.pub_key":
		return protoreflect.ValueOfBytes(nil)
	case "band.tss.v1beta1.Group.status":
		return protoreflect.ValueOfEnum(0)
	case "band.tss.v1beta1.Group.created_height":
		return protoreflect.ValueOfUint64(uint64(0))
	case "band.tss.v1beta1.Group.module_owner":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Group"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Group does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_Group) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in band.tss.v1beta1.Group", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_Group) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Group) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_Group) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_Group) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*Group)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Id != 0 {
			n += 1 + runtime.Sov(uint64(x.Id))
		}
		if x.Size != 0 {
			n += 1 + runtime.Sov(uint64(x.Size))
		}
		if x.Threshold != 0 {
			n += 1 + runtime.Sov(uint64(x.Threshold))
		}
		l = len(x.PubKey)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Status != 0 {
			n += 1 + runtime.Sov(uint64(x.Status))
		}
		if x.CreatedHeight != 0 {
			n += 1 + runtime.Sov(uint64(x.CreatedHeight))
		}
		l = len(x.ModuleOwner)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*Group)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.ModuleOwner) > 0 {
			i -= len(x.ModuleOwner)
			copy(dAtA[i:], x.ModuleOwner)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ModuleOwner)))
			i--
			dAtA[i] = 0x3a
		}
		if x.CreatedHeight != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.CreatedHeight))
			i--
			dAtA[i] = 0x30
		}
		if x.Status != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Status))
			i--
			dAtA[i] = 0x28
		}
		if len(x.PubKey) > 0 {
			i -= len(x.PubKey)
			copy(dAtA[i:], x.PubKey)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PubKey)))
			i--
			dAtA[i] = 0x22
		}
		if x.Threshold != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Threshold))
			i--
			dAtA[i] = 0x18
		}
		if x.Size != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Size))
			i--
			dAtA[i] = 0x10
		}
		if x.Id != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Id))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*Group)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Group: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
				}
				x.Id = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Id |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Size", wireType)
				}
				x.Size = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Size |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
				}
				x.Threshold = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Threshold |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PubKey = append(x.PubKey[:0], dAtA[iNdEx:postIndex]...)
				if x.PubKey == nil {
					x.PubKey = []byte{}
				}
				iNdEx = postIndex
			case 5:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
				}
				x.Status = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Status |= GroupStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 6:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CreatedHeight", wireType)
				}
				x.CreatedHeight = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.CreatedHeight |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ModuleOwner", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ModuleOwner = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_GroupResult_3_list)(nil)

type _GroupResult_3_list struct {
	list *[]*Member
}

func (x *_GroupResult_3_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_GroupResult_3_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_GroupResult_3_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Member)
	(*x.list)[i] = concreteValue
}

func (x *_GroupResult_3_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Member)
	*x.list = append(*x.list, concreteValue)
}

func (x *_GroupResult_3_list) AppendMutable() protoreflect.Value {
	v := new(Member)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_GroupResult_3_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_GroupResult_3_list) NewElement() protoreflect.Value {
	v := new(Member)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_GroupResult_3_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_GroupResult_4_list)(nil)

type _GroupResult_4_list struct {
	list *[]*Round1Info
}

func (x *_GroupResult_4_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_GroupResult_4_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_GroupResult_4_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Round1Info)
	(*x.list)[i] = concreteValue
}

func (x *_GroupResult_4_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Round1Info)
	*x.list = append(*x.list, concreteValue)
}

func (x *_GroupResult_4_list) AppendMutable() protoreflect.Value {
	v := new(Round1Info)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_GroupResult_4_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_GroupResult_4_list) NewElement() protoreflect.Value {
	v := new(Round1Info)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_GroupResult_4_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_GroupResult_5_list)(nil)

type _GroupResult_5_list struct {
	list *[]*Round2Info
}

func (x *_GroupResult_5_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_GroupResult_5_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_GroupResult_5_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Round2Info)
	(*x.list)[i] = concreteValue
}

func (x *_GroupResult_5_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Round2Info)
	*x.list = append(*x.list, concreteValue)
}

func (x *_GroupResult_5_list) AppendMutable() protoreflect.Value {
	v := new(Round2Info)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_GroupResult_5_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_GroupResult_5_list) NewElement() protoreflect.Value {
	v := new(Round2Info)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_GroupResult_5_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_GroupResult_6_list)(nil)

type _GroupResult_6_list struct {
	list *[]*ComplaintsWithStatus
}

func (x *_GroupResult_6_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_GroupResult_6_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_GroupResult_6_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*ComplaintsWithStatus)
	(*x.list)[i] = concreteValue
}

func (x *_GroupResult_6_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*ComplaintsWithStatus)
	*x.list = append(*x.list, concreteValue)
}

func (x *_GroupResult_6_list) AppendMutable() protoreflect.Value {
	v := new(ComplaintsWithStatus)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_GroupResult_6_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_GroupResult_6_list) NewElement() protoreflect.Value {
	v := new(ComplaintsWithStatus)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_GroupResult_6_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_GroupResult_7_list)(nil)

type _GroupResult_7_list struct {
	list *[]*Confirm
}

func (x *_GroupResult_7_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_GroupResult_7_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_GroupResult_7_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Confirm)
	(*x.list)[i] = concreteValue
}

func (x *_GroupResult_7_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Confirm)
	*x.list = append(*x.list, concreteValue)
}

func (x *_GroupResult_7_list) AppendMutable() protoreflect.Value {
	v := new(Confirm)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_GroupResult_7_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_GroupResult_7_list) NewElement() protoreflect.Value {
	v := new(Confirm)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_GroupResult_7_list) IsValid() bool {
	return x.list != nil
}

var (
	md_GroupResult                        protoreflect.MessageDescriptor
	fd_GroupResult_group                  protoreflect.FieldDescriptor
	fd_GroupResult_dkg_context            protoreflect.FieldDescriptor
	fd_GroupResult_members                protoreflect.FieldDescriptor
	fd_GroupResult_round1_infos           protoreflect.FieldDescriptor
	fd_GroupResult_round2_infos           protoreflect.FieldDescriptor
	fd_GroupResult_complaints_with_status protoreflect.FieldDescriptor
	fd_GroupResult_confirms               protoreflect.FieldDescriptor
)

func init() {
	file_band_tss_v1beta1_tss_proto_init()
	md_GroupResult = File_band_tss_v1beta1_tss_proto.Messages().ByName("GroupResult")
	fd_GroupResult_group = md_GroupResult.Fields().ByName("group")
	fd_GroupResult_dkg_context = md_GroupResult.Fields().ByName("dkg_context")
	fd_GroupResult_members = md_GroupResult.Fields().ByName("members")
	fd_GroupResult_round1_infos = md_GroupResult.Fields().ByName("round1_infos")
	fd_GroupResult_round2_infos = md_GroupResult.Fields().ByName("round2_infos")
	fd_GroupResult_complaints_with_status = md_GroupResult.Fields().ByName("complaints_with_status")
	fd_GroupResult_confirms = md_GroupResult.Fields().ByName("confirms")
}

var _ protoreflect.Message = (*fastReflection_GroupResult)(nil)

type fastReflection_GroupResult GroupResult

func (x *GroupResult) ProtoReflect() protoreflect.Message {
	return (*fastReflection_GroupResult)(x)
}

func (x *GroupResult) slowProtoReflect() protoreflect.Message {
	mi := &file_band_tss_v1beta1_tss_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_GroupResult_messageType fastReflection_GroupResult_messageType
var _ protoreflect.MessageType = fastReflection_GroupResult_messageType{}

type fastReflection_GroupResult_messageType struct{}

func (x fastReflection_GroupResult_messageType) Zero() protoreflect.Message {
	return (*fastReflection_GroupResult)(nil)
}
func (x fastReflection_GroupResult_messageType) New() protoreflect.Message {
	return new(fastReflection_GroupResult)
}
func (x fastReflection_GroupResult_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_GroupResult
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_GroupResult) Descriptor() protoreflect.MessageDescriptor {
	return md_GroupResult
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_GroupResult) Type() protoreflect.MessageType {
	return _fastReflection_GroupResult_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_GroupResult) New() protoreflect.Message {
	return new(fastReflection_GroupResult)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_GroupResult) Interface() protoreflect.ProtoMessage {
	return (*GroupResult)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_GroupResult) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Group != nil {
		value := protoreflect.ValueOfMessage(x.Group.ProtoReflect())
		if !f(fd_GroupResult_group, value) {
			return
		}
	}
	if len(x.DkgContext) != 0 {
		value := protoreflect.ValueOfBytes(x.DkgContext)
		if !f(fd_GroupResult_dkg_context, value) {
			return
		}
	}
	if len(x.Members) != 0 {
		value := protoreflect.ValueOfList(&_GroupResult_3_list{list: &x.Members})
		if !f(fd_GroupResult_members, value) {
			return
		}
	}
	if len(x.Round1Infos) != 0 {
		value := protoreflect.ValueOfList(&_GroupResult_4_list{list: &x.Round1Infos})
		if !f(fd_GroupResult_round1_infos, value) {
			return
		}
	}
	if len(x.Round2Infos) != 0 {
		value := protoreflect.ValueOfList(&_GroupResult_5_list{list: &x.Round2Infos})
		if !f(fd_GroupResult_round2_infos, value) {
			return
		}
	}
	if len(x.ComplaintsWithStatus) != 0 {
		value := protoreflect.ValueOfList(&_GroupResult_6_list{list: &x.ComplaintsWithStatus})
		if !f(fd_GroupResult_complaints_with_status, value) {
			return
		}
	}
	if len(x.Confirms) != 0 {
		value := protoreflect.ValueOfList(&_GroupResult_7_list{list: &x.Confirms})
		if !f(fd_GroupResult_confirms, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_GroupResult) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "band.tss.v1beta1.GroupResult.group":
		return x.Group != nil
	case "band.tss.v1beta1.GroupResult.dkg_context":
		return len(x.DkgContext) != 0
	case "band.tss.v1beta1.GroupResult.members":
		return len(x.Members) != 0
	case "band.tss.v1beta1.GroupResult.round1_infos":
		return len(x.Round1Infos) != 0
	case "band.tss.v1beta1.GroupResult.round2_infos":
		return len(x.Round2Infos) != 0
	case "band.tss.v1beta1.GroupResult.complaints_with_status":
		return len(x.ComplaintsWithStatus) != 0
	case "band.tss.v1beta1.GroupResult.confirms":
		return len(x.Confirms) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.GroupResult"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.GroupResult does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_GroupResult) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "band.tss.v1beta1.GroupResult.group":
		x.Group = nil
	case "band.tss.v1beta1.GroupResult.dkg_context":
		x.DkgContext = nil
	case "band.tss.v1beta1.GroupResult.members":
		x.Members = nil
	case "band.tss.v1beta1.GroupResult.round1_infos":
		x.Round1Infos = nil
	case "band.tss.v1beta1.GroupResult.round2_infos":
		x.Round2Infos = nil
	case "band.tss.v1beta1.GroupResult.complaints_with_status":
		x.ComplaintsWithStatus = nil
	case "band.tss.v1beta1.GroupResult.confirms":
		x.Confirms = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.GroupResult"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.GroupResult does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_GroupResult) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "band.tss.v1beta1.GroupResult.group":
		value := x.Group
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "band.tss.v1beta1.GroupResult.dkg_context":
		value := x.DkgContext
		return protoreflect.ValueOfBytes(value)
	case "band.tss.v1beta1.GroupResult.members":
		if len(x.Members) == 0 {
			return protoreflect.ValueOfList(&_GroupResult_3_list{})
		}
		listValue := &_GroupResult_3_list{list: &x.Members}
		return protoreflect.ValueOfList(listValue)
	case "band.tss.v1beta1.GroupResult.round1_infos":
		if len(x.Round1Infos) == 0 {
			return protoreflect.ValueOfList(&_GroupResult_4_list{})
		}
		listValue := &_GroupResult_4_list{list: &x.Round1Infos}
		return protoreflect.ValueOfList(listValue)
	case "band.tss.v1beta1.GroupResult.round2_infos":
		if len(x.Round2Infos) == 0 {
			return protoreflect.ValueOfList(&_GroupResult_5_list{})
		}
		listValue := &_GroupResult_5_list{list: &x.Round2Infos}
		return protoreflect.ValueOfList(listValue)
	case "band.tss.v1beta1.GroupResult.complaints_with_status":
		if len(x.ComplaintsWithStatus) == 0 {
			return protoreflect.ValueOfList(&_GroupResult_6_list{})
		}
		listValue := &_GroupResult_6_list{list: &x.ComplaintsWithStatus}
		return protoreflect.ValueOfList(listValue)
	case "band.tss.v1beta1.GroupResult.confirms":
		if len(x.Confirms) == 0 {
			return protoreflect.ValueOfList(&_GroupResult_7_list{})
		}
		listValue := &_GroupResult_7_list{list: &x.Confirms}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.GroupResult"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.GroupResult does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_GroupResult) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "band.tss.v1beta1.GroupResult.group":
		x.Group = value.Message().Interface().(*Group)
	case "band.tss.v1beta1.GroupResult.dkg_context":
		x.DkgContext = value.Bytes()
	case "band.tss.v1beta1.GroupResult.members":
		lv := value.List()
		clv := lv.(*_GroupResult_3_list)
		x.Members = *clv.list
	case "band.tss.v1beta1.GroupResult.round1_infos":
		lv := value.List()
		clv := lv.(*_GroupResult_4_list)
		x.Round1Infos = *clv.list
	case "band.tss.v1beta1.GroupResult.round2_infos":
		lv := value.List()
		clv := lv.(*_GroupResult_5_list)
		x.Round2Infos = *clv.list
	case "band.tss.v1beta1.GroupResult.complaints_with_status":
		lv := value.List()
		clv := lv.(*_GroupResult_6_list)
		x.ComplaintsWithStatus = *clv.list
	case "band.tss.v1beta1.GroupResult.confirms":
		lv := value.List()
		clv := lv.(*_GroupResult_7_list)
		x.Confirms = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.GroupResult"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.GroupResult does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_GroupResult) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.GroupResult.group":
		if x.Group == nil {
			x.Group = new(Group)
		}
		return protoreflect.ValueOfMessage(x.Group.ProtoReflect())
	case "band.tss.v1beta1.GroupResult.members":
		if x.Members == nil {
			x.Members = []*Member{}
		}
		value := &_GroupResult_3_list{list: &x.Members}
		return protoreflect.ValueOfList(value)
	case "band.tss.v1beta1.GroupResult.round1_infos":
		if x.Round1Infos == nil {
			x.Round1Infos = []*Round1Info{}
		}
		value := &_GroupResult_4_list{list: &x.Round1Infos}
		return protoreflect.ValueOfList(value)
	case "band.tss.v1beta1.GroupResult.round2_infos":
		if x.Round2Infos == nil {
			x.Round2Infos = []*Round2Info{}
		}
		value := &_GroupResult_5_list{list: &x.Round2Infos}
		return protoreflect.ValueOfList(value)
	case "band.tss.v1beta1.GroupResult.complaints_with_status":
		if x.ComplaintsWithStatus == nil {
			x.ComplaintsWithStatus = []*ComplaintsWithStatus{}
		}
		value := &_GroupResult_6_list{list: &x.ComplaintsWithStatus}
		return protoreflect.ValueOfList(value)
	case "band.tss.v1beta1.GroupResult.confirms":
		if x.Confirms == nil {
			x.Confirms = []*Confirm{}
		}
		value := &_GroupResult_7_list{list: &x.Confirms}
		return protoreflect.ValueOfList(value)
	case "band.tss.v1beta1.GroupResult.dkg_context":
		panic(fmt.Errorf("field dkg_context of message band.tss.v1beta1.GroupResult is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.GroupResult"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.GroupResult does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_GroupResult) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.GroupResult.group":
		m := new(Group)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "band.tss.v1beta1.GroupResult.dkg_context":
		return protoreflect.ValueOfBytes(nil)
	case "band.tss.v1beta1.GroupResult.members":
		list := []*Member{}
		return protoreflect.ValueOfList(&_GroupResult_3_list{list: &list})
	case "band.tss.v1beta1.GroupResult.round1_infos":
		list := []*Round1Info{}
		return protoreflect.ValueOfList(&_GroupResult_4_list{list: &list})
	case "band.tss.v1beta1.GroupResult.round2_infos":
		list := []*Round2Info{}
		return protoreflect.ValueOfList(&_GroupResult_5_list{list: &list})
	case "band.tss.v1beta1.GroupResult.complaints_with_status":
		list := []*ComplaintsWithStatus{}
		return protoreflect.ValueOfList(&_GroupResult_6_list{list: &list})
	case "band.tss.v1beta1.GroupResult.confirms":
		list := []*Confirm{}
		return protoreflect.ValueOfList(&_GroupResult_7_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.GroupResult"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.GroupResult does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_GroupResult) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in band.tss.v1beta1.GroupResult", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_GroupResult) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_GroupResult) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_GroupResult) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_GroupResult) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*GroupResult)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Group != nil {
			l = options.Size(x.Group)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.DkgContext)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.Members) > 0 {
			for _, e := range x.Members {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.Round1Infos) > 0 {
			for _, e := range x.Round1Infos {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.Round2Infos) > 0 {
			for _, e := range x.Round2Infos {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.ComplaintsWithStatus) > 0 {
			for _, e := range x.ComplaintsWithStatus {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.Confirms) > 0 {
			for _, e := range x.Confirms {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*GroupResult)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Confirms) > 0 {
			for iNdEx := len(x.Confirms) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Confirms[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x3a
			}
		}
		if len(x.ComplaintsWithStatus) > 0 {
			for iNdEx := len(x.ComplaintsWithStatus) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.ComplaintsWithStatus[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x32
			}
		}
		if len(x.Round2Infos) > 0 {
			for iNdEx := len(x.Round2Infos) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Round2Infos[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x2a
			}
		}
		if len(x.Round1Infos) > 0 {
			for iNdEx := len(x.Round1Infos) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Round1Infos[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x22
			}
		}
		if len(x.Members) > 0 {
			for iNdEx := len(x.Members) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Members[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x1a
			}
		}
		if len(x.DkgContext) > 0 {
			i -= len(x.DkgContext)
			copy(dAtA[i:], x.DkgContext)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.DkgContext)))
			i--
			dAtA[i] = 0x12
		}
		if x.Group != nil {
			encoded, err := options.Marshal(x.Group)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*GroupResult)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: GroupResult: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: GroupResult: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Group == nil {
					x.Group = &Group{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Group); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DkgContext", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.DkgContext = append(x.DkgContext[:0], dAtA[iNdEx:postIndex]...)
				if x.DkgContext == nil {
					x.DkgContext = []byte{}
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Members = append(x.Members, &Member{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Members[len(x.Members)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Round1Infos", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Round1Infos = append(x.Round1Infos, &Round1Info{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Round1Infos[len(x.Round1Infos)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Round2Infos", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Round2Infos = append(x.Round2Infos, &Round2Info{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Round2Infos[len(x.Round2Infos)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ComplaintsWithStatus", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ComplaintsWithStatus = append(x.ComplaintsWithStatus, &ComplaintsWithStatus{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ComplaintsWithStatus[len(x.ComplaintsWithStatus)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Confirms", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Confirms = append(x.Confirms, &Confirm{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Confirms[len(x.Confirms)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_Round1Info_2_list)(nil)

type _Round1Info_2_list struct {
	list *[][]byte
}

func (x *_Round1Info_2_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_Round1Info_2_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfBytes((*x.list)[i])
}

func (x *_Round1Info_2_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Bytes()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_Round1Info_2_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Bytes()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_Round1Info_2_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message Round1Info at list field CoefficientCommits as it is not of Message kind"))
}

func (x *_Round1Info_2_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_Round1Info_2_list) NewElement() protoreflect.Value {
	var v []byte
	return protoreflect.ValueOfBytes(v)
}

func (x *_Round1Info_2_list) IsValid() bool {
	return x.list != nil
}

var (
	md_Round1Info                     protoreflect.MessageDescriptor
	fd_Round1Info_member_id           protoreflect.FieldDescriptor
	fd_Round1Info_coefficient_commits protoreflect.FieldDescriptor
	fd_Round1Info_one_time_pub_key    protoreflect.FieldDescriptor
	fd_Round1Info_a0_signature        protoreflect.FieldDescriptor
	fd_Round1Info_one_time_signature  protoreflect.FieldDescriptor
)

func init() {
	file_band_tss_v1beta1_tss_proto_init()
	md_Round1Info = File_band_tss_v1beta1_tss_proto.Messages().ByName("Round1Info")
	fd_Round1Info_member_id = md_Round1Info.Fields().ByName("member_id")
	fd_Round1Info_coefficient_commits = md_Round1Info.Fields().ByName("coefficient_commits")
	fd_Round1Info_one_time_pub_key = md_Round1Info.Fields().ByName("one_time_pub_key")
	fd_Round1Info_a0_signature = md_Round1Info.Fields().ByName("a0_signature")
	fd_Round1Info_one_time_signature = md_Round1Info.Fields().ByName("one_time_signature")
}

var _ protoreflect.Message = (*fastReflection_Round1Info)(nil)

type fastReflection_Round1Info Round1Info

func (x *Round1Info) ProtoReflect() protoreflect.Message {
	return (*fastReflection_Round1Info)(x)
}

func (x *Round1Info) slowProtoReflect() protoreflect.Message {
	mi := &file_band_tss_v1beta1_tss_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_Round1Info_messageType fastReflection_Round1Info_messageType
var _ protoreflect.MessageType = fastReflection_Round1Info_messageType{}

type fastReflection_Round1Info_messageType struct{}

func (x fastReflection_Round1Info_messageType) Zero() protoreflect.Message {
	return (*fastReflection_Round1Info)(nil)
}
func (x fastReflection_Round1Info_messageType) New() protoreflect.Message {
	return new(fastReflection_Round1Info)
}
func (x fastReflection_Round1Info_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_Round1Info
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_Round1Info) Descriptor() protoreflect.MessageDescriptor {
	return md_Round1Info
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_Round1Info) Type() protoreflect.MessageType {
	return _fastReflection_Round1Info_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_Round1Info) New() protoreflect.Message {
	return new(fastReflection_Round1Info)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_Round1Info) Interface() protoreflect.ProtoMessage {
	return (*Round1Info)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_Round1Info) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.MemberId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.MemberId)
		if !f(fd_Round1Info_member_id, value) {
			return
		}
	}
	if len(x.CoefficientCommits) != 0 {
		value := protoreflect.ValueOfList(&_Round1Info_2_list{list: &x.CoefficientCommits})
		if !f(fd_Round1Info_coefficient_commits, value) {
			return
		}
	}
	if len(x.OneTimePubKey) != 0 {
		value := protoreflect.ValueOfBytes(x.OneTimePubKey)
		if !f(fd_Round1Info_one_time_pub_key, value) {
			return
		}
	}
	if len(x.A0Signature) != 0 {
		value := protoreflect.ValueOfBytes(x.A0Signature)
		if !f(fd_Round1Info_a0_signature, value) {
			return
		}
	}
	if len(x.OneTimeSignature) != 0 {
		value := protoreflect.ValueOfBytes(x.OneTimeSignature)
		if !f(fd_Round1Info_one_time_signature, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_Round1Info) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "band.tss.v1beta1.Round1Info.member_id":
		return x.MemberId != uint64(0)
	case "band.tss.v1beta1.Round1Info.coefficient_commits":
		return len(x.CoefficientCommits) != 0
	case "band.tss.v1beta1.Round1Info.one_time_pub_key":
		return len(x.OneTimePubKey) != 0
	case "band.tss.v1beta1.Round1Info.a0_signature":
		return len(x.A0Signature) != 0
	case "band.tss.v1beta1.Round1Info.one_time_signature":
		return len(x.OneTimeSignature) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Round1Info"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Round1Info does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Round1Info) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "band.tss.v1beta1.Round1Info.member_id":
		x.MemberId = uint64(0)
	case "band.tss.v1beta1.Round1Info.coefficient_commits":
		x.CoefficientCommits = nil
	case "band.tss.v1beta1.Round1Info.one_time_pub_key":
		x.OneTimePubKey = nil
	case "band.tss.v1beta1.Round1Info.a0_signature":
		x.A0Signature = nil
	case "band.tss.v1beta1.Round1Info.one_time_signature":
		x.OneTimeSignature = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Round1Info"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Round1Info does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_Round1Info) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "band.tss.v1beta1.Round1Info.member_id":
		value := x.MemberId
		return protoreflect.ValueOfUint64(value)
	case "band.tss.v1beta1.Round1Info.coefficient_commits":
		if len(x.CoefficientCommits) == 0 {
			return protoreflect.ValueOfList(&_Round1Info_2_list{})
		}
		listValue := &_Round1Info_2_list{list: &x.CoefficientCommits}
		return protoreflect.ValueOfList(listValue)
	case "band.tss.v1beta1.Round1Info.one_time_pub_key":
		value := x.OneTimePubKey
		return protoreflect.ValueOfBytes(value)
	case "band.tss.v1beta1.Round1Info.a0_signature":
		value := x.A0Signature
		return protoreflect.ValueOfBytes(value)
	case "band.tss.v1beta1.Round1Info.one_time_signature":
		value := x.OneTimeSignature
		return protoreflect.ValueOfBytes(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Round1Info"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Round1Info does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Round1Info) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "band.tss.v1beta1.Round1Info.member_id":
		x.MemberId = value.Uint()
	case "band.tss.v1beta1.Round1Info.coefficient_commits":
		lv := value.List()
		clv := lv.(*_Round1Info_2_list)
		x.CoefficientCommits = *clv.list
	case "band.tss.v1beta1.Round1Info.one_time_pub_key":
		x.OneTimePubKey = value.Bytes()
	case "band.tss.v1beta1.Round1Info.a0_signature":
		x.A0Signature = value.Bytes()
	case "band.tss.v1beta1.Round1Info.one_time_signature":
		x.OneTimeSignature = value.Bytes()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Round1Info"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Round1Info does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Round1Info) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.Round1Info.coefficient_commits":
		if x.CoefficientCommits == nil {
			x.CoefficientCommits = [][]byte{}
		}
		value := &_Round1Info_2_list{list: &x.CoefficientCommits}
		return protoreflect.ValueOfList(value)
	case "band.tss.v1beta1.Round1Info.member_id":
		panic(fmt.Errorf("field member_id of message band.tss.v1beta1.Round1Info is not mutable"))
	case "band.tss.v1beta1.Round1Info.one_time_pub_key":
		panic(fmt.Errorf("field one_time_pub_key of message band.tss.v1beta1.Round1Info is not mutable"))
	case "band.tss.v1beta1.Round1Info.a0_signature":
		panic(fmt.Errorf("field a0_signature of message band.tss.v1beta1.Round1Info is not mutable"))
	case "band.tss.v1beta1.Round1Info.one_time_signature":
		panic(fmt.Errorf("field one_time_signature of message band.tss.v1beta1.Round1Info is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Round1Info"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Round1Info does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_Round1Info) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.Round1Info.member_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "band.tss.v1beta1.Round1Info.coefficient_commits":
		list := [][]byte{}
		return protoreflect.ValueOfList(&_Round1Info_2_list{list: &list})
	case "band.tss.v1beta1.Round1Info.one_time_pub_key":
		return protoreflect.ValueOfBytes(nil)
	case "band.tss.v1beta1.Round1Info.a0_signature":
		return protoreflect.ValueOfBytes(nil)
	case "band.tss.v1beta1.Round1Info.one_time_signature":
		return protoreflect.ValueOfBytes(nil)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Round1Info"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Round1Info does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_Round1Info) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in band.tss.v1beta1.Round1Info", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_Round1Info) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Round1Info) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_Round1Info) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_Round1Info) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*Round1Info)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.MemberId != 0 {
			n += 1 + runtime.Sov(uint64(x.MemberId))
		}
		if len(x.CoefficientCommits) > 0 {
			for _, b := range x.CoefficientCommits {
				l = len(b)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		l = len(x.OneTimePubKey)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.A0Signature)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.OneTimeSignature)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*Round1Info)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.OneTimeSignature) > 0 {
			i -= len(x.OneTimeSignature)
			copy(dAtA[i:], x.OneTimeSignature)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.OneTimeSignature)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.A0Signature) > 0 {
			i -= len(x.A0Signature)
			copy(dAtA[i:], x.A0Signature)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.A0Signature)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.OneTimePubKey) > 0 {
			i -= len(x.OneTimePubKey)
			copy(dAtA[i:], x.OneTimePubKey)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.OneTimePubKey)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.CoefficientCommits) > 0 {
			for iNdEx := len(x.CoefficientCommits) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.CoefficientCommits[iNdEx])
				copy(dAtA[i:], x.CoefficientCommits[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CoefficientCommits[iNdEx])))
				i--
				dAtA[i] = 0x12
			}
		}
		if x.MemberId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MemberId))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*Round1Info)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Round1Info: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Round1Info: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MemberId", wireType)
				}
				x.MemberId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MemberId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CoefficientCommits", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CoefficientCommits = append(x.CoefficientCommits, make([]byte, postIndex-iNdEx))
				copy(x.CoefficientCommits[len(x.CoefficientCommits)-1], dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OneTimePubKey", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.OneTimePubKey = append(x.OneTimePubKey[:0], dAtA[iNdEx:postIndex]...)
				if x.OneTimePubKey == nil {
					x.OneTimePubKey = []byte{}
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field A0Signature", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.A0Signature = append(x.A0Signature[:0], dAtA[iNdEx:postIndex]...)
				if x.A0Signature == nil {
					x.A0Signature = []byte{}
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OneTimeSignature", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.OneTimeSignature = append(x.OneTimeSignature[:0], dAtA[iNdEx:postIndex]...)
				if x.OneTimeSignature == nil {
					x.OneTimeSignature = []byte{}
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_Round2Info_2_list)(nil)

type _Round2Info_2_list struct {
	list *[][]byte
}

func (x *_Round2Info_2_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_Round2Info_2_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfBytes((*x.list)[i])
}

func (x *_Round2Info_2_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Bytes()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_Round2Info_2_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Bytes()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_Round2Info_2_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message Round2Info at list field EncryptedSecretShares as it is not of Message kind"))
}

func (x *_Round2Info_2_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_Round2Info_2_list) NewElement() protoreflect.Value {
	var v []byte
	return protoreflect.ValueOfBytes(v)
}

func (x *_Round2Info_2_list) IsValid() bool {
	return x.list != nil
}

var (
	md_Round2Info                         protoreflect.MessageDescriptor
	fd_Round2Info_member_id               protoreflect.FieldDescriptor
	fd_Round2Info_encrypted_secret_shares protoreflect.FieldDescriptor
)

func init() {
	file_band_tss_v1beta1_tss_proto_init()
	md_Round2Info = File_band_tss_v1beta1_tss_proto.Messages().ByName("Round2Info")
	fd_Round2Info_member_id = md_Round2Info.Fields().ByName("member_id")
	fd_Round2Info_encrypted_secret_shares = md_Round2Info.Fields().ByName("encrypted_secret_shares")
}

var _ protoreflect.Message = (*fastReflection_Round2Info)(nil)

type fastReflection_Round2Info Round2Info

func (x *Round2Info) ProtoReflect() protoreflect.Message {
	return (*fastReflection_Round2Info)(x)
}

func (x *Round2Info) slowProtoReflect() protoreflect.Message {
	mi := &file_band_tss_v1beta1_tss_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_Round2Info_messageType fastReflection_Round2Info_messageType
var _ protoreflect.MessageType = fastReflection_Round2Info_messageType{}

type fastReflection_Round2Info_messageType struct{}

func (x fastReflection_Round2Info_messageType) Zero() protoreflect.Message {
	return (*fastReflection_Round2Info)(nil)
}
func (x fastReflection_Round2Info_messageType) New() protoreflect.Message {
	return new(fastReflection_Round2Info)
}
func (x fastReflection_Round2Info_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_Round2Info
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_Round2Info) Descriptor() protoreflect.MessageDescriptor {
	return md_Round2Info
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_Round2Info) Type() protoreflect.MessageType {
	return _fastReflection_Round2Info_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_Round2Info) New() protoreflect.Message {
	return new(fastReflection_Round2Info)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_Round2Info) Interface() protoreflect.ProtoMessage {
	return (*Round2Info)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_Round2Info) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.MemberId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.MemberId)
		if !f(fd_Round2Info_member_id, value) {
			return
		}
	}
	if len(x.EncryptedSecretShares) != 0 {
		value := protoreflect.ValueOfList(&_Round2Info_2_list{list: &x.EncryptedSecretShares})
		if !f(fd_Round2Info_encrypted_secret_shares, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_Round2Info) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "band.tss.v1beta1.Round2Info.member_id":
		return x.MemberId != uint64(0)
	case "band.tss.v1beta1.Round2Info.encrypted_secret_shares":
		return len(x.EncryptedSecretShares) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Round2Info"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Round2Info does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Round2Info) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "band.tss.v1beta1.Round2Info.member_id":
		x.MemberId = uint64(0)
	case "band.tss.v1beta1.Round2Info.encrypted_secret_shares":
		x.EncryptedSecretShares = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Round2Info"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Round2Info does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_Round2Info) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "band.tss.v1beta1.Round2Info.member_id":
		value := x.MemberId
		return protoreflect.ValueOfUint64(value)
	case "band.tss.v1beta1.Round2Info.encrypted_secret_shares":
		if len(x.EncryptedSecretShares) == 0 {
			return protoreflect.ValueOfList(&_Round2Info_2_list{})
		}
		listValue := &_Round2Info_2_list{list: &x.EncryptedSecretShares}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Round2Info"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Round2Info does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Round2Info) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "band.tss.v1beta1.Round2Info.member_id":
		x.MemberId = value.Uint()
	case "band.tss.v1beta1.Round2Info.encrypted_secret_shares":
		lv := value.List()
		clv := lv.(*_Round2Info_2_list)
		x.EncryptedSecretShares = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Round2Info"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Round2Info does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Round2Info) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.Round2Info.encrypted_secret_shares":
		if x.EncryptedSecretShares == nil {
			x.EncryptedSecretShares = [][]byte{}
		}
		value := &_Round2Info_2_list{list: &x.EncryptedSecretShares}
		return protoreflect.ValueOfList(value)
	case "band.tss.v1beta1.Round2Info.member_id":
		panic(fmt.Errorf("field member_id of message band.tss.v1beta1.Round2Info is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Round2Info"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Round2Info does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_Round2Info) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.Round2Info.member_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "band.tss.v1beta1.Round2Info.encrypted_secret_shares":
		list := [][]byte{}
		return protoreflect.ValueOfList(&_Round2Info_2_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Round2Info"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Round2Info does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_Round2Info) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in band.tss.v1beta1.Round2Info", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_Round2Info) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Round2Info) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_Round2Info) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_Round2Info) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*Round2Info)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.MemberId != 0 {
			n += 1 + runtime.Sov(uint64(x.MemberId))
		}
		if len(x.EncryptedSecretShares) > 0 {
			for _, b := range x.EncryptedSecretShares {
				l = len(b)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*Round2Info)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.EncryptedSecretShares) > 0 {
			for iNdEx := len(x.EncryptedSecretShares) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.EncryptedSecretShares[iNdEx])
				copy(dAtA[i:], x.EncryptedSecretShares[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.EncryptedSecretShares[iNdEx])))
				i--
				dAtA[i] = 0x12
			}
		}
		if x.MemberId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MemberId))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*Round2Info)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Round2Info: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Round2Info: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MemberId", wireType)
				}
				x.MemberId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MemberId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field EncryptedSecretShares", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.EncryptedSecretShares = append(x.EncryptedSecretShares, make([]byte, postIndex-iNdEx))
				copy(x.EncryptedSecretShares[len(x.EncryptedSecretShares)-1], dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_DE       protoreflect.MessageDescriptor
	fd_DE_pub_d protoreflect.FieldDescriptor
	fd_DE_pub_e protoreflect.FieldDescriptor
)

func init() {
	file_band_tss_v1beta1_tss_proto_init()
	md_DE = File_band_tss_v1beta1_tss_proto.Messages().ByName("DE")
	fd_DE_pub_d = md_DE.Fields().ByName("pub_d")
	fd_DE_pub_e = md_DE.Fields().ByName("pub_e")
}

var _ protoreflect.Message = (*fastReflection_DE)(nil)

type fastReflection_DE DE

func (x *DE) ProtoReflect() protoreflect.Message {
	return (*fastReflection_DE)(x)
}

func (x *DE) slowProtoReflect() protoreflect.Message {
	mi := &file_band_tss_v1beta1_tss_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_DE_messageType fastReflection_DE_messageType
var _ protoreflect.MessageType = fastReflection_DE_messageType{}

type fastReflection_DE_messageType struct{}

func (x fastReflection_DE_messageType) Zero() protoreflect.Message {
	return (*fastReflection_DE)(nil)
}
func (x fastReflection_DE_messageType) New() protoreflect.Message {
	return new(fastReflection_DE)
}
func (x fastReflection_DE_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_DE
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_DE) Descriptor() protoreflect.MessageDescriptor {
	return md_DE
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_DE) Type() protoreflect.MessageType {
	return _fastReflection_DE_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_DE) New() protoreflect.Message {
	return new(fastReflection_DE)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_DE) Interface() protoreflect.ProtoMessage {
	return (*DE)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_DE) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.PubD) != 0 {
		value := protoreflect.ValueOfBytes(x.PubD)
		if !f(fd_DE_pub_d, value) {
			return
		}
	}
	if len(x.PubE) != 0 {
		value := protoreflect.ValueOfBytes(x.PubE)
		if !f(fd_DE_pub_e, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_DE) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "band.tss.v1beta1.DE.pub_d":
		return len(x.PubD) != 0
	case "band.tss.v1beta1.DE.pub_e":
		return len(x.PubE) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.DE"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.DE does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DE) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "band.tss.v1beta1.DE.pub_d":
		x.PubD = nil
	case "band.tss.v1beta1.DE.pub_e":
		x.PubE = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.DE"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.DE does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_DE) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "band.tss.v1beta1.DE.pub_d":
		value := x.PubD
		return protoreflect.ValueOfBytes(value)
	case "band.tss.v1beta1.DE.pub_e":
		value := x.PubE
		return protoreflect.ValueOfBytes(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.DE"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.DE does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DE) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "band.tss.v1beta1.DE.pub_d":
		x.PubD = value.Bytes()
	case "band.tss.v1beta1.DE.pub_e":
		x.PubE = value.Bytes()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.DE"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.DE does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DE) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.DE.pub_d":
		panic(fmt.Errorf("field pub_d of message band.tss.v1beta1.DE is not mutable"))
	case "band.tss.v1beta1.DE.pub_e":
		panic(fmt.Errorf("field pub_e of message band.tss.v1beta1.DE is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.DE"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.DE does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_DE) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.DE.pub_d":
		return protoreflect.ValueOfBytes(nil)
	case "band.tss.v1beta1.DE.pub_e":
		return protoreflect.ValueOfBytes(nil)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.DE"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.DE does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_DE) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in band.tss.v1beta1.DE", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_DE) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DE) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_DE) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_DE) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*DE)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.PubD)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PubE)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*DE)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.PubE) > 0 {
			i -= len(x.PubE)
			copy(dAtA[i:], x.PubE)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PubE)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.PubD) > 0 {
			i -= len(x.PubD)
			copy(dAtA[i:], x.PubD)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PubD)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*DE)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: DE: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: DE: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PubD", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PubD = append(x.PubD[:0], dAtA[iNdEx:postIndex]...)
				if x.PubD == nil {
					x.PubD = []byte{}
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PubE", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PubE = append(x.PubE[:0], dAtA[iNdEx:postIndex]...)
				if x.PubE == nil {
					x.PubE = []byte{}
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_DEQueue      protoreflect.MessageDescriptor
	fd_DEQueue_head protoreflect.FieldDescriptor
	fd_DEQueue_tail protoreflect.FieldDescriptor
)

func init() {
	file_band_tss_v1beta1_tss_proto_init()
	md_DEQueue = File_band_tss_v1beta1_tss_proto.Messages().ByName("DEQueue")
	fd_DEQueue_head = md_DEQueue.Fields().ByName("head")
	fd_DEQueue_tail = md_DEQueue.Fields().ByName("tail")
}

var _ protoreflect.Message = (*fastReflection_DEQueue)(nil)

type fastReflection_DEQueue DEQueue

func (x *DEQueue) ProtoReflect() protoreflect.Message {
	return (*fastReflection_DEQueue)(x)
}

func (x *DEQueue) slowProtoReflect() protoreflect.Message {
	mi := &file_band_tss_v1beta1_tss_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_DEQueue_messageType fastReflection_DEQueue_messageType
var _ protoreflect.MessageType = fastReflection_DEQueue_messageType{}

type fastReflection_DEQueue_messageType struct{}

func (x fastReflection_DEQueue_messageType) Zero() protoreflect.Message {
	return (*fastReflection_DEQueue)(nil)
}
func (x fastReflection_DEQueue_messageType) New() protoreflect.Message {
	return new(fastReflection_DEQueue)
}
func (x fastReflection_DEQueue_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_DEQueue
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_DEQueue) Descriptor() protoreflect.MessageDescriptor {
	return md_DEQueue
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_DEQueue) Type() protoreflect.MessageType {
	return _fastReflection_DEQueue_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_DEQueue) New() protoreflect.Message {
	return new(fastReflection_DEQueue)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_DEQueue) Interface() protoreflect.ProtoMessage {
	return (*DEQueue)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_DEQueue) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Head != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Head)
		if !f(fd_DEQueue_head, value) {
			return
		}
	}
	if x.Tail != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Tail)
		if !f(fd_DEQueue_tail, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_DEQueue) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "band.tss.v1beta1.DEQueue.head":
		return x.Head != uint64(0)
	case "band.tss.v1beta1.DEQueue.tail":
		return x.Tail != uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.DEQueue"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.DEQueue does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DEQueue) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "band.tss.v1beta1.DEQueue.head":
		x.Head = uint64(0)
	case "band.tss.v1beta1.DEQueue.tail":
		x.Tail = uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.DEQueue"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.DEQueue does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_DEQueue) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "band.tss.v1beta1.DEQueue.head":
		value := x.Head
		return protoreflect.ValueOfUint64(value)
	case "band.tss.v1beta1.DEQueue.tail":
		value := x.Tail
		return protoreflect.ValueOfUint64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.DEQueue"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.DEQueue does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DEQueue) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "band.tss.v1beta1.DEQueue.head":
		x.Head = value.Uint()
	case "band.tss.v1beta1.DEQueue.tail":
		x.Tail = value.Uint()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.DEQueue"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.DEQueue does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DEQueue) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.DEQueue.head":
		panic(fmt.Errorf("field head of message band.tss.v1beta1.DEQueue is not mutable"))
	case "band.tss.v1beta1.DEQueue.tail":
		panic(fmt.Errorf("field tail of message band.tss.v1beta1.DEQueue is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.DEQueue"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.DEQueue does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_DEQueue) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.DEQueue.head":
		return protoreflect.ValueOfUint64(uint64(0))
	case "band.tss.v1beta1.DEQueue.tail":
		return protoreflect.ValueOfUint64(uint64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.DEQueue"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.DEQueue does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_DEQueue) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in band.tss.v1beta1.DEQueue", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_DEQueue) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DEQueue) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_DEQueue) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_DEQueue) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*DEQueue)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Head != 0 {
			n += 1 + runtime.Sov(uint64(x.Head))
		}
		if x.Tail != 0 {
			n += 1 + runtime.Sov(uint64(x.Tail))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*DEQueue)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Tail != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Tail))
			i--
			dAtA[i] = 0x10
		}
		if x.Head != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Head))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*DEQueue)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: DEQueue: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: DEQueue: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
				}
				x.Head = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Head |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Tail", wireType)
				}
				x.Tail = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Tail |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_Signing                   protoreflect.MessageDescriptor
	fd_Signing_id                protoreflect.FieldDescriptor
	fd_Signing_current_attempt   protoreflect.FieldDescriptor
	fd_Signing_group_id          protoreflect.FieldDescriptor
	fd_Signing_group_pub_key     protoreflect.FieldDescriptor
	fd_Signing_message           protoreflect.FieldDescriptor
	fd_Signing_group_pub_nonce   protoreflect.FieldDescriptor
	fd_Signing_signature         protoreflect.FieldDescriptor
	fd_Signing_status            protoreflect.FieldDescriptor
	fd_Signing_created_height    protoreflect.FieldDescriptor
	fd_Signing_created_timestamp protoreflect.FieldDescriptor
)

func init() {
	file_band_tss_v1beta1_tss_proto_init()
	md_Signing = File_band_tss_v1beta1_tss_proto.Messages().ByName("Signing")
	fd_Signing_id = md_Signing.Fields().ByName("id")
	fd_Signing_current_attempt = md_Signing.Fields().ByName("current_attempt")
	fd_Signing_group_id = md_Signing.Fields().ByName("group_id")
	fd_Signing_group_pub_key = md_Signing.Fields().ByName("group_pub_key")
	fd_Signing_message = md_Signing.Fields().ByName("message")
	fd_Signing_group_pub_nonce = md_Signing.Fields().ByName("group_pub_nonce")
	fd_Signing_signature = md_Signing.Fields().ByName("signature")
	fd_Signing_status = md_Signing.Fields().ByName("status")
	fd_Signing_created_height = md_Signing.Fields().ByName("created_height")
	fd_Signing_created_timestamp = md_Signing.Fields().ByName("created_timestamp")
}

var _ protoreflect.Message = (*fastReflection_Signing)(nil)

type fastReflection_Signing Signing

func (x *Signing) ProtoReflect() protoreflect.Message {
	return (*fastReflection_Signing)(x)
}

func (x *Signing) slowProtoReflect() protoreflect.Message {
	mi := &file_band_tss_v1beta1_tss_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_Signing_messageType fastReflection_Signing_messageType
var _ protoreflect.MessageType = fastReflection_Signing_messageType{}

type fastReflection_Signing_messageType struct{}

func (x fastReflection_Signing_messageType) Zero() protoreflect.Message {
	return (*fastReflection_Signing)(nil)
}
func (x fastReflection_Signing_messageType) New() protoreflect.Message {
	return new(fastReflection_Signing)
}
func (x fastReflection_Signing_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_Signing
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_Signing) Descriptor() protoreflect.MessageDescriptor {
	return md_Signing
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_Signing) Type() protoreflect.MessageType {
	return _fastReflection_Signing_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_Signing) New() protoreflect.Message {
	return new(fastReflection_Signing)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_Signing) Interface() protoreflect.ProtoMessage {
	return (*Signing)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_Signing) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Id != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Id)
		if !f(fd_Signing_id, value) {
			return
		}
	}
	if x.CurrentAttempt != uint64(0) {
		value := protoreflect.ValueOfUint64(x.CurrentAttempt)
		if !f(fd_Signing_current_attempt, value) {
			return
		}
	}
	if x.GroupId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.GroupId)
		if !f(fd_Signing_group_id, value) {
			return
		}
	}
	if len(x.GroupPubKey) != 0 {
		value := protoreflect.ValueOfBytes(x.GroupPubKey)
		if !f(fd_Signing_group_pub_key, value) {
			return
		}
	}
	if len(x.Message) != 0 {
		value := protoreflect.ValueOfBytes(x.Message)
		if !f(fd_Signing_message, value) {
			return
		}
	}
	if len(x.GroupPubNonce) != 0 {
		value := protoreflect.ValueOfBytes(x.GroupPubNonce)
		if !f(fd_Signing_group_pub_nonce, value) {
			return
		}
	}
	if len(x.Signature) != 0 {
		value := protoreflect.ValueOfBytes(x.Signature)
		if !f(fd_Signing_signature, value) {
			return
		}
	}
	if x.Status != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.Status))
		if !f(fd_Signing_status, value) {
			return
		}
	}
	if x.CreatedHeight != uint64(0) {
		value := protoreflect.ValueOfUint64(x.CreatedHeight)
		if !f(fd_Signing_created_height, value) {
			return
		}
	}
	if x.CreatedTimestamp != nil {
		value := protoreflect.ValueOfMessage(x.CreatedTimestamp.ProtoReflect())
		if !f(fd_Signing_created_timestamp, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_Signing) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "band.tss.v1beta1.Signing.id":
		return x.Id != uint64(0)
	case "band.tss.v1beta1.Signing.current_attempt":
		return x.CurrentAttempt != uint64(0)
	case "band.tss.v1beta1.Signing.group_id":
		return x.GroupId != uint64(0)
	case "band.tss.v1beta1.Signing.group_pub_key":
		return len(x.GroupPubKey) != 0
	case "band.tss.v1beta1.Signing.message":
		return len(x.Message) != 0
	case "band.tss.v1beta1.Signing.group_pub_nonce":
		return len(x.GroupPubNonce) != 0
	case "band.tss.v1beta1.Signing.signature":
		return len(x.Signature) != 0
	case "band.tss.v1beta1.Signing.status":
		return x.Status != 0
	case "band.tss.v1beta1.Signing.created_height":
		return x.CreatedHeight != uint64(0)
	case "band.tss.v1beta1.Signing.created_timestamp":
		return x.CreatedTimestamp != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Signing"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Signing does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Signing) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "band.tss.v1beta1.Signing.id":
		x.Id = uint64(0)
	case "band.tss.v1beta1.Signing.current_attempt":
		x.CurrentAttempt = uint64(0)
	case "band.tss.v1beta1.Signing.group_id":
		x.GroupId = uint64(0)
	case "band.tss.v1beta1.Signing.group_pub_key":
		x.GroupPubKey = nil
	case "band.tss.v1beta1.Signing.message":
		x.Message = nil
	case "band.tss.v1beta1.Signing.group_pub_nonce":
		x.GroupPubNonce = nil
	case "band.tss.v1beta1.Signing.signature":
		x.Signature = nil
	case "band.tss.v1beta1.Signing.status":
		x.Status = 0
	case "band.tss.v1beta1.Signing.created_height":
		x.CreatedHeight = uint64(0)
	case "band.tss.v1beta1.Signing.created_timestamp":
		x.CreatedTimestamp = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Signing"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Signing does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_Signing) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "band.tss.v1beta1.Signing.id":
		value := x.Id
		return protoreflect.ValueOfUint64(value)
	case "band.tss.v1beta1.Signing.current_attempt":
		value := x.CurrentAttempt
		return protoreflect.ValueOfUint64(value)
	case "band.tss.v1beta1.Signing.group_id":
		value := x.GroupId
		return protoreflect.ValueOfUint64(value)
	case "band.tss.v1beta1.Signing.group_pub_key":
		value := x.GroupPubKey
		return protoreflect.ValueOfBytes(value)
	case "band.tss.v1beta1.Signing.message":
		value := x.Message
		return protoreflect.ValueOfBytes(value)
	case "band.tss.v1beta1.Signing.group_pub_nonce":
		value := x.GroupPubNonce
		return protoreflect.ValueOfBytes(value)
	case "band.tss.v1beta1.Signing.signature":
		value := x.Signature
		return protoreflect.ValueOfBytes(value)
	case "band.tss.v1beta1.Signing.status":
		value := x.Status
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	case "band.tss.v1beta1.Signing.created_height":
		value := x.CreatedHeight
		return protoreflect.ValueOfUint64(value)
	case "band.tss.v1beta1.Signing.created_timestamp":
		value := x.CreatedTimestamp
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Signing"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Signing does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Signing) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "band.tss.v1beta1.Signing.id":
		x.Id = value.Uint()
	case "band.tss.v1beta1.Signing.current_attempt":
		x.CurrentAttempt = value.Uint()
	case "band.tss.v1beta1.Signing.group_id":
		x.GroupId = value.Uint()
	case "band.tss.v1beta1.Signing.group_pub_key":
		x.GroupPubKey = value.Bytes()
	case "band.tss.v1beta1.Signing.message":
		x.Message = value.Bytes()
	case "band.tss.v1beta1.Signing.group_pub_nonce":
		x.GroupPubNonce = value.Bytes()
	case "band.tss.v1beta1.Signing.signature":
		x.Signature = value.Bytes()
	case "band.tss.v1beta1.Signing.status":
		x.Status = (SigningStatus)(value.Enum())
	case "band.tss.v1beta1.Signing.created_height":
		x.CreatedHeight = value.Uint()
	case "band.tss.v1beta1.Signing.created_timestamp":
		x.CreatedTimestamp = value.Message().Interface().(*timestamppb.Timestamp)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Signing"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Signing does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Signing) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.Signing.created_timestamp":
		if x.CreatedTimestamp == nil {
			x.CreatedTimestamp = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.CreatedTimestamp.ProtoReflect())
	case "band.tss.v1beta1.Signing.id":
		panic(fmt.Errorf("field id of message band.tss.v1beta1.Signing is not mutable"))
	case "band.tss.v1beta1.Signing.current_attempt":
		panic(fmt.Errorf("field current_attempt of message band.tss.v1beta1.Signing is not mutable"))
	case "band.tss.v1beta1.Signing.group_id":
		panic(fmt.Errorf("field group_id of message band.tss.v1beta1.Signing is not mutable"))
	case "band.tss.v1beta1.Signing.group_pub_key":
		panic(fmt.Errorf("field group_pub_key of message band.tss.v1beta1.Signing is not mutable"))
	case "band.tss.v1beta1.Signing.message":
		panic(fmt.Errorf("field message of message band.tss.v1beta1.Signing is not mutable"))
	case "band.tss.v1beta1.Signing.group_pub_nonce":
		panic(fmt.Errorf("field group_pub_nonce of message band.tss.v1beta1.Signing is not mutable"))
	case "band.tss.v1beta1.Signing.signature":
		panic(fmt.Errorf("field signature of message band.tss.v1beta1.Signing is not mutable"))
	case "band.tss.v1beta1.Signing.status":
		panic(fmt.Errorf("field status of message band.tss.v1beta1.Signing is not mutable"))
	case "band.tss.v1beta1.Signing.created_height":
		panic(fmt.Errorf("field created_height of message band.tss.v1beta1.Signing is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Signing"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Signing does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_Signing) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.Signing.id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "band.tss.v1beta1.Signing.current_attempt":
		return protoreflect.ValueOfUint64(uint64(0))
	case "band.tss.v1beta1.Signing.group_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "band.tss.v1beta1.Signing.group_pub_key":
		return protoreflect.ValueOfBytes(nil)
	case "band.tss.v1beta1.Signing.message":
		return protoreflect.ValueOfBytes(nil)
	case "band.tss.v1beta1.Signing.group_pub_nonce":
		return protoreflect.ValueOfBytes(nil)
	case "band.tss.v1beta1.Signing.signature":
		return protoreflect.ValueOfBytes(nil)
	case "band.tss.v1beta1.Signing.status":
		return protoreflect.ValueOfEnum(0)
	case "band.tss.v1beta1.Signing.created_height":
		return protoreflect.ValueOfUint64(uint64(0))
	case "band.tss.v1beta1.Signing.created_timestamp":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Signing"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Signing does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_Signing) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in band.tss.v1beta1.Signing", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_Signing) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Signing) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_Signing) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_Signing) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*Signing)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Id != 0 {
			n += 1 + runtime.Sov(uint64(x.Id))
		}
		if x.CurrentAttempt != 0 {
			n += 1 + runtime.Sov(uint64(x.CurrentAttempt))
		}
		if x.GroupId != 0 {
			n += 1 + runtime.Sov(uint64(x.GroupId))
		}
		l = len(x.GroupPubKey)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Message)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.GroupPubNonce)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Signature)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Status != 0 {
			n += 1 + runtime.Sov(uint64(x.Status))
		}
		if x.CreatedHeight != 0 {
			n += 1 + runtime.Sov(uint64(x.CreatedHeight))
		}
		if x.CreatedTimestamp != nil {
			l = options.Size(x.CreatedTimestamp)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*Signing)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.CreatedTimestamp != nil {
			encoded, err := options.Marshal(x.CreatedTimestamp)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x52
		}
		if x.CreatedHeight != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.CreatedHeight))
			i--
			dAtA[i] = 0x48
		}
		if x.Status != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Status))
			i--
			dAtA[i] = 0x40
		}
		if len(x.Signature) > 0 {
			i -= len(x.Signature)
			copy(dAtA[i:], x.Signature)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Signature)))
			i--
			dAtA[i] = 0x3a
		}
		if len(x.GroupPubNonce) > 0 {
			i -= len(x.GroupPubNonce)
			copy(dAtA[i:], x.GroupPubNonce)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.GroupPubNonce)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.Message) > 0 {
			i -= len(x.Message)
			copy(dAtA[i:], x.Message)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Message)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.GroupPubKey) > 0 {
			i -= len(x.GroupPubKey)
			copy(dAtA[i:], x.GroupPubKey)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.GroupPubKey)))
			i--
			dAtA[i] = 0x22
		}
		if x.GroupId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.GroupId))
			i--
			dAtA[i] = 0x18
		}
		if x.CurrentAttempt != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.CurrentAttempt))
			i--
			dAtA[i] = 0x10
		}
		if x.Id != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Id))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*Signing)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Signing: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Signing: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
				}
				x.Id = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Id |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CurrentAttempt", wireType)
				}
				x.CurrentAttempt = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.CurrentAttempt |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
				}
				x.GroupId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.GroupId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field GroupPubKey", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.GroupPubKey = append(x.GroupPubKey[:0], dAtA[iNdEx:postIndex]...)
				if x.GroupPubKey == nil {
					x.GroupPubKey = []byte{}
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Message = append(x.Message[:0], dAtA[iNdEx:postIndex]...)
				if x.Message == nil {
					x.Message = []byte{}
				}
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field GroupPubNonce", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.GroupPubNonce = append(x.GroupPubNonce[:0], dAtA[iNdEx:postIndex]...)
				if x.GroupPubNonce == nil {
					x.GroupPubNonce = []byte{}
				}
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Signature = append(x.Signature[:0], dAtA[iNdEx:postIndex]...)
				if x.Signature == nil {
					x.Signature = []byte{}
				}
				iNdEx = postIndex
			case 8:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
				}
				x.Status = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Status |= SigningStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 9:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CreatedHeight", wireType)
				}
				x.CreatedHeight = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.CreatedHeight |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 10:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CreatedTimestamp", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.CreatedTimestamp == nil {
					x.CreatedTimestamp = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.CreatedTimestamp); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_SigningAttempt_4_list)(nil)

type _SigningAttempt_4_list struct {
	list *[]*AssignedMember
}

func (x *_SigningAttempt_4_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_SigningAttempt_4_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_SigningAttempt_4_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*AssignedMember)
	(*x.list)[i] = concreteValue
}

func (x *_SigningAttempt_4_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*AssignedMember)
	*x.list = append(*x.list, concreteValue)
}

func (x *_SigningAttempt_4_list) AppendMutable() protoreflect.Value {
	v := new(AssignedMember)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_SigningAttempt_4_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_SigningAttempt_4_list) NewElement() protoreflect.Value {
	v := new(AssignedMember)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_SigningAttempt_4_list) IsValid() bool {
	return x.list != nil
}

var (
	md_SigningAttempt                  protoreflect.MessageDescriptor
	fd_SigningAttempt_signing_id       protoreflect.FieldDescriptor
	fd_SigningAttempt_attempt          protoreflect.FieldDescriptor
	fd_SigningAttempt_expired_height   protoreflect.FieldDescriptor
	fd_SigningAttempt_assigned_members protoreflect.FieldDescriptor
)

func init() {
	file_band_tss_v1beta1_tss_proto_init()
	md_SigningAttempt = File_band_tss_v1beta1_tss_proto.Messages().ByName("SigningAttempt")
	fd_SigningAttempt_signing_id = md_SigningAttempt.Fields().ByName("signing_id")
	fd_SigningAttempt_attempt = md_SigningAttempt.Fields().ByName("attempt")
	fd_SigningAttempt_expired_height = md_SigningAttempt.Fields().ByName("expired_height")
	fd_SigningAttempt_assigned_members = md_SigningAttempt.Fields().ByName("assigned_members")
}

var _ protoreflect.Message = (*fastReflection_SigningAttempt)(nil)

type fastReflection_SigningAttempt SigningAttempt

func (x *SigningAttempt) ProtoReflect() protoreflect.Message {
	return (*fastReflection_SigningAttempt)(x)
}

func (x *SigningAttempt) slowProtoReflect() protoreflect.Message {
	mi := &file_band_tss_v1beta1_tss_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_SigningAttempt_messageType fastReflection_SigningAttempt_messageType
var _ protoreflect.MessageType = fastReflection_SigningAttempt_messageType{}

type fastReflection_SigningAttempt_messageType struct{}

func (x fastReflection_SigningAttempt_messageType) Zero() protoreflect.Message {
	return (*fastReflection_SigningAttempt)(nil)
}
func (x fastReflection_SigningAttempt_messageType) New() protoreflect.Message {
	return new(fastReflection_SigningAttempt)
}
func (x fastReflection_SigningAttempt_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_SigningAttempt
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_SigningAttempt) Descriptor() protoreflect.MessageDescriptor {
	return md_SigningAttempt
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_SigningAttempt) Type() protoreflect.MessageType {
	return _fastReflection_SigningAttempt_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_SigningAttempt) New() protoreflect.Message {
	return new(fastReflection_SigningAttempt)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_SigningAttempt) Interface() protoreflect.ProtoMessage {
	return (*SigningAttempt)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_SigningAttempt) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.SigningId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.SigningId)
		if !f(fd_SigningAttempt_signing_id, value) {
			return
		}
	}
	if x.Attempt != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Attempt)
		if !f(fd_SigningAttempt_attempt, value) {
			return
		}
	}
	if x.ExpiredHeight != uint64(0) {
		value := protoreflect.ValueOfUint64(x.ExpiredHeight)
		if !f(fd_SigningAttempt_expired_height, value) {
			return
		}
	}
	if len(x.AssignedMembers) != 0 {
		value := protoreflect.ValueOfList(&_SigningAttempt_4_list{list: &x.AssignedMembers})
		if !f(fd_SigningAttempt_assigned_members, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_SigningAttempt) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "band.tss.v1beta1.SigningAttempt.signing_id":
		return x.SigningId != uint64(0)
	case "band.tss.v1beta1.SigningAttempt.attempt":
		return x.Attempt != uint64(0)
	case "band.tss.v1beta1.SigningAttempt.expired_height":
		return x.ExpiredHeight != uint64(0)
	case "band.tss.v1beta1.SigningAttempt.assigned_members":
		return len(x.AssignedMembers) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.SigningAttempt"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.SigningAttempt does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SigningAttempt) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "band.tss.v1beta1.SigningAttempt.signing_id":
		x.SigningId = uint64(0)
	case "band.tss.v1beta1.SigningAttempt.attempt":
		x.Attempt = uint64(0)
	case "band.tss.v1beta1.SigningAttempt.expired_height":
		x.ExpiredHeight = uint64(0)
	case "band.tss.v1beta1.SigningAttempt.assigned_members":
		x.AssignedMembers = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.SigningAttempt"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.SigningAttempt does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_SigningAttempt) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "band.tss.v1beta1.SigningAttempt.signing_id":
		value := x.SigningId
		return protoreflect.ValueOfUint64(value)
	case "band.tss.v1beta1.SigningAttempt.attempt":
		value := x.Attempt
		return protoreflect.ValueOfUint64(value)
	case "band.tss.v1beta1.SigningAttempt.expired_height":
		value := x.ExpiredHeight
		return protoreflect.ValueOfUint64(value)
	case "band.tss.v1beta1.SigningAttempt.assigned_members":
		if len(x.AssignedMembers) == 0 {
			return protoreflect.ValueOfList(&_SigningAttempt_4_list{})
		}
		listValue := &_SigningAttempt_4_list{list: &x.AssignedMembers}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.SigningAttempt"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.SigningAttempt does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SigningAttempt) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "band.tss.v1beta1.SigningAttempt.signing_id":
		x.SigningId = value.Uint()
	case "band.tss.v1beta1.SigningAttempt.attempt":
		x.Attempt = value.Uint()
	case "band.tss.v1beta1.SigningAttempt.expired_height":
		x.ExpiredHeight = value.Uint()
	case "band.tss.v1beta1.SigningAttempt.assigned_members":
		lv := value.List()
		clv := lv.(*_SigningAttempt_4_list)
		x.AssignedMembers = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.SigningAttempt"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.SigningAttempt does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SigningAttempt) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.SigningAttempt.assigned_members":
		if x.AssignedMembers == nil {
			x.AssignedMembers = []*AssignedMember{}
		}
		value := &_SigningAttempt_4_list{list: &x.AssignedMembers}
		return protoreflect.ValueOfList(value)
	case "band.tss.v1beta1.SigningAttempt.signing_id":
		panic(fmt.Errorf("field signing_id of message band.tss.v1beta1.SigningAttempt is not mutable"))
	case "band.tss.v1beta1.SigningAttempt.attempt":
		panic(fmt.Errorf("field attempt of message band.tss.v1beta1.SigningAttempt is not mutable"))
	case "band.tss.v1beta1.SigningAttempt.expired_height":
		panic(fmt.Errorf("field expired_height of message band.tss.v1beta1.SigningAttempt is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.SigningAttempt"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.SigningAttempt does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_SigningAttempt) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.SigningAttempt.signing_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "band.tss.v1beta1.SigningAttempt.attempt":
		return protoreflect.ValueOfUint64(uint64(0))
	case "band.tss.v1beta1.SigningAttempt.expired_height":
		return protoreflect.ValueOfUint64(uint64(0))
	case "band.tss.v1beta1.SigningAttempt.assigned_members":
		list := []*AssignedMember{}
		return protoreflect.ValueOfList(&_SigningAttempt_4_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.SigningAttempt"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.SigningAttempt does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_SigningAttempt) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in band.tss.v1beta1.SigningAttempt", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_SigningAttempt) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SigningAttempt) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_SigningAttempt) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_SigningAttempt) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*SigningAttempt)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.SigningId != 0 {
			n += 1 + runtime.Sov(uint64(x.SigningId))
		}
		if x.Attempt != 0 {
			n += 1 + runtime.Sov(uint64(x.Attempt))
		}
		if x.ExpiredHeight != 0 {
			n += 1 + runtime.Sov(uint64(x.ExpiredHeight))
		}
		if len(x.AssignedMembers) > 0 {
			for _, e := range x.AssignedMembers {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*SigningAttempt)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.AssignedMembers) > 0 {
			for iNdEx := len(x.AssignedMembers) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.AssignedMembers[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x22
			}
		}
		if x.ExpiredHeight != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.ExpiredHeight))
			i--
			dAtA[i] = 0x18
		}
		if x.Attempt != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Attempt))
			i--
			dAtA[i] = 0x10
		}
		if x.SigningId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.SigningId))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*SigningAttempt)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: SigningAttempt: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: SigningAttempt: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SigningId", wireType)
				}
				x.SigningId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.SigningId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Attempt", wireType)
				}
				x.Attempt = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Attempt |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ExpiredHeight", wireType)
				}
				x.ExpiredHeight = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.ExpiredHeight |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AssignedMembers", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AssignedMembers = append(x.AssignedMembers, &AssignedMember{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.AssignedMembers[len(x.AssignedMembers)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_AssignedMember                protoreflect.MessageDescriptor
	fd_AssignedMember_member_id      protoreflect.FieldDescriptor
	fd_AssignedMember_address        protoreflect.FieldDescriptor
	fd_AssignedMember_pub_key        protoreflect.FieldDescriptor
	fd_AssignedMember_pub_d          protoreflect.FieldDescriptor
	fd_AssignedMember_pub_e          protoreflect.FieldDescriptor
	fd_AssignedMember_binding_factor protoreflect.FieldDescriptor
	fd_AssignedMember_pub_nonce      protoreflect.FieldDescriptor
)

func init() {
	file_band_tss_v1beta1_tss_proto_init()
	md_AssignedMember = File_band_tss_v1beta1_tss_proto.Messages().ByName("AssignedMember")
	fd_AssignedMember_member_id = md_AssignedMember.Fields().ByName("member_id")
	fd_AssignedMember_address = md_AssignedMember.Fields().ByName("address")
	fd_AssignedMember_pub_key = md_AssignedMember.Fields().ByName("pub_key")
	fd_AssignedMember_pub_d = md_AssignedMember.Fields().ByName("pub_d")
	fd_AssignedMember_pub_e = md_AssignedMember.Fields().ByName("pub_e")
	fd_AssignedMember_binding_factor = md_AssignedMember.Fields().ByName("binding_factor")
	fd_AssignedMember_pub_nonce = md_AssignedMember.Fields().ByName("pub_nonce")
}

var _ protoreflect.Message = (*fastReflection_AssignedMember)(nil)

type fastReflection_AssignedMember AssignedMember

func (x *AssignedMember) ProtoReflect() protoreflect.Message {
	return (*fastReflection_AssignedMember)(x)
}

func (x *AssignedMember) slowProtoReflect() protoreflect.Message {
	mi := &file_band_tss_v1beta1_tss_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_AssignedMember_messageType fastReflection_AssignedMember_messageType
var _ protoreflect.MessageType = fastReflection_AssignedMember_messageType{}

type fastReflection_AssignedMember_messageType struct{}

func (x fastReflection_AssignedMember_messageType) Zero() protoreflect.Message {
	return (*fastReflection_AssignedMember)(nil)
}
func (x fastReflection_AssignedMember_messageType) New() protoreflect.Message {
	return new(fastReflection_AssignedMember)
}
func (x fastReflection_AssignedMember_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_AssignedMember
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_AssignedMember) Descriptor() protoreflect.MessageDescriptor {
	return md_AssignedMember
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_AssignedMember) Type() protoreflect.MessageType {
	return _fastReflection_AssignedMember_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_AssignedMember) New() protoreflect.Message {
	return new(fastReflection_AssignedMember)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_AssignedMember) Interface() protoreflect.ProtoMessage {
	return (*AssignedMember)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_AssignedMember) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.MemberId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.MemberId)
		if !f(fd_AssignedMember_member_id, value) {
			return
		}
	}
	if x.Address != "" {
		value := protoreflect.ValueOfString(x.Address)
		if !f(fd_AssignedMember_address, value) {
			return
		}
	}
	if len(x.PubKey) != 0 {
		value := protoreflect.ValueOfBytes(x.PubKey)
		if !f(fd_AssignedMember_pub_key, value) {
			return
		}
	}
	if len(x.PubD) != 0 {
		value := protoreflect.ValueOfBytes(x.PubD)
		if !f(fd_AssignedMember_pub_d, value) {
			return
		}
	}
	if len(x.PubE) != 0 {
		value := protoreflect.ValueOfBytes(x.PubE)
		if !f(fd_AssignedMember_pub_e, value) {
			return
		}
	}
	if len(x.BindingFactor) != 0 {
		value := protoreflect.ValueOfBytes(x.BindingFactor)
		if !f(fd_AssignedMember_binding_factor, value) {
			return
		}
	}
	if len(x.PubNonce) != 0 {
		value := protoreflect.ValueOfBytes(x.PubNonce)
		if !f(fd_AssignedMember_pub_nonce, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_AssignedMember) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "band.tss.v1beta1.AssignedMember.member_id":
		return x.MemberId != uint64(0)
	case "band.tss.v1beta1.AssignedMember.address":
		return x.Address != ""
	case "band.tss.v1beta1.AssignedMember.pub_key":
		return len(x.PubKey) != 0
	case "band.tss.v1beta1.AssignedMember.pub_d":
		return len(x.PubD) != 0
	case "band.tss.v1beta1.AssignedMember.pub_e":
		return len(x.PubE) != 0
	case "band.tss.v1beta1.AssignedMember.binding_factor":
		return len(x.BindingFactor) != 0
	case "band.tss.v1beta1.AssignedMember.pub_nonce":
		return len(x.PubNonce) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.AssignedMember"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.AssignedMember does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AssignedMember) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "band.tss.v1beta1.AssignedMember.member_id":
		x.MemberId = uint64(0)
	case "band.tss.v1beta1.AssignedMember.address":
		x.Address = ""
	case "band.tss.v1beta1.AssignedMember.pub_key":
		x.PubKey = nil
	case "band.tss.v1beta1.AssignedMember.pub_d":
		x.PubD = nil
	case "band.tss.v1beta1.AssignedMember.pub_e":
		x.PubE = nil
	case "band.tss.v1beta1.AssignedMember.binding_factor":
		x.BindingFactor = nil
	case "band.tss.v1beta1.AssignedMember.pub_nonce":
		x.PubNonce = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.AssignedMember"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.AssignedMember does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_AssignedMember) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "band.tss.v1beta1.AssignedMember.member_id":
		value := x.MemberId
		return protoreflect.ValueOfUint64(value)
	case "band.tss.v1beta1.AssignedMember.address":
		value := x.Address
		return protoreflect.ValueOfString(value)
	case "band.tss.v1beta1.AssignedMember.pub_key":
		value := x.PubKey
		return protoreflect.ValueOfBytes(value)
	case "band.tss.v1beta1.AssignedMember.pub_d":
		value := x.PubD
		return protoreflect.ValueOfBytes(value)
	case "band.tss.v1beta1.AssignedMember.pub_e":
		value := x.PubE
		return protoreflect.ValueOfBytes(value)
	case "band.tss.v1beta1.AssignedMember.binding_factor":
		value := x.BindingFactor
		return protoreflect.ValueOfBytes(value)
	case "band.tss.v1beta1.AssignedMember.pub_nonce":
		value := x.PubNonce
		return protoreflect.ValueOfBytes(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.AssignedMember"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.AssignedMember does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AssignedMember) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "band.tss.v1beta1.AssignedMember.member_id":
		x.MemberId = value.Uint()
	case "band.tss.v1beta1.AssignedMember.address":
		x.Address = value.Interface().(string)
	case "band.tss.v1beta1.AssignedMember.pub_key":
		x.PubKey = value.Bytes()
	case "band.tss.v1beta1.AssignedMember.pub_d":
		x.PubD = value.Bytes()
	case "band.tss.v1beta1.AssignedMember.pub_e":
		x.PubE = value.Bytes()
	case "band.tss.v1beta1.AssignedMember.binding_factor":
		x.BindingFactor = value.Bytes()
	case "band.tss.v1beta1.AssignedMember.pub_nonce":
		x.PubNonce = value.Bytes()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.AssignedMember"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.AssignedMember does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AssignedMember) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.AssignedMember.member_id":
		panic(fmt.Errorf("field member_id of message band.tss.v1beta1.AssignedMember is not mutable"))
	case "band.tss.v1beta1.AssignedMember.address":
		panic(fmt.Errorf("field address of message band.tss.v1beta1.AssignedMember is not mutable"))
	case "band.tss.v1beta1.AssignedMember.pub_key":
		panic(fmt.Errorf("field pub_key of message band.tss.v1beta1.AssignedMember is not mutable"))
	case "band.tss.v1beta1.AssignedMember.pub_d":
		panic(fmt.Errorf("field pub_d of message band.tss.v1beta1.AssignedMember is not mutable"))
	case "band.tss.v1beta1.AssignedMember.pub_e":
		panic(fmt.Errorf("field pub_e of message band.tss.v1beta1.AssignedMember is not mutable"))
	case "band.tss.v1beta1.AssignedMember.binding_factor":
		panic(fmt.Errorf("field binding_factor of message band.tss.v1beta1.AssignedMember is not mutable"))
	case "band.tss.v1beta1.AssignedMember.pub_nonce":
		panic(fmt.Errorf("field pub_nonce of message band.tss.v1beta1.AssignedMember is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.AssignedMember"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.AssignedMember does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_AssignedMember) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.AssignedMember.member_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "band.tss.v1beta1.AssignedMember.address":
		return protoreflect.ValueOfString("")
	case "band.tss.v1beta1.AssignedMember.pub_key":
		return protoreflect.ValueOfBytes(nil)
	case "band.tss.v1beta1.AssignedMember.pub_d":
		return protoreflect.ValueOfBytes(nil)
	case "band.tss.v1beta1.AssignedMember.pub_e":
		return protoreflect.ValueOfBytes(nil)
	case "band.tss.v1beta1.AssignedMember.binding_factor":
		return protoreflect.ValueOfBytes(nil)
	case "band.tss.v1beta1.AssignedMember.pub_nonce":
		return protoreflect.ValueOfBytes(nil)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.AssignedMember"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.AssignedMember does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_AssignedMember) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in band.tss.v1beta1.AssignedMember", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_AssignedMember) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AssignedMember) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_AssignedMember) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_AssignedMember) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*AssignedMember)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.MemberId != 0 {
			n += 1 + runtime.Sov(uint64(x.MemberId))
		}
		l = len(x.Address)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PubKey)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PubD)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PubE)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.BindingFactor)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PubNonce)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*AssignedMember)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.PubNonce) > 0 {
			i -= len(x.PubNonce)
			copy(dAtA[i:], x.PubNonce)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PubNonce)))
			i--
			dAtA[i] = 0x3a
		}
		if len(x.BindingFactor) > 0 {
			i -= len(x.BindingFactor)
			copy(dAtA[i:], x.BindingFactor)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BindingFactor)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.PubE) > 0 {
			i -= len(x.PubE)
			copy(dAtA[i:], x.PubE)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PubE)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.PubD) > 0 {
			i -= len(x.PubD)
			copy(dAtA[i:], x.PubD)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PubD)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.PubKey) > 0 {
			i -= len(x.PubKey)
			copy(dAtA[i:], x.PubKey)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PubKey)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Address) > 0 {
			i -= len(x.Address)
			copy(dAtA[i:], x.Address)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Address)))
			i--
			dAtA[i] = 0x12
		}
		if x.MemberId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MemberId))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*AssignedMember)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: AssignedMember: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: AssignedMember: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MemberId", wireType)
				}
				x.MemberId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MemberId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Address = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PubKey = append(x.PubKey[:0], dAtA[iNdEx:postIndex]...)
				if x.PubKey == nil {
					x.PubKey = []byte{}
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PubD", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PubD = append(x.PubD[:0], dAtA[iNdEx:postIndex]...)
				if x.PubD == nil {
					x.PubD = []byte{}
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PubE", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PubE = append(x.PubE[:0], dAtA[iNdEx:postIndex]...)
				if x.PubE == nil {
					x.PubE = []byte{}
				}
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BindingFactor", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BindingFactor = append(x.BindingFactor[:0], dAtA[iNdEx:postIndex]...)
				if x.BindingFactor == nil {
					x.BindingFactor = []byte{}
				}
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PubNonce", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PubNonce = append(x.PubNonce[:0], dAtA[iNdEx:postIndex]...)
				if x.PubNonce == nil {
					x.PubNonce = []byte{}
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_PendingSignings_1_list)(nil)

type _PendingSignings_1_list struct {
	list *[]uint64
}

func (x *_PendingSignings_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_PendingSignings_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfUint64((*x.list)[i])
}

func (x *_PendingSignings_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Uint()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_PendingSignings_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Uint()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_PendingSignings_1_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message PendingSignings at list field SigningIds as it is not of Message kind"))
}

func (x *_PendingSignings_1_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_PendingSignings_1_list) NewElement() protoreflect.Value {
	v := uint64(0)
	return protoreflect.ValueOfUint64(v)
}

func (x *_PendingSignings_1_list) IsValid() bool {
	return x.list != nil
}

var (
	md_PendingSignings             protoreflect.MessageDescriptor
	fd_PendingSignings_signing_ids protoreflect.FieldDescriptor
)

func init() {
	file_band_tss_v1beta1_tss_proto_init()
	md_PendingSignings = File_band_tss_v1beta1_tss_proto.Messages().ByName("PendingSignings")
	fd_PendingSignings_signing_ids = md_PendingSignings.Fields().ByName("signing_ids")
}

var _ protoreflect.Message = (*fastReflection_PendingSignings)(nil)

type fastReflection_PendingSignings PendingSignings

func (x *PendingSignings) ProtoReflect() protoreflect.Message {
	return (*fastReflection_PendingSignings)(x)
}

func (x *PendingSignings) slowProtoReflect() protoreflect.Message {
	mi := &file_band_tss_v1beta1_tss_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_PendingSignings_messageType fastReflection_PendingSignings_messageType
var _ protoreflect.MessageType = fastReflection_PendingSignings_messageType{}

type fastReflection_PendingSignings_messageType struct{}

func (x fastReflection_PendingSignings_messageType) Zero() protoreflect.Message {
	return (*fastReflection_PendingSignings)(nil)
}
func (x fastReflection_PendingSignings_messageType) New() protoreflect.Message {
	return new(fastReflection_PendingSignings)
}
func (x fastReflection_PendingSignings_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_PendingSignings
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_PendingSignings) Descriptor() protoreflect.MessageDescriptor {
	return md_PendingSignings
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_PendingSignings) Type() protoreflect.MessageType {
	return _fastReflection_PendingSignings_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_PendingSignings) New() protoreflect.Message {
	return new(fastReflection_PendingSignings)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_PendingSignings) Interface() protoreflect.ProtoMessage {
	return (*PendingSignings)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_PendingSignings) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.SigningIds) != 0 {
		value := protoreflect.ValueOfList(&_PendingSignings_1_list{list: &x.SigningIds})
		if !f(fd_PendingSignings_signing_ids, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_PendingSignings) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "band.tss.v1beta1.PendingSignings.signing_ids":
		return len(x.SigningIds) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.PendingSignings"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.PendingSignings does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PendingSignings) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "band.tss.v1beta1.PendingSignings.signing_ids":
		x.SigningIds = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.PendingSignings"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.PendingSignings does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_PendingSignings) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "band.tss.v1beta1.PendingSignings.signing_ids":
		if len(x.SigningIds) == 0 {
			return protoreflect.ValueOfList(&_PendingSignings_1_list{})
		}
		listValue := &_PendingSignings_1_list{list: &x.SigningIds}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.PendingSignings"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.PendingSignings does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PendingSignings) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "band.tss.v1beta1.PendingSignings.signing_ids":
		lv := value.List()
		clv := lv.(*_PendingSignings_1_list)
		x.SigningIds = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.PendingSignings"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.PendingSignings does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PendingSignings) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.PendingSignings.signing_ids":
		if x.SigningIds == nil {
			x.SigningIds = []uint64{}
		}
		value := &_PendingSignings_1_list{list: &x.SigningIds}
		return protoreflect.ValueOfList(value)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.PendingSignings"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.PendingSignings does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_PendingSignings) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.PendingSignings.signing_ids":
		list := []uint64{}
		return protoreflect.ValueOfList(&_PendingSignings_1_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.PendingSignings"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.PendingSignings does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_PendingSignings) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in band.tss.v1beta1.PendingSignings", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_PendingSignings) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PendingSignings) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_PendingSignings) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_PendingSignings) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*PendingSignings)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.SigningIds) > 0 {
			l = 0
			for _, e := range x.SigningIds {
				l += runtime.Sov(uint64(e))
			}
			n += 1 + runtime.Sov(uint64(l)) + l
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*PendingSignings)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.SigningIds) > 0 {
			var pksize2 int
			for _, num := range x.SigningIds {
				pksize2 += runtime.Sov(uint64(num))
			}
			i -= pksize2
			j1 := i
			for _, num := range x.SigningIds {
				for num >= 1<<7 {
					dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j1++
				}
				dAtA[j1] = uint8(num)
				j1++
			}
			i = runtime.EncodeVarint(dAtA, i, uint64(pksize2))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*PendingSignings)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PendingSignings: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PendingSignings: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType == 0 {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
						}
						if iNdEx >= l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					x.SigningIds = append(x.SigningIds, v)
				} else if wireType == 2 {
					var packedLen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
						}
						if iNdEx >= l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						packedLen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if packedLen < 0 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
					}
					postIndex := iNdEx + packedLen
					if postIndex < 0 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
					}
					if postIndex > l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					var elementCount int
					var count int
					for _, integer := range dAtA[iNdEx:postIndex] {
						if integer < 128 {
							count++
						}
					}
					elementCount = count
					if elementCount != 0 && len(x.SigningIds) == 0 {
						x.SigningIds = make([]uint64, 0, elementCount)
					}
					for iNdEx < postIndex {
						var v uint64
						for shift := uint(0); ; shift += 7 {
							if shift >= 64 {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
							}
							if iNdEx >= l {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
							}
							b := dAtA[iNdEx]
							iNdEx++
							v |= uint64(b&0x7F) << shift
							if b < 0x80 {
								break
							}
						}
						x.SigningIds = append(x.SigningIds, v)
					}
				} else {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SigningIds", wireType)
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_Member              protoreflect.MessageDescriptor
	fd_Member_id           protoreflect.FieldDescriptor
	fd_Member_group_id     protoreflect.FieldDescriptor
	fd_Member_address      protoreflect.FieldDescriptor
	fd_Member_pub_key      protoreflect.FieldDescriptor
	fd_Member_is_malicious protoreflect.FieldDescriptor
	fd_Member_is_active    protoreflect.FieldDescriptor
)

func init() {
	file_band_tss_v1beta1_tss_proto_init()
	md_Member = File_band_tss_v1beta1_tss_proto.Messages().ByName("Member")
	fd_Member_id = md_Member.Fields().ByName("id")
	fd_Member_group_id = md_Member.Fields().ByName("group_id")
	fd_Member_address = md_Member.Fields().ByName("address")
	fd_Member_pub_key = md_Member.Fields().ByName("pub_key")
	fd_Member_is_malicious = md_Member.Fields().ByName("is_malicious")
	fd_Member_is_active = md_Member.Fields().ByName("is_active")
}

var _ protoreflect.Message = (*fastReflection_Member)(nil)

type fastReflection_Member Member

func (x *Member) ProtoReflect() protoreflect.Message {
	return (*fastReflection_Member)(x)
}

func (x *Member) slowProtoReflect() protoreflect.Message {
	mi := &file_band_tss_v1beta1_tss_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_Member_messageType fastReflection_Member_messageType
var _ protoreflect.MessageType = fastReflection_Member_messageType{}

type fastReflection_Member_messageType struct{}

func (x fastReflection_Member_messageType) Zero() protoreflect.Message {
	return (*fastReflection_Member)(nil)
}
func (x fastReflection_Member_messageType) New() protoreflect.Message {
	return new(fastReflection_Member)
}
func (x fastReflection_Member_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_Member
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_Member) Descriptor() protoreflect.MessageDescriptor {
	return md_Member
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_Member) Type() protoreflect.MessageType {
	return _fastReflection_Member_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_Member) New() protoreflect.Message {
	return new(fastReflection_Member)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_Member) Interface() protoreflect.ProtoMessage {
	return (*Member)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_Member) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Id != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Id)
		if !f(fd_Member_id, value) {
			return
		}
	}
	if x.GroupId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.GroupId)
		if !f(fd_Member_group_id, value) {
			return
		}
	}
	if x.Address != "" {
		value := protoreflect.ValueOfString(x.Address)
		if !f(fd_Member_address, value) {
			return
		}
	}
	if len(x.PubKey) != 0 {
		value := protoreflect.ValueOfBytes(x.PubKey)
		if !f(fd_Member_pub_key, value) {
			return
		}
	}
	if x.IsMalicious != false {
		value := protoreflect.ValueOfBool(x.IsMalicious)
		if !f(fd_Member_is_malicious, value) {
			return
		}
	}
	if x.IsActive != false {
		value := protoreflect.ValueOfBool(x.IsActive)
		if !f(fd_Member_is_active, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_Member) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "band.tss.v1beta1.Member.id":
		return x.Id != uint64(0)
	case "band.tss.v1beta1.Member.group_id":
		return x.GroupId != uint64(0)
	case "band.tss.v1beta1.Member.address":
		return x.Address != ""
	case "band.tss.v1beta1.Member.pub_key":
		return len(x.PubKey) != 0
	case "band.tss.v1beta1.Member.is_malicious":
		return x.IsMalicious != false
	case "band.tss.v1beta1.Member.is_active":
		return x.IsActive != false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Member"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Member does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Member) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "band.tss.v1beta1.Member.id":
		x.Id = uint64(0)
	case "band.tss.v1beta1.Member.group_id":
		x.GroupId = uint64(0)
	case "band.tss.v1beta1.Member.address":
		x.Address = ""
	case "band.tss.v1beta1.Member.pub_key":
		x.PubKey = nil
	case "band.tss.v1beta1.Member.is_malicious":
		x.IsMalicious = false
	case "band.tss.v1beta1.Member.is_active":
		x.IsActive = false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Member"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Member does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_Member) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "band.tss.v1beta1.Member.id":
		value := x.Id
		return protoreflect.ValueOfUint64(value)
	case "band.tss.v1beta1.Member.group_id":
		value := x.GroupId
		return protoreflect.ValueOfUint64(value)
	case "band.tss.v1beta1.Member.address":
		value := x.Address
		return protoreflect.ValueOfString(value)
	case "band.tss.v1beta1.Member.pub_key":
		value := x.PubKey
		return protoreflect.ValueOfBytes(value)
	case "band.tss.v1beta1.Member.is_malicious":
		value := x.IsMalicious
		return protoreflect.ValueOfBool(value)
	case "band.tss.v1beta1.Member.is_active":
		value := x.IsActive
		return protoreflect.ValueOfBool(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Member"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Member does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Member) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "band.tss.v1beta1.Member.id":
		x.Id = value.Uint()
	case "band.tss.v1beta1.Member.group_id":
		x.GroupId = value.Uint()
	case "band.tss.v1beta1.Member.address":
		x.Address = value.Interface().(string)
	case "band.tss.v1beta1.Member.pub_key":
		x.PubKey = value.Bytes()
	case "band.tss.v1beta1.Member.is_malicious":
		x.IsMalicious = value.Bool()
	case "band.tss.v1beta1.Member.is_active":
		x.IsActive = value.Bool()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Member"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Member does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Member) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.Member.id":
		panic(fmt.Errorf("field id of message band.tss.v1beta1.Member is not mutable"))
	case "band.tss.v1beta1.Member.group_id":
		panic(fmt.Errorf("field group_id of message band.tss.v1beta1.Member is not mutable"))
	case "band.tss.v1beta1.Member.address":
		panic(fmt.Errorf("field address of message band.tss.v1beta1.Member is not mutable"))
	case "band.tss.v1beta1.Member.pub_key":
		panic(fmt.Errorf("field pub_key of message band.tss.v1beta1.Member is not mutable"))
	case "band.tss.v1beta1.Member.is_malicious":
		panic(fmt.Errorf("field is_malicious of message band.tss.v1beta1.Member is not mutable"))
	case "band.tss.v1beta1.Member.is_active":
		panic(fmt.Errorf("field is_active of message band.tss.v1beta1.Member is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Member"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Member does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_Member) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.Member.id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "band.tss.v1beta1.Member.group_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "band.tss.v1beta1.Member.address":
		return protoreflect.ValueOfString("")
	case "band.tss.v1beta1.Member.pub_key":
		return protoreflect.ValueOfBytes(nil)
	case "band.tss.v1beta1.Member.is_malicious":
		return protoreflect.ValueOfBool(false)
	case "band.tss.v1beta1.Member.is_active":
		return protoreflect.ValueOfBool(false)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Member"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Member does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_Member) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in band.tss.v1beta1.Member", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_Member) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Member) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_Member) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_Member) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*Member)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Id != 0 {
			n += 1 + runtime.Sov(uint64(x.Id))
		}
		if x.GroupId != 0 {
			n += 1 + runtime.Sov(uint64(x.GroupId))
		}
		l = len(x.Address)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PubKey)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.IsMalicious {
			n += 2
		}
		if x.IsActive {
			n += 2
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*Member)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.IsActive {
			i--
			if x.IsActive {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x30
		}
		if x.IsMalicious {
			i--
			if x.IsMalicious {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x28
		}
		if len(x.PubKey) > 0 {
			i -= len(x.PubKey)
			copy(dAtA[i:], x.PubKey)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PubKey)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.Address) > 0 {
			i -= len(x.Address)
			copy(dAtA[i:], x.Address)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Address)))
			i--
			dAtA[i] = 0x1a
		}
		if x.GroupId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.GroupId))
			i--
			dAtA[i] = 0x10
		}
		if x.Id != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Id))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*Member)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Member: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
				}
				x.Id = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Id |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
				}
				x.GroupId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.GroupId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Address = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PubKey = append(x.PubKey[:0], dAtA[iNdEx:postIndex]...)
				if x.PubKey == nil {
					x.PubKey = []byte{}
				}
				iNdEx = postIndex
			case 5:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field IsMalicious", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.IsMalicious = bool(v != 0)
			case 6:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.IsActive = bool(v != 0)
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_Confirm                 protoreflect.MessageDescriptor
	fd_Confirm_member_id       protoreflect.FieldDescriptor
	fd_Confirm_own_pub_key_sig protoreflect.FieldDescriptor
)

func init() {
	file_band_tss_v1beta1_tss_proto_init()
	md_Confirm = File_band_tss_v1beta1_tss_proto.Messages().ByName("Confirm")
	fd_Confirm_member_id = md_Confirm.Fields().ByName("member_id")
	fd_Confirm_own_pub_key_sig = md_Confirm.Fields().ByName("own_pub_key_sig")
}

var _ protoreflect.Message = (*fastReflection_Confirm)(nil)

type fastReflection_Confirm Confirm

func (x *Confirm) ProtoReflect() protoreflect.Message {
	return (*fastReflection_Confirm)(x)
}

func (x *Confirm) slowProtoReflect() protoreflect.Message {
	mi := &file_band_tss_v1beta1_tss_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_Confirm_messageType fastReflection_Confirm_messageType
var _ protoreflect.MessageType = fastReflection_Confirm_messageType{}

type fastReflection_Confirm_messageType struct{}

func (x fastReflection_Confirm_messageType) Zero() protoreflect.Message {
	return (*fastReflection_Confirm)(nil)
}
func (x fastReflection_Confirm_messageType) New() protoreflect.Message {
	return new(fastReflection_Confirm)
}
func (x fastReflection_Confirm_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_Confirm
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_Confirm) Descriptor() protoreflect.MessageDescriptor {
	return md_Confirm
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_Confirm) Type() protoreflect.MessageType {
	return _fastReflection_Confirm_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_Confirm) New() protoreflect.Message {
	return new(fastReflection_Confirm)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_Confirm) Interface() protoreflect.ProtoMessage {
	return (*Confirm)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_Confirm) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.MemberId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.MemberId)
		if !f(fd_Confirm_member_id, value) {
			return
		}
	}
	if len(x.OwnPubKeySig) != 0 {
		value := protoreflect.ValueOfBytes(x.OwnPubKeySig)
		if !f(fd_Confirm_own_pub_key_sig, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_Confirm) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "band.tss.v1beta1.Confirm.member_id":
		return x.MemberId != uint64(0)
	case "band.tss.v1beta1.Confirm.own_pub_key_sig":
		return len(x.OwnPubKeySig) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Confirm"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Confirm does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Confirm) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "band.tss.v1beta1.Confirm.member_id":
		x.MemberId = uint64(0)
	case "band.tss.v1beta1.Confirm.own_pub_key_sig":
		x.OwnPubKeySig = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Confirm"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Confirm does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_Confirm) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "band.tss.v1beta1.Confirm.member_id":
		value := x.MemberId
		return protoreflect.ValueOfUint64(value)
	case "band.tss.v1beta1.Confirm.own_pub_key_sig":
		value := x.OwnPubKeySig
		return protoreflect.ValueOfBytes(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Confirm"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Confirm does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Confirm) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "band.tss.v1beta1.Confirm.member_id":
		x.MemberId = value.Uint()
	case "band.tss.v1beta1.Confirm.own_pub_key_sig":
		x.OwnPubKeySig = value.Bytes()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Confirm"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Confirm does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Confirm) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.Confirm.member_id":
		panic(fmt.Errorf("field member_id of message band.tss.v1beta1.Confirm is not mutable"))
	case "band.tss.v1beta1.Confirm.own_pub_key_sig":
		panic(fmt.Errorf("field own_pub_key_sig of message band.tss.v1beta1.Confirm is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Confirm"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Confirm does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_Confirm) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.Confirm.member_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "band.tss.v1beta1.Confirm.own_pub_key_sig":
		return protoreflect.ValueOfBytes(nil)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Confirm"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Confirm does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_Confirm) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in band.tss.v1beta1.Confirm", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_Confirm) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Confirm) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_Confirm) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_Confirm) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*Confirm)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.MemberId != 0 {
			n += 1 + runtime.Sov(uint64(x.MemberId))
		}
		l = len(x.OwnPubKeySig)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*Confirm)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.OwnPubKeySig) > 0 {
			i -= len(x.OwnPubKeySig)
			copy(dAtA[i:], x.OwnPubKeySig)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.OwnPubKeySig)))
			i--
			dAtA[i] = 0x12
		}
		if x.MemberId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MemberId))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*Confirm)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Confirm: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Confirm: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MemberId", wireType)
				}
				x.MemberId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MemberId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OwnPubKeySig", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.OwnPubKeySig = append(x.OwnPubKeySig[:0], dAtA[iNdEx:postIndex]...)
				if x.OwnPubKeySig == nil {
					x.OwnPubKeySig = []byte{}
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_Complaint             protoreflect.MessageDescriptor
	fd_Complaint_complainant protoreflect.FieldDescriptor
	fd_Complaint_respondent  protoreflect.FieldDescriptor
	fd_Complaint_key_sym     protoreflect.FieldDescriptor
	fd_Complaint_signature   protoreflect.FieldDescriptor
)

func init() {
	file_band_tss_v1beta1_tss_proto_init()
	md_Complaint = File_band_tss_v1beta1_tss_proto.Messages().ByName("Complaint")
	fd_Complaint_complainant = md_Complaint.Fields().ByName("complainant")
	fd_Complaint_respondent = md_Complaint.Fields().ByName("respondent")
	fd_Complaint_key_sym = md_Complaint.Fields().ByName("key_sym")
	fd_Complaint_signature = md_Complaint.Fields().ByName("signature")
}

var _ protoreflect.Message = (*fastReflection_Complaint)(nil)

type fastReflection_Complaint Complaint

func (x *Complaint) ProtoReflect() protoreflect.Message {
	return (*fastReflection_Complaint)(x)
}

func (x *Complaint) slowProtoReflect() protoreflect.Message {
	mi := &file_band_tss_v1beta1_tss_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_Complaint_messageType fastReflection_Complaint_messageType
var _ protoreflect.MessageType = fastReflection_Complaint_messageType{}

type fastReflection_Complaint_messageType struct{}

func (x fastReflection_Complaint_messageType) Zero() protoreflect.Message {
	return (*fastReflection_Complaint)(nil)
}
func (x fastReflection_Complaint_messageType) New() protoreflect.Message {
	return new(fastReflection_Complaint)
}
func (x fastReflection_Complaint_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_Complaint
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_Complaint) Descriptor() protoreflect.MessageDescriptor {
	return md_Complaint
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_Complaint) Type() protoreflect.MessageType {
	return _fastReflection_Complaint_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_Complaint) New() protoreflect.Message {
	return new(fastReflection_Complaint)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_Complaint) Interface() protoreflect.ProtoMessage {
	return (*Complaint)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_Complaint) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Complainant != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Complainant)
		if !f(fd_Complaint_complainant, value) {
			return
		}
	}
	if x.Respondent != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Respondent)
		if !f(fd_Complaint_respondent, value) {
			return
		}
	}
	if len(x.KeySym) != 0 {
		value := protoreflect.ValueOfBytes(x.KeySym)
		if !f(fd_Complaint_key_sym, value) {
			return
		}
	}
	if len(x.Signature) != 0 {
		value := protoreflect.ValueOfBytes(x.Signature)
		if !f(fd_Complaint_signature, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_Complaint) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "band.tss.v1beta1.Complaint.complainant":
		return x.Complainant != uint64(0)
	case "band.tss.v1beta1.Complaint.respondent":
		return x.Respondent != uint64(0)
	case "band.tss.v1beta1.Complaint.key_sym":
		return len(x.KeySym) != 0
	case "band.tss.v1beta1.Complaint.signature":
		return len(x.Signature) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Complaint"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Complaint does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Complaint) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "band.tss.v1beta1.Complaint.complainant":
		x.Complainant = uint64(0)
	case "band.tss.v1beta1.Complaint.respondent":
		x.Respondent = uint64(0)
	case "band.tss.v1beta1.Complaint.key_sym":
		x.KeySym = nil
	case "band.tss.v1beta1.Complaint.signature":
		x.Signature = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Complaint"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Complaint does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_Complaint) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "band.tss.v1beta1.Complaint.complainant":
		value := x.Complainant
		return protoreflect.ValueOfUint64(value)
	case "band.tss.v1beta1.Complaint.respondent":
		value := x.Respondent
		return protoreflect.ValueOfUint64(value)
	case "band.tss.v1beta1.Complaint.key_sym":
		value := x.KeySym
		return protoreflect.ValueOfBytes(value)
	case "band.tss.v1beta1.Complaint.signature":
		value := x.Signature
		return protoreflect.ValueOfBytes(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Complaint"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Complaint does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Complaint) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "band.tss.v1beta1.Complaint.complainant":
		x.Complainant = value.Uint()
	case "band.tss.v1beta1.Complaint.respondent":
		x.Respondent = value.Uint()
	case "band.tss.v1beta1.Complaint.key_sym":
		x.KeySym = value.Bytes()
	case "band.tss.v1beta1.Complaint.signature":
		x.Signature = value.Bytes()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Complaint"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Complaint does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Complaint) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.Complaint.complainant":
		panic(fmt.Errorf("field complainant of message band.tss.v1beta1.Complaint is not mutable"))
	case "band.tss.v1beta1.Complaint.respondent":
		panic(fmt.Errorf("field respondent of message band.tss.v1beta1.Complaint is not mutable"))
	case "band.tss.v1beta1.Complaint.key_sym":
		panic(fmt.Errorf("field key_sym of message band.tss.v1beta1.Complaint is not mutable"))
	case "band.tss.v1beta1.Complaint.signature":
		panic(fmt.Errorf("field signature of message band.tss.v1beta1.Complaint is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Complaint"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Complaint does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_Complaint) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.Complaint.complainant":
		return protoreflect.ValueOfUint64(uint64(0))
	case "band.tss.v1beta1.Complaint.respondent":
		return protoreflect.ValueOfUint64(uint64(0))
	case "band.tss.v1beta1.Complaint.key_sym":
		return protoreflect.ValueOfBytes(nil)
	case "band.tss.v1beta1.Complaint.signature":
		return protoreflect.ValueOfBytes(nil)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.Complaint"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.Complaint does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_Complaint) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in band.tss.v1beta1.Complaint", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_Complaint) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Complaint) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_Complaint) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_Complaint) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*Complaint)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Complainant != 0 {
			n += 1 + runtime.Sov(uint64(x.Complainant))
		}
		if x.Respondent != 0 {
			n += 1 + runtime.Sov(uint64(x.Respondent))
		}
		l = len(x.KeySym)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Signature)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*Complaint)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Signature) > 0 {
			i -= len(x.Signature)
			copy(dAtA[i:], x.Signature)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Signature)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.KeySym) > 0 {
			i -= len(x.KeySym)
			copy(dAtA[i:], x.KeySym)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.KeySym)))
			i--
			dAtA[i] = 0x1a
		}
		if x.Respondent != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Respondent))
			i--
			dAtA[i] = 0x10
		}
		if x.Complainant != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Complainant))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*Complaint)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Complaint: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Complaint: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Complainant", wireType)
				}
				x.Complainant = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Complainant |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Respondent", wireType)
				}
				x.Respondent = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Respondent |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field KeySym", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.KeySym = append(x.KeySym[:0], dAtA[iNdEx:postIndex]...)
				if x.KeySym == nil {
					x.KeySym = []byte{}
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Signature = append(x.Signature[:0], dAtA[iNdEx:postIndex]...)
				if x.Signature == nil {
					x.Signature = []byte{}
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_ComplaintWithStatus                  protoreflect.MessageDescriptor
	fd_ComplaintWithStatus_complaint        protoreflect.FieldDescriptor
	fd_ComplaintWithStatus_complaint_status protoreflect.FieldDescriptor
)

func init() {
	file_band_tss_v1beta1_tss_proto_init()
	md_ComplaintWithStatus = File_band_tss_v1beta1_tss_proto.Messages().ByName("ComplaintWithStatus")
	fd_ComplaintWithStatus_complaint = md_ComplaintWithStatus.Fields().ByName("complaint")
	fd_ComplaintWithStatus_complaint_status = md_ComplaintWithStatus.Fields().ByName("complaint_status")
}

var _ protoreflect.Message = (*fastReflection_ComplaintWithStatus)(nil)

type fastReflection_ComplaintWithStatus ComplaintWithStatus

func (x *ComplaintWithStatus) ProtoReflect() protoreflect.Message {
	return (*fastReflection_ComplaintWithStatus)(x)
}

func (x *ComplaintWithStatus) slowProtoReflect() protoreflect.Message {
	mi := &file_band_tss_v1beta1_tss_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_ComplaintWithStatus_messageType fastReflection_ComplaintWithStatus_messageType
var _ protoreflect.MessageType = fastReflection_ComplaintWithStatus_messageType{}

type fastReflection_ComplaintWithStatus_messageType struct{}

func (x fastReflection_ComplaintWithStatus_messageType) Zero() protoreflect.Message {
	return (*fastReflection_ComplaintWithStatus)(nil)
}
func (x fastReflection_ComplaintWithStatus_messageType) New() protoreflect.Message {
	return new(fastReflection_ComplaintWithStatus)
}
func (x fastReflection_ComplaintWithStatus_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_ComplaintWithStatus
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_ComplaintWithStatus) Descriptor() protoreflect.MessageDescriptor {
	return md_ComplaintWithStatus
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_ComplaintWithStatus) Type() protoreflect.MessageType {
	return _fastReflection_ComplaintWithStatus_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_ComplaintWithStatus) New() protoreflect.Message {
	return new(fastReflection_ComplaintWithStatus)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_ComplaintWithStatus) Interface() protoreflect.ProtoMessage {
	return (*ComplaintWithStatus)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_ComplaintWithStatus) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Complaint != nil {
		value := protoreflect.ValueOfMessage(x.Complaint.ProtoReflect())
		if !f(fd_ComplaintWithStatus_complaint, value) {
			return
		}
	}
	if x.ComplaintStatus != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.ComplaintStatus))
		if !f(fd_ComplaintWithStatus_complaint_status, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_ComplaintWithStatus) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "band.tss.v1beta1.ComplaintWithStatus.complaint":
		return x.Complaint != nil
	case "band.tss.v1beta1.ComplaintWithStatus.complaint_status":
		return x.ComplaintStatus != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.ComplaintWithStatus"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.ComplaintWithStatus does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ComplaintWithStatus) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "band.tss.v1beta1.ComplaintWithStatus.complaint":
		x.Complaint = nil
	case "band.tss.v1beta1.ComplaintWithStatus.complaint_status":
		x.ComplaintStatus = 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.ComplaintWithStatus"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.ComplaintWithStatus does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_ComplaintWithStatus) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "band.tss.v1beta1.ComplaintWithStatus.complaint":
		value := x.Complaint
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "band.tss.v1beta1.ComplaintWithStatus.complaint_status":
		value := x.ComplaintStatus
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.ComplaintWithStatus"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.ComplaintWithStatus does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ComplaintWithStatus) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "band.tss.v1beta1.ComplaintWithStatus.complaint":
		x.Complaint = value.Message().Interface().(*Complaint)
	case "band.tss.v1beta1.ComplaintWithStatus.complaint_status":
		x.ComplaintStatus = (ComplaintStatus)(value.Enum())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.ComplaintWithStatus"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.ComplaintWithStatus does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ComplaintWithStatus) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.ComplaintWithStatus.complaint":
		if x.Complaint == nil {
			x.Complaint = new(Complaint)
		}
		return protoreflect.ValueOfMessage(x.Complaint.ProtoReflect())
	case "band.tss.v1beta1.ComplaintWithStatus.complaint_status":
		panic(fmt.Errorf("field complaint_status of message band.tss.v1beta1.ComplaintWithStatus is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.ComplaintWithStatus"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.ComplaintWithStatus does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_ComplaintWithStatus) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.ComplaintWithStatus.complaint":
		m := new(Complaint)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "band.tss.v1beta1.ComplaintWithStatus.complaint_status":
		return protoreflect.ValueOfEnum(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.ComplaintWithStatus"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.ComplaintWithStatus does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_ComplaintWithStatus) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in band.tss.v1beta1.ComplaintWithStatus", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_ComplaintWithStatus) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ComplaintWithStatus) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_ComplaintWithStatus) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_ComplaintWithStatus) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*ComplaintWithStatus)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Complaint != nil {
			l = options.Size(x.Complaint)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.ComplaintStatus != 0 {
			n += 1 + runtime.Sov(uint64(x.ComplaintStatus))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*ComplaintWithStatus)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.ComplaintStatus != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.ComplaintStatus))
			i--
			dAtA[i] = 0x10
		}
		if x.Complaint != nil {
			encoded, err := options.Marshal(x.Complaint)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*ComplaintWithStatus)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ComplaintWithStatus: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ComplaintWithStatus: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Complaint", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Complaint == nil {
					x.Complaint = &Complaint{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Complaint); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ComplaintStatus", wireType)
				}
				x.ComplaintStatus = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.ComplaintStatus |= ComplaintStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_ComplaintsWithStatus_2_list)(nil)

type _ComplaintsWithStatus_2_list struct {
	list *[]*ComplaintWithStatus
}

func (x *_ComplaintsWithStatus_2_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_ComplaintsWithStatus_2_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_ComplaintsWithStatus_2_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*ComplaintWithStatus)
	(*x.list)[i] = concreteValue
}

func (x *_ComplaintsWithStatus_2_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*ComplaintWithStatus)
	*x.list = append(*x.list, concreteValue)
}

func (x *_ComplaintsWithStatus_2_list) AppendMutable() protoreflect.Value {
	v := new(ComplaintWithStatus)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_ComplaintsWithStatus_2_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_ComplaintsWithStatus_2_list) NewElement() protoreflect.Value {
	v := new(ComplaintWithStatus)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_ComplaintsWithStatus_2_list) IsValid() bool {
	return x.list != nil
}

var (
	md_ComplaintsWithStatus                        protoreflect.MessageDescriptor
	fd_ComplaintsWithStatus_member_id              protoreflect.FieldDescriptor
	fd_ComplaintsWithStatus_complaints_with_status protoreflect.FieldDescriptor
)

func init() {
	file_band_tss_v1beta1_tss_proto_init()
	md_ComplaintsWithStatus = File_band_tss_v1beta1_tss_proto.Messages().ByName("ComplaintsWithStatus")
	fd_ComplaintsWithStatus_member_id = md_ComplaintsWithStatus.Fields().ByName("member_id")
	fd_ComplaintsWithStatus_complaints_with_status = md_ComplaintsWithStatus.Fields().ByName("complaints_with_status")
}

var _ protoreflect.Message = (*fastReflection_ComplaintsWithStatus)(nil)

type fastReflection_ComplaintsWithStatus ComplaintsWithStatus

func (x *ComplaintsWithStatus) ProtoReflect() protoreflect.Message {
	return (*fastReflection_ComplaintsWithStatus)(x)
}

func (x *ComplaintsWithStatus) slowProtoReflect() protoreflect.Message {
	mi := &file_band_tss_v1beta1_tss_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_ComplaintsWithStatus_messageType fastReflection_ComplaintsWithStatus_messageType
var _ protoreflect.MessageType = fastReflection_ComplaintsWithStatus_messageType{}

type fastReflection_ComplaintsWithStatus_messageType struct{}

func (x fastReflection_ComplaintsWithStatus_messageType) Zero() protoreflect.Message {
	return (*fastReflection_ComplaintsWithStatus)(nil)
}
func (x fastReflection_ComplaintsWithStatus_messageType) New() protoreflect.Message {
	return new(fastReflection_ComplaintsWithStatus)
}
func (x fastReflection_ComplaintsWithStatus_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_ComplaintsWithStatus
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_ComplaintsWithStatus) Descriptor() protoreflect.MessageDescriptor {
	return md_ComplaintsWithStatus
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_ComplaintsWithStatus) Type() protoreflect.MessageType {
	return _fastReflection_ComplaintsWithStatus_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_ComplaintsWithStatus) New() protoreflect.Message {
	return new(fastReflection_ComplaintsWithStatus)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_ComplaintsWithStatus) Interface() protoreflect.ProtoMessage {
	return (*ComplaintsWithStatus)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_ComplaintsWithStatus) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.MemberId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.MemberId)
		if !f(fd_ComplaintsWithStatus_member_id, value) {
			return
		}
	}
	if len(x.ComplaintsWithStatus) != 0 {
		value := protoreflect.ValueOfList(&_ComplaintsWithStatus_2_list{list: &x.ComplaintsWithStatus})
		if !f(fd_ComplaintsWithStatus_complaints_with_status, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_ComplaintsWithStatus) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "band.tss.v1beta1.ComplaintsWithStatus.member_id":
		return x.MemberId != uint64(0)
	case "band.tss.v1beta1.ComplaintsWithStatus.complaints_with_status":
		return len(x.ComplaintsWithStatus) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.ComplaintsWithStatus"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.ComplaintsWithStatus does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ComplaintsWithStatus) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "band.tss.v1beta1.ComplaintsWithStatus.member_id":
		x.MemberId = uint64(0)
	case "band.tss.v1beta1.ComplaintsWithStatus.complaints_with_status":
		x.ComplaintsWithStatus = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.ComplaintsWithStatus"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.ComplaintsWithStatus does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_ComplaintsWithStatus) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "band.tss.v1beta1.ComplaintsWithStatus.member_id":
		value := x.MemberId
		return protoreflect.ValueOfUint64(value)
	case "band.tss.v1beta1.ComplaintsWithStatus.complaints_with_status":
		if len(x.ComplaintsWithStatus) == 0 {
			return protoreflect.ValueOfList(&_ComplaintsWithStatus_2_list{})
		}
		listValue := &_ComplaintsWithStatus_2_list{list: &x.ComplaintsWithStatus}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.ComplaintsWithStatus"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.ComplaintsWithStatus does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ComplaintsWithStatus) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "band.tss.v1beta1.ComplaintsWithStatus.member_id":
		x.MemberId = value.Uint()
	case "band.tss.v1beta1.ComplaintsWithStatus.complaints_with_status":
		lv := value.List()
		clv := lv.(*_ComplaintsWithStatus_2_list)
		x.ComplaintsWithStatus = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.ComplaintsWithStatus"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.ComplaintsWithStatus does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ComplaintsWithStatus) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.ComplaintsWithStatus.complaints_with_status":
		if x.ComplaintsWithStatus == nil {
			x.ComplaintsWithStatus = []*ComplaintWithStatus{}
		}
		value := &_ComplaintsWithStatus_2_list{list: &x.ComplaintsWithStatus}
		return protoreflect.ValueOfList(value)
	case "band.tss.v1beta1.ComplaintsWithStatus.member_id":
		panic(fmt.Errorf("field member_id of message band.tss.v1beta1.ComplaintsWithStatus is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.ComplaintsWithStatus"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.ComplaintsWithStatus does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_ComplaintsWithStatus) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.ComplaintsWithStatus.member_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "band.tss.v1beta1.ComplaintsWithStatus.complaints_with_status":
		list := []*ComplaintWithStatus{}
		return protoreflect.ValueOfList(&_ComplaintsWithStatus_2_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.ComplaintsWithStatus"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.ComplaintsWithStatus does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_ComplaintsWithStatus) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in band.tss.v1beta1.ComplaintsWithStatus", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_ComplaintsWithStatus) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ComplaintsWithStatus) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_ComplaintsWithStatus) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_ComplaintsWithStatus) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*ComplaintsWithStatus)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.MemberId != 0 {
			n += 1 + runtime.Sov(uint64(x.MemberId))
		}
		if len(x.ComplaintsWithStatus) > 0 {
			for _, e := range x.ComplaintsWithStatus {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*ComplaintsWithStatus)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.ComplaintsWithStatus) > 0 {
			for iNdEx := len(x.ComplaintsWithStatus) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.ComplaintsWithStatus[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x12
			}
		}
		if x.MemberId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MemberId))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*ComplaintsWithStatus)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ComplaintsWithStatus: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ComplaintsWithStatus: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MemberId", wireType)
				}
				x.MemberId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MemberId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ComplaintsWithStatus", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ComplaintsWithStatus = append(x.ComplaintsWithStatus, &ComplaintWithStatus{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ComplaintsWithStatus[len(x.ComplaintsWithStatus)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_PendingProcessGroups_1_list)(nil)

type _PendingProcessGroups_1_list struct {
	list *[]uint64
}

func (x *_PendingProcessGroups_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_PendingProcessGroups_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfUint64((*x.list)[i])
}

func (x *_PendingProcessGroups_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Uint()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_PendingProcessGroups_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Uint()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_PendingProcessGroups_1_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message PendingProcessGroups at list field GroupIds as it is not of Message kind"))
}

func (x *_PendingProcessGroups_1_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_PendingProcessGroups_1_list) NewElement() protoreflect.Value {
	v := uint64(0)
	return protoreflect.ValueOfUint64(v)
}

func (x *_PendingProcessGroups_1_list) IsValid() bool {
	return x.list != nil
}

var (
	md_PendingProcessGroups           protoreflect.MessageDescriptor
	fd_PendingProcessGroups_group_ids protoreflect.FieldDescriptor
)

func init() {
	file_band_tss_v1beta1_tss_proto_init()
	md_PendingProcessGroups = File_band_tss_v1beta1_tss_proto.Messages().ByName("PendingProcessGroups")
	fd_PendingProcessGroups_group_ids = md_PendingProcessGroups.Fields().ByName("group_ids")
}

var _ protoreflect.Message = (*fastReflection_PendingProcessGroups)(nil)

type fastReflection_PendingProcessGroups PendingProcessGroups

func (x *PendingProcessGroups) ProtoReflect() protoreflect.Message {
	return (*fastReflection_PendingProcessGroups)(x)
}

func (x *PendingProcessGroups) slowProtoReflect() protoreflect.Message {
	mi := &file_band_tss_v1beta1_tss_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_PendingProcessGroups_messageType fastReflection_PendingProcessGroups_messageType
var _ protoreflect.MessageType = fastReflection_PendingProcessGroups_messageType{}

type fastReflection_PendingProcessGroups_messageType struct{}

func (x fastReflection_PendingProcessGroups_messageType) Zero() protoreflect.Message {
	return (*fastReflection_PendingProcessGroups)(nil)
}
func (x fastReflection_PendingProcessGroups_messageType) New() protoreflect.Message {
	return new(fastReflection_PendingProcessGroups)
}
func (x fastReflection_PendingProcessGroups_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_PendingProcessGroups
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_PendingProcessGroups) Descriptor() protoreflect.MessageDescriptor {
	return md_PendingProcessGroups
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_PendingProcessGroups) Type() protoreflect.MessageType {
	return _fastReflection_PendingProcessGroups_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_PendingProcessGroups) New() protoreflect.Message {
	return new(fastReflection_PendingProcessGroups)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_PendingProcessGroups) Interface() protoreflect.ProtoMessage {
	return (*PendingProcessGroups)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_PendingProcessGroups) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.GroupIds) != 0 {
		value := protoreflect.ValueOfList(&_PendingProcessGroups_1_list{list: &x.GroupIds})
		if !f(fd_PendingProcessGroups_group_ids, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_PendingProcessGroups) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "band.tss.v1beta1.PendingProcessGroups.group_ids":
		return len(x.GroupIds) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.PendingProcessGroups"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.PendingProcessGroups does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PendingProcessGroups) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "band.tss.v1beta1.PendingProcessGroups.group_ids":
		x.GroupIds = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.PendingProcessGroups"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.PendingProcessGroups does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_PendingProcessGroups) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "band.tss.v1beta1.PendingProcessGroups.group_ids":
		if len(x.GroupIds) == 0 {
			return protoreflect.ValueOfList(&_PendingProcessGroups_1_list{})
		}
		listValue := &_PendingProcessGroups_1_list{list: &x.GroupIds}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.PendingProcessGroups"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.PendingProcessGroups does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PendingProcessGroups) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "band.tss.v1beta1.PendingProcessGroups.group_ids":
		lv := value.List()
		clv := lv.(*_PendingProcessGroups_1_list)
		x.GroupIds = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.PendingProcessGroups"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.PendingProcessGroups does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PendingProcessGroups) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.PendingProcessGroups.group_ids":
		if x.GroupIds == nil {
			x.GroupIds = []uint64{}
		}
		value := &_PendingProcessGroups_1_list{list: &x.GroupIds}
		return protoreflect.ValueOfList(value)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.PendingProcessGroups"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.PendingProcessGroups does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_PendingProcessGroups) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.PendingProcessGroups.group_ids":
		list := []uint64{}
		return protoreflect.ValueOfList(&_PendingProcessGroups_1_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.PendingProcessGroups"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.PendingProcessGroups does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_PendingProcessGroups) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in band.tss.v1beta1.PendingProcessGroups", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_PendingProcessGroups) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PendingProcessGroups) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_PendingProcessGroups) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_PendingProcessGroups) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*PendingProcessGroups)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.GroupIds) > 0 {
			l = 0
			for _, e := range x.GroupIds {
				l += runtime.Sov(uint64(e))
			}
			n += 1 + runtime.Sov(uint64(l)) + l
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*PendingProcessGroups)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.GroupIds) > 0 {
			var pksize2 int
			for _, num := range x.GroupIds {
				pksize2 += runtime.Sov(uint64(num))
			}
			i -= pksize2
			j1 := i
			for _, num := range x.GroupIds {
				for num >= 1<<7 {
					dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j1++
				}
				dAtA[j1] = uint8(num)
				j1++
			}
			i = runtime.EncodeVarint(dAtA, i, uint64(pksize2))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*PendingProcessGroups)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PendingProcessGroups: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PendingProcessGroups: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType == 0 {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
						}
						if iNdEx >= l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					x.GroupIds = append(x.GroupIds, v)
				} else if wireType == 2 {
					var packedLen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
						}
						if iNdEx >= l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						packedLen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if packedLen < 0 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
					}
					postIndex := iNdEx + packedLen
					if postIndex < 0 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
					}
					if postIndex > l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					var elementCount int
					var count int
					for _, integer := range dAtA[iNdEx:postIndex] {
						if integer < 128 {
							count++
						}
					}
					elementCount = count
					if elementCount != 0 && len(x.GroupIds) == 0 {
						x.GroupIds = make([]uint64, 0, elementCount)
					}
					for iNdEx < postIndex {
						var v uint64
						for shift := uint(0); ; shift += 7 {
							if shift >= 64 {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
							}
							if iNdEx >= l {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
							}
							b := dAtA[iNdEx]
							iNdEx++
							v |= uint64(b&0x7F) << shift
							if b < 0x80 {
								break
							}
						}
						x.GroupIds = append(x.GroupIds, v)
					}
				} else {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field GroupIds", wireType)
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_PendingProcessSignings_1_list)(nil)

type _PendingProcessSignings_1_list struct {
	list *[]uint64
}

func (x *_PendingProcessSignings_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_PendingProcessSignings_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfUint64((*x.list)[i])
}

func (x *_PendingProcessSignings_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Uint()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_PendingProcessSignings_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Uint()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_PendingProcessSignings_1_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message PendingProcessSignings at list field SigningIds as it is not of Message kind"))
}

func (x *_PendingProcessSignings_1_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_PendingProcessSignings_1_list) NewElement() protoreflect.Value {
	v := uint64(0)
	return protoreflect.ValueOfUint64(v)
}

func (x *_PendingProcessSignings_1_list) IsValid() bool {
	return x.list != nil
}

var (
	md_PendingProcessSignings             protoreflect.MessageDescriptor
	fd_PendingProcessSignings_signing_ids protoreflect.FieldDescriptor
)

func init() {
	file_band_tss_v1beta1_tss_proto_init()
	md_PendingProcessSignings = File_band_tss_v1beta1_tss_proto.Messages().ByName("PendingProcessSignings")
	fd_PendingProcessSignings_signing_ids = md_PendingProcessSignings.Fields().ByName("signing_ids")
}

var _ protoreflect.Message = (*fastReflection_PendingProcessSignings)(nil)

type fastReflection_PendingProcessSignings PendingProcessSignings

func (x *PendingProcessSignings) ProtoReflect() protoreflect.Message {
	return (*fastReflection_PendingProcessSignings)(x)
}

func (x *PendingProcessSignings) slowProtoReflect() protoreflect.Message {
	mi := &file_band_tss_v1beta1_tss_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_PendingProcessSignings_messageType fastReflection_PendingProcessSignings_messageType
var _ protoreflect.MessageType = fastReflection_PendingProcessSignings_messageType{}

type fastReflection_PendingProcessSignings_messageType struct{}

func (x fastReflection_PendingProcessSignings_messageType) Zero() protoreflect.Message {
	return (*fastReflection_PendingProcessSignings)(nil)
}
func (x fastReflection_PendingProcessSignings_messageType) New() protoreflect.Message {
	return new(fastReflection_PendingProcessSignings)
}
func (x fastReflection_PendingProcessSignings_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_PendingProcessSignings
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_PendingProcessSignings) Descriptor() protoreflect.MessageDescriptor {
	return md_PendingProcessSignings
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_PendingProcessSignings) Type() protoreflect.MessageType {
	return _fastReflection_PendingProcessSignings_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_PendingProcessSignings) New() protoreflect.Message {
	return new(fastReflection_PendingProcessSignings)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_PendingProcessSignings) Interface() protoreflect.ProtoMessage {
	return (*PendingProcessSignings)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_PendingProcessSignings) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.SigningIds) != 0 {
		value := protoreflect.ValueOfList(&_PendingProcessSignings_1_list{list: &x.SigningIds})
		if !f(fd_PendingProcessSignings_signing_ids, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_PendingProcessSignings) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "band.tss.v1beta1.PendingProcessSignings.signing_ids":
		return len(x.SigningIds) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.PendingProcessSignings"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.PendingProcessSignings does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PendingProcessSignings) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "band.tss.v1beta1.PendingProcessSignings.signing_ids":
		x.SigningIds = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.PendingProcessSignings"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.PendingProcessSignings does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_PendingProcessSignings) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "band.tss.v1beta1.PendingProcessSignings.signing_ids":
		if len(x.SigningIds) == 0 {
			return protoreflect.ValueOfList(&_PendingProcessSignings_1_list{})
		}
		listValue := &_PendingProcessSignings_1_list{list: &x.SigningIds}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.PendingProcessSignings"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.PendingProcessSignings does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PendingProcessSignings) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "band.tss.v1beta1.PendingProcessSignings.signing_ids":
		lv := value.List()
		clv := lv.(*_PendingProcessSignings_1_list)
		x.SigningIds = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.PendingProcessSignings"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.PendingProcessSignings does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PendingProcessSignings) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.PendingProcessSignings.signing_ids":
		if x.SigningIds == nil {
			x.SigningIds = []uint64{}
		}
		value := &_PendingProcessSignings_1_list{list: &x.SigningIds}
		return protoreflect.ValueOfList(value)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.PendingProcessSignings"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.PendingProcessSignings does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_PendingProcessSignings) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.PendingProcessSignings.signing_ids":
		list := []uint64{}
		return protoreflect.ValueOfList(&_PendingProcessSignings_1_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.PendingProcessSignings"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.PendingProcessSignings does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_PendingProcessSignings) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in band.tss.v1beta1.PendingProcessSignings", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_PendingProcessSignings) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PendingProcessSignings) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_PendingProcessSignings) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_PendingProcessSignings) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*PendingProcessSignings)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.SigningIds) > 0 {
			l = 0
			for _, e := range x.SigningIds {
				l += runtime.Sov(uint64(e))
			}
			n += 1 + runtime.Sov(uint64(l)) + l
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*PendingProcessSignings)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.SigningIds) > 0 {
			var pksize2 int
			for _, num := range x.SigningIds {
				pksize2 += runtime.Sov(uint64(num))
			}
			i -= pksize2
			j1 := i
			for _, num := range x.SigningIds {
				for num >= 1<<7 {
					dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j1++
				}
				dAtA[j1] = uint8(num)
				j1++
			}
			i = runtime.EncodeVarint(dAtA, i, uint64(pksize2))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*PendingProcessSignings)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PendingProcessSignings: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PendingProcessSignings: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType == 0 {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
						}
						if iNdEx >= l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					x.SigningIds = append(x.SigningIds, v)
				} else if wireType == 2 {
					var packedLen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
						}
						if iNdEx >= l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						packedLen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if packedLen < 0 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
					}
					postIndex := iNdEx + packedLen
					if postIndex < 0 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
					}
					if postIndex > l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					var elementCount int
					var count int
					for _, integer := range dAtA[iNdEx:postIndex] {
						if integer < 128 {
							count++
						}
					}
					elementCount = count
					if elementCount != 0 && len(x.SigningIds) == 0 {
						x.SigningIds = make([]uint64, 0, elementCount)
					}
					for iNdEx < postIndex {
						var v uint64
						for shift := uint(0); ; shift += 7 {
							if shift >= 64 {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
							}
							if iNdEx >= l {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
							}
							b := dAtA[iNdEx]
							iNdEx++
							v |= uint64(b&0x7F) << shift
							if b < 0x80 {
								break
							}
						}
						x.SigningIds = append(x.SigningIds, v)
					}
				} else {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SigningIds", wireType)
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_PartialSignature                 protoreflect.MessageDescriptor
	fd_PartialSignature_signing_id      protoreflect.FieldDescriptor
	fd_PartialSignature_signing_attempt protoreflect.FieldDescriptor
	fd_PartialSignature_member_id       protoreflect.FieldDescriptor
	fd_PartialSignature_signature       protoreflect.FieldDescriptor
)

func init() {
	file_band_tss_v1beta1_tss_proto_init()
	md_PartialSignature = File_band_tss_v1beta1_tss_proto.Messages().ByName("PartialSignature")
	fd_PartialSignature_signing_id = md_PartialSignature.Fields().ByName("signing_id")
	fd_PartialSignature_signing_attempt = md_PartialSignature.Fields().ByName("signing_attempt")
	fd_PartialSignature_member_id = md_PartialSignature.Fields().ByName("member_id")
	fd_PartialSignature_signature = md_PartialSignature.Fields().ByName("signature")
}

var _ protoreflect.Message = (*fastReflection_PartialSignature)(nil)

type fastReflection_PartialSignature PartialSignature

func (x *PartialSignature) ProtoReflect() protoreflect.Message {
	return (*fastReflection_PartialSignature)(x)
}

func (x *PartialSignature) slowProtoReflect() protoreflect.Message {
	mi := &file_band_tss_v1beta1_tss_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_PartialSignature_messageType fastReflection_PartialSignature_messageType
var _ protoreflect.MessageType = fastReflection_PartialSignature_messageType{}

type fastReflection_PartialSignature_messageType struct{}

func (x fastReflection_PartialSignature_messageType) Zero() protoreflect.Message {
	return (*fastReflection_PartialSignature)(nil)
}
func (x fastReflection_PartialSignature_messageType) New() protoreflect.Message {
	return new(fastReflection_PartialSignature)
}
func (x fastReflection_PartialSignature_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_PartialSignature
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_PartialSignature) Descriptor() protoreflect.MessageDescriptor {
	return md_PartialSignature
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_PartialSignature) Type() protoreflect.MessageType {
	return _fastReflection_PartialSignature_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_PartialSignature) New() protoreflect.Message {
	return new(fastReflection_PartialSignature)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_PartialSignature) Interface() protoreflect.ProtoMessage {
	return (*PartialSignature)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_PartialSignature) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.SigningId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.SigningId)
		if !f(fd_PartialSignature_signing_id, value) {
			return
		}
	}
	if x.SigningAttempt != uint64(0) {
		value := protoreflect.ValueOfUint64(x.SigningAttempt)
		if !f(fd_PartialSignature_signing_attempt, value) {
			return
		}
	}
	if x.MemberId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.MemberId)
		if !f(fd_PartialSignature_member_id, value) {
			return
		}
	}
	if len(x.Signature) != 0 {
		value := protoreflect.ValueOfBytes(x.Signature)
		if !f(fd_PartialSignature_signature, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_PartialSignature) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "band.tss.v1beta1.PartialSignature.signing_id":
		return x.SigningId != uint64(0)
	case "band.tss.v1beta1.PartialSignature.signing_attempt":
		return x.SigningAttempt != uint64(0)
	case "band.tss.v1beta1.PartialSignature.member_id":
		return x.MemberId != uint64(0)
	case "band.tss.v1beta1.PartialSignature.signature":
		return len(x.Signature) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.PartialSignature"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.PartialSignature does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PartialSignature) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "band.tss.v1beta1.PartialSignature.signing_id":
		x.SigningId = uint64(0)
	case "band.tss.v1beta1.PartialSignature.signing_attempt":
		x.SigningAttempt = uint64(0)
	case "band.tss.v1beta1.PartialSignature.member_id":
		x.MemberId = uint64(0)
	case "band.tss.v1beta1.PartialSignature.signature":
		x.Signature = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.PartialSignature"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.PartialSignature does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_PartialSignature) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "band.tss.v1beta1.PartialSignature.signing_id":
		value := x.SigningId
		return protoreflect.ValueOfUint64(value)
	case "band.tss.v1beta1.PartialSignature.signing_attempt":
		value := x.SigningAttempt
		return protoreflect.ValueOfUint64(value)
	case "band.tss.v1beta1.PartialSignature.member_id":
		value := x.MemberId
		return protoreflect.ValueOfUint64(value)
	case "band.tss.v1beta1.PartialSignature.signature":
		value := x.Signature
		return protoreflect.ValueOfBytes(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.PartialSignature"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.PartialSignature does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PartialSignature) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "band.tss.v1beta1.PartialSignature.signing_id":
		x.SigningId = value.Uint()
	case "band.tss.v1beta1.PartialSignature.signing_attempt":
		x.SigningAttempt = value.Uint()
	case "band.tss.v1beta1.PartialSignature.member_id":
		x.MemberId = value.Uint()
	case "band.tss.v1beta1.PartialSignature.signature":
		x.Signature = value.Bytes()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.PartialSignature"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.PartialSignature does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PartialSignature) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.PartialSignature.signing_id":
		panic(fmt.Errorf("field signing_id of message band.tss.v1beta1.PartialSignature is not mutable"))
	case "band.tss.v1beta1.PartialSignature.signing_attempt":
		panic(fmt.Errorf("field signing_attempt of message band.tss.v1beta1.PartialSignature is not mutable"))
	case "band.tss.v1beta1.PartialSignature.member_id":
		panic(fmt.Errorf("field member_id of message band.tss.v1beta1.PartialSignature is not mutable"))
	case "band.tss.v1beta1.PartialSignature.signature":
		panic(fmt.Errorf("field signature of message band.tss.v1beta1.PartialSignature is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.PartialSignature"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.PartialSignature does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_PartialSignature) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.PartialSignature.signing_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "band.tss.v1beta1.PartialSignature.signing_attempt":
		return protoreflect.ValueOfUint64(uint64(0))
	case "band.tss.v1beta1.PartialSignature.member_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "band.tss.v1beta1.PartialSignature.signature":
		return protoreflect.ValueOfBytes(nil)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.PartialSignature"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.PartialSignature does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_PartialSignature) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in band.tss.v1beta1.PartialSignature", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_PartialSignature) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PartialSignature) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_PartialSignature) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_PartialSignature) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*PartialSignature)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.SigningId != 0 {
			n += 1 + runtime.Sov(uint64(x.SigningId))
		}
		if x.SigningAttempt != 0 {
			n += 1 + runtime.Sov(uint64(x.SigningAttempt))
		}
		if x.MemberId != 0 {
			n += 1 + runtime.Sov(uint64(x.MemberId))
		}
		l = len(x.Signature)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*PartialSignature)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Signature) > 0 {
			i -= len(x.Signature)
			copy(dAtA[i:], x.Signature)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Signature)))
			i--
			dAtA[i] = 0x22
		}
		if x.MemberId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MemberId))
			i--
			dAtA[i] = 0x18
		}
		if x.SigningAttempt != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.SigningAttempt))
			i--
			dAtA[i] = 0x10
		}
		if x.SigningId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.SigningId))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*PartialSignature)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PartialSignature: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PartialSignature: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SigningId", wireType)
				}
				x.SigningId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.SigningId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SigningAttempt", wireType)
				}
				x.SigningAttempt = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.SigningAttempt |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MemberId", wireType)
				}
				x.MemberId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MemberId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Signature = append(x.Signature[:0], dAtA[iNdEx:postIndex]...)
				if x.Signature == nil {
					x.Signature = []byte{}
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_TextSignatureOrder         protoreflect.MessageDescriptor
	fd_TextSignatureOrder_message protoreflect.FieldDescriptor
)

func init() {
	file_band_tss_v1beta1_tss_proto_init()
	md_TextSignatureOrder = File_band_tss_v1beta1_tss_proto.Messages().ByName("TextSignatureOrder")
	fd_TextSignatureOrder_message = md_TextSignatureOrder.Fields().ByName("message")
}

var _ protoreflect.Message = (*fastReflection_TextSignatureOrder)(nil)

type fastReflection_TextSignatureOrder TextSignatureOrder

func (x *TextSignatureOrder) ProtoReflect() protoreflect.Message {
	return (*fastReflection_TextSignatureOrder)(x)
}

func (x *TextSignatureOrder) slowProtoReflect() protoreflect.Message {
	mi := &file_band_tss_v1beta1_tss_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_TextSignatureOrder_messageType fastReflection_TextSignatureOrder_messageType
var _ protoreflect.MessageType = fastReflection_TextSignatureOrder_messageType{}

type fastReflection_TextSignatureOrder_messageType struct{}

func (x fastReflection_TextSignatureOrder_messageType) Zero() protoreflect.Message {
	return (*fastReflection_TextSignatureOrder)(nil)
}
func (x fastReflection_TextSignatureOrder_messageType) New() protoreflect.Message {
	return new(fastReflection_TextSignatureOrder)
}
func (x fastReflection_TextSignatureOrder_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_TextSignatureOrder
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_TextSignatureOrder) Descriptor() protoreflect.MessageDescriptor {
	return md_TextSignatureOrder
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_TextSignatureOrder) Type() protoreflect.MessageType {
	return _fastReflection_TextSignatureOrder_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_TextSignatureOrder) New() protoreflect.Message {
	return new(fastReflection_TextSignatureOrder)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_TextSignatureOrder) Interface() protoreflect.ProtoMessage {
	return (*TextSignatureOrder)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_TextSignatureOrder) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.Message) != 0 {
		value := protoreflect.ValueOfBytes(x.Message)
		if !f(fd_TextSignatureOrder_message, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_TextSignatureOrder) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "band.tss.v1beta1.TextSignatureOrder.message":
		return len(x.Message) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.TextSignatureOrder"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.TextSignatureOrder does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_TextSignatureOrder) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "band.tss.v1beta1.TextSignatureOrder.message":
		x.Message = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.TextSignatureOrder"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.TextSignatureOrder does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_TextSignatureOrder) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "band.tss.v1beta1.TextSignatureOrder.message":
		value := x.Message
		return protoreflect.ValueOfBytes(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.TextSignatureOrder"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.TextSignatureOrder does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_TextSignatureOrder) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "band.tss.v1beta1.TextSignatureOrder.message":
		x.Message = value.Bytes()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.TextSignatureOrder"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.TextSignatureOrder does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_TextSignatureOrder) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.TextSignatureOrder.message":
		panic(fmt.Errorf("field message of message band.tss.v1beta1.TextSignatureOrder is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.TextSignatureOrder"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.TextSignatureOrder does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_TextSignatureOrder) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.TextSignatureOrder.message":
		return protoreflect.ValueOfBytes(nil)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.TextSignatureOrder"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.TextSignatureOrder does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_TextSignatureOrder) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in band.tss.v1beta1.TextSignatureOrder", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_TextSignatureOrder) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_TextSignatureOrder) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_TextSignatureOrder) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_TextSignatureOrder) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*TextSignatureOrder)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Message)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*TextSignatureOrder)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Message) > 0 {
			i -= len(x.Message)
			copy(dAtA[i:], x.Message)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Message)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*TextSignatureOrder)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: TextSignatureOrder: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: TextSignatureOrder: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Message = append(x.Message[:0], dAtA[iNdEx:postIndex]...)
				if x.Message == nil {
					x.Message = []byte{}
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EVMSignature           protoreflect.MessageDescriptor
	fd_EVMSignature_r_address protoreflect.FieldDescriptor
	fd_EVMSignature_signature protoreflect.FieldDescriptor
)

func init() {
	file_band_tss_v1beta1_tss_proto_init()
	md_EVMSignature = File_band_tss_v1beta1_tss_proto.Messages().ByName("EVMSignature")
	fd_EVMSignature_r_address = md_EVMSignature.Fields().ByName("r_address")
	fd_EVMSignature_signature = md_EVMSignature.Fields().ByName("signature")
}

var _ protoreflect.Message = (*fastReflection_EVMSignature)(nil)

type fastReflection_EVMSignature EVMSignature

func (x *EVMSignature) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EVMSignature)(x)
}

func (x *EVMSignature) slowProtoReflect() protoreflect.Message {
	mi := &file_band_tss_v1beta1_tss_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EVMSignature_messageType fastReflection_EVMSignature_messageType
var _ protoreflect.MessageType = fastReflection_EVMSignature_messageType{}

type fastReflection_EVMSignature_messageType struct{}

func (x fastReflection_EVMSignature_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EVMSignature)(nil)
}
func (x fastReflection_EVMSignature_messageType) New() protoreflect.Message {
	return new(fastReflection_EVMSignature)
}
func (x fastReflection_EVMSignature_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EVMSignature
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EVMSignature) Descriptor() protoreflect.MessageDescriptor {
	return md_EVMSignature
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EVMSignature) Type() protoreflect.MessageType {
	return _fastReflection_EVMSignature_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EVMSignature) New() protoreflect.Message {
	return new(fastReflection_EVMSignature)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EVMSignature) Interface() protoreflect.ProtoMessage {
	return (*EVMSignature)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EVMSignature) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.RAddress) != 0 {
		value := protoreflect.ValueOfBytes(x.RAddress)
		if !f(fd_EVMSignature_r_address, value) {
			return
		}
	}
	if len(x.Signature) != 0 {
		value := protoreflect.ValueOfBytes(x.Signature)
		if !f(fd_EVMSignature_signature, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EVMSignature) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "band.tss.v1beta1.EVMSignature.r_address":
		return len(x.RAddress) != 0
	case "band.tss.v1beta1.EVMSignature.signature":
		return len(x.Signature) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.EVMSignature"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.EVMSignature does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EVMSignature) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "band.tss.v1beta1.EVMSignature.r_address":
		x.RAddress = nil
	case "band.tss.v1beta1.EVMSignature.signature":
		x.Signature = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.EVMSignature"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.EVMSignature does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EVMSignature) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "band.tss.v1beta1.EVMSignature.r_address":
		value := x.RAddress
		return protoreflect.ValueOfBytes(value)
	case "band.tss.v1beta1.EVMSignature.signature":
		value := x.Signature
		return protoreflect.ValueOfBytes(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.EVMSignature"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.EVMSignature does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EVMSignature) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "band.tss.v1beta1.EVMSignature.r_address":
		x.RAddress = value.Bytes()
	case "band.tss.v1beta1.EVMSignature.signature":
		x.Signature = value.Bytes()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.EVMSignature"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.EVMSignature does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EVMSignature) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.EVMSignature.r_address":
		panic(fmt.Errorf("field r_address of message band.tss.v1beta1.EVMSignature is not mutable"))
	case "band.tss.v1beta1.EVMSignature.signature":
		panic(fmt.Errorf("field signature of message band.tss.v1beta1.EVMSignature is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.EVMSignature"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.EVMSignature does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EVMSignature) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.EVMSignature.r_address":
		return protoreflect.ValueOfBytes(nil)
	case "band.tss.v1beta1.EVMSignature.signature":
		return protoreflect.ValueOfBytes(nil)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.EVMSignature"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.EVMSignature does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EVMSignature) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in band.tss.v1beta1.EVMSignature", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EVMSignature) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EVMSignature) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EVMSignature) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EVMSignature) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EVMSignature)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.RAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Signature)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EVMSignature)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Signature) > 0 {
			i -= len(x.Signature)
			copy(dAtA[i:], x.Signature)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Signature)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.RAddress) > 0 {
			i -= len(x.RAddress)
			copy(dAtA[i:], x.RAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RAddress)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EVMSignature)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EVMSignature: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EVMSignature: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RAddress", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RAddress = append(x.RAddress[:0], dAtA[iNdEx:postIndex]...)
				if x.RAddress == nil {
					x.RAddress = []byte{}
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Signature = append(x.Signature[:0], dAtA[iNdEx:postIndex]...)
				if x.Signature == nil {
					x.Signature = []byte{}
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_SigningResult_4_list)(nil)

type _SigningResult_4_list struct {
	list *[]*PartialSignature
}

func (x *_SigningResult_4_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_SigningResult_4_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_SigningResult_4_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*PartialSignature)
	(*x.list)[i] = concreteValue
}

func (x *_SigningResult_4_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*PartialSignature)
	*x.list = append(*x.list, concreteValue)
}

func (x *_SigningResult_4_list) AppendMutable() protoreflect.Value {
	v := new(PartialSignature)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_SigningResult_4_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_SigningResult_4_list) NewElement() protoreflect.Value {
	v := new(PartialSignature)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_SigningResult_4_list) IsValid() bool {
	return x.list != nil
}

var (
	md_SigningResult                             protoreflect.MessageDescriptor
	fd_SigningResult_signing                     protoreflect.FieldDescriptor
	fd_SigningResult_current_signing_attempt     protoreflect.FieldDescriptor
	fd_SigningResult_evm_signature               protoreflect.FieldDescriptor
	fd_SigningResult_received_partial_signatures protoreflect.FieldDescriptor
)

func init() {
	file_band_tss_v1beta1_tss_proto_init()
	md_SigningResult = File_band_tss_v1beta1_tss_proto.Messages().ByName("SigningResult")
	fd_SigningResult_signing = md_SigningResult.Fields().ByName("signing")
	fd_SigningResult_current_signing_attempt = md_SigningResult.Fields().ByName("current_signing_attempt")
	fd_SigningResult_evm_signature = md_SigningResult.Fields().ByName("evm_signature")
	fd_SigningResult_received_partial_signatures = md_SigningResult.Fields().ByName("received_partial_signatures")
}

var _ protoreflect.Message = (*fastReflection_SigningResult)(nil)

type fastReflection_SigningResult SigningResult

func (x *SigningResult) ProtoReflect() protoreflect.Message {
	return (*fastReflection_SigningResult)(x)
}

func (x *SigningResult) slowProtoReflect() protoreflect.Message {
	mi := &file_band_tss_v1beta1_tss_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_SigningResult_messageType fastReflection_SigningResult_messageType
var _ protoreflect.MessageType = fastReflection_SigningResult_messageType{}

type fastReflection_SigningResult_messageType struct{}

func (x fastReflection_SigningResult_messageType) Zero() protoreflect.Message {
	return (*fastReflection_SigningResult)(nil)
}
func (x fastReflection_SigningResult_messageType) New() protoreflect.Message {
	return new(fastReflection_SigningResult)
}
func (x fastReflection_SigningResult_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_SigningResult
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_SigningResult) Descriptor() protoreflect.MessageDescriptor {
	return md_SigningResult
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_SigningResult) Type() protoreflect.MessageType {
	return _fastReflection_SigningResult_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_SigningResult) New() protoreflect.Message {
	return new(fastReflection_SigningResult)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_SigningResult) Interface() protoreflect.ProtoMessage {
	return (*SigningResult)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_SigningResult) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Signing != nil {
		value := protoreflect.ValueOfMessage(x.Signing.ProtoReflect())
		if !f(fd_SigningResult_signing, value) {
			return
		}
	}
	if x.CurrentSigningAttempt != nil {
		value := protoreflect.ValueOfMessage(x.CurrentSigningAttempt.ProtoReflect())
		if !f(fd_SigningResult_current_signing_attempt, value) {
			return
		}
	}
	if x.EvmSignature != nil {
		value := protoreflect.ValueOfMessage(x.EvmSignature.ProtoReflect())
		if !f(fd_SigningResult_evm_signature, value) {
			return
		}
	}
	if len(x.ReceivedPartialSignatures) != 0 {
		value := protoreflect.ValueOfList(&_SigningResult_4_list{list: &x.ReceivedPartialSignatures})
		if !f(fd_SigningResult_received_partial_signatures, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_SigningResult) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "band.tss.v1beta1.SigningResult.signing":
		return x.Signing != nil
	case "band.tss.v1beta1.SigningResult.current_signing_attempt":
		return x.CurrentSigningAttempt != nil
	case "band.tss.v1beta1.SigningResult.evm_signature":
		return x.EvmSignature != nil
	case "band.tss.v1beta1.SigningResult.received_partial_signatures":
		return len(x.ReceivedPartialSignatures) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.SigningResult"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.SigningResult does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SigningResult) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "band.tss.v1beta1.SigningResult.signing":
		x.Signing = nil
	case "band.tss.v1beta1.SigningResult.current_signing_attempt":
		x.CurrentSigningAttempt = nil
	case "band.tss.v1beta1.SigningResult.evm_signature":
		x.EvmSignature = nil
	case "band.tss.v1beta1.SigningResult.received_partial_signatures":
		x.ReceivedPartialSignatures = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.SigningResult"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.SigningResult does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_SigningResult) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "band.tss.v1beta1.SigningResult.signing":
		value := x.Signing
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "band.tss.v1beta1.SigningResult.current_signing_attempt":
		value := x.CurrentSigningAttempt
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "band.tss.v1beta1.SigningResult.evm_signature":
		value := x.EvmSignature
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "band.tss.v1beta1.SigningResult.received_partial_signatures":
		if len(x.ReceivedPartialSignatures) == 0 {
			return protoreflect.ValueOfList(&_SigningResult_4_list{})
		}
		listValue := &_SigningResult_4_list{list: &x.ReceivedPartialSignatures}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.SigningResult"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.SigningResult does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SigningResult) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "band.tss.v1beta1.SigningResult.signing":
		x.Signing = value.Message().Interface().(*Signing)
	case "band.tss.v1beta1.SigningResult.current_signing_attempt":
		x.CurrentSigningAttempt = value.Message().Interface().(*SigningAttempt)
	case "band.tss.v1beta1.SigningResult.evm_signature":
		x.EvmSignature = value.Message().Interface().(*EVMSignature)
	case "band.tss.v1beta1.SigningResult.received_partial_signatures":
		lv := value.List()
		clv := lv.(*_SigningResult_4_list)
		x.ReceivedPartialSignatures = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.SigningResult"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.SigningResult does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SigningResult) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.SigningResult.signing":
		if x.Signing == nil {
			x.Signing = new(Signing)
		}
		return protoreflect.ValueOfMessage(x.Signing.ProtoReflect())
	case "band.tss.v1beta1.SigningResult.current_signing_attempt":
		if x.CurrentSigningAttempt == nil {
			x.CurrentSigningAttempt = new(SigningAttempt)
		}
		return protoreflect.ValueOfMessage(x.CurrentSigningAttempt.ProtoReflect())
	case "band.tss.v1beta1.SigningResult.evm_signature":
		if x.EvmSignature == nil {
			x.EvmSignature = new(EVMSignature)
		}
		return protoreflect.ValueOfMessage(x.EvmSignature.ProtoReflect())
	case "band.tss.v1beta1.SigningResult.received_partial_signatures":
		if x.ReceivedPartialSignatures == nil {
			x.ReceivedPartialSignatures = []*PartialSignature{}
		}
		value := &_SigningResult_4_list{list: &x.ReceivedPartialSignatures}
		return protoreflect.ValueOfList(value)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.SigningResult"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.SigningResult does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_SigningResult) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.SigningResult.signing":
		m := new(Signing)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "band.tss.v1beta1.SigningResult.current_signing_attempt":
		m := new(SigningAttempt)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "band.tss.v1beta1.SigningResult.evm_signature":
		m := new(EVMSignature)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "band.tss.v1beta1.SigningResult.received_partial_signatures":
		list := []*PartialSignature{}
		return protoreflect.ValueOfList(&_SigningResult_4_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.SigningResult"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.SigningResult does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_SigningResult) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in band.tss.v1beta1.SigningResult", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_SigningResult) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SigningResult) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_SigningResult) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_SigningResult) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*SigningResult)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Signing != nil {
			l = options.Size(x.Signing)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.CurrentSigningAttempt != nil {
			l = options.Size(x.CurrentSigningAttempt)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.EvmSignature != nil {
			l = options.Size(x.EvmSignature)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.ReceivedPartialSignatures) > 0 {
			for _, e := range x.ReceivedPartialSignatures {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*SigningResult)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.ReceivedPartialSignatures) > 0 {
			for iNdEx := len(x.ReceivedPartialSignatures) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.ReceivedPartialSignatures[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x22
			}
		}
		if x.EvmSignature != nil {
			encoded, err := options.Marshal(x.EvmSignature)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if x.CurrentSigningAttempt != nil {
			encoded, err := options.Marshal(x.CurrentSigningAttempt)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if x.Signing != nil {
			encoded, err := options.Marshal(x.Signing)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*SigningResult)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: SigningResult: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: SigningResult: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Signing", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Signing == nil {
					x.Signing = &Signing{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Signing); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CurrentSigningAttempt", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.CurrentSigningAttempt == nil {
					x.CurrentSigningAttempt = &SigningAttempt{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.CurrentSigningAttempt); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field EvmSignature", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.EvmSignature == nil {
					x.EvmSignature = &EVMSignature{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.EvmSignature); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ReceivedPartialSignatures", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ReceivedPartialSignatures = append(x.ReceivedPartialSignatures, &PartialSignature{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ReceivedPartialSignatures[len(x.ReceivedPartialSignatures)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_SigningExpiration                 protoreflect.MessageDescriptor
	fd_SigningExpiration_signing_id      protoreflect.FieldDescriptor
	fd_SigningExpiration_signing_attempt protoreflect.FieldDescriptor
)

func init() {
	file_band_tss_v1beta1_tss_proto_init()
	md_SigningExpiration = File_band_tss_v1beta1_tss_proto.Messages().ByName("SigningExpiration")
	fd_SigningExpiration_signing_id = md_SigningExpiration.Fields().ByName("signing_id")
	fd_SigningExpiration_signing_attempt = md_SigningExpiration.Fields().ByName("signing_attempt")
}

var _ protoreflect.Message = (*fastReflection_SigningExpiration)(nil)

type fastReflection_SigningExpiration SigningExpiration

func (x *SigningExpiration) ProtoReflect() protoreflect.Message {
	return (*fastReflection_SigningExpiration)(x)
}

func (x *SigningExpiration) slowProtoReflect() protoreflect.Message {
	mi := &file_band_tss_v1beta1_tss_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_SigningExpiration_messageType fastReflection_SigningExpiration_messageType
var _ protoreflect.MessageType = fastReflection_SigningExpiration_messageType{}

type fastReflection_SigningExpiration_messageType struct{}

func (x fastReflection_SigningExpiration_messageType) Zero() protoreflect.Message {
	return (*fastReflection_SigningExpiration)(nil)
}
func (x fastReflection_SigningExpiration_messageType) New() protoreflect.Message {
	return new(fastReflection_SigningExpiration)
}
func (x fastReflection_SigningExpiration_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_SigningExpiration
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_SigningExpiration) Descriptor() protoreflect.MessageDescriptor {
	return md_SigningExpiration
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_SigningExpiration) Type() protoreflect.MessageType {
	return _fastReflection_SigningExpiration_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_SigningExpiration) New() protoreflect.Message {
	return new(fastReflection_SigningExpiration)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_SigningExpiration) Interface() protoreflect.ProtoMessage {
	return (*SigningExpiration)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_SigningExpiration) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.SigningId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.SigningId)
		if !f(fd_SigningExpiration_signing_id, value) {
			return
		}
	}
	if x.SigningAttempt != uint64(0) {
		value := protoreflect.ValueOfUint64(x.SigningAttempt)
		if !f(fd_SigningExpiration_signing_attempt, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_SigningExpiration) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "band.tss.v1beta1.SigningExpiration.signing_id":
		return x.SigningId != uint64(0)
	case "band.tss.v1beta1.SigningExpiration.signing_attempt":
		return x.SigningAttempt != uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.SigningExpiration"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.SigningExpiration does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SigningExpiration) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "band.tss.v1beta1.SigningExpiration.signing_id":
		x.SigningId = uint64(0)
	case "band.tss.v1beta1.SigningExpiration.signing_attempt":
		x.SigningAttempt = uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.SigningExpiration"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.SigningExpiration does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_SigningExpiration) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "band.tss.v1beta1.SigningExpiration.signing_id":
		value := x.SigningId
		return protoreflect.ValueOfUint64(value)
	case "band.tss.v1beta1.SigningExpiration.signing_attempt":
		value := x.SigningAttempt
		return protoreflect.ValueOfUint64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.SigningExpiration"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.SigningExpiration does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SigningExpiration) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "band.tss.v1beta1.SigningExpiration.signing_id":
		x.SigningId = value.Uint()
	case "band.tss.v1beta1.SigningExpiration.signing_attempt":
		x.SigningAttempt = value.Uint()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.SigningExpiration"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.SigningExpiration does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SigningExpiration) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.SigningExpiration.signing_id":
		panic(fmt.Errorf("field signing_id of message band.tss.v1beta1.SigningExpiration is not mutable"))
	case "band.tss.v1beta1.SigningExpiration.signing_attempt":
		panic(fmt.Errorf("field signing_attempt of message band.tss.v1beta1.SigningExpiration is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.SigningExpiration"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.SigningExpiration does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_SigningExpiration) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.SigningExpiration.signing_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "band.tss.v1beta1.SigningExpiration.signing_attempt":
		return protoreflect.ValueOfUint64(uint64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.SigningExpiration"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.SigningExpiration does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_SigningExpiration) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in band.tss.v1beta1.SigningExpiration", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_SigningExpiration) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SigningExpiration) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_SigningExpiration) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_SigningExpiration) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*SigningExpiration)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.SigningId != 0 {
			n += 1 + runtime.Sov(uint64(x.SigningId))
		}
		if x.SigningAttempt != 0 {
			n += 1 + runtime.Sov(uint64(x.SigningAttempt))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*SigningExpiration)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.SigningAttempt != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.SigningAttempt))
			i--
			dAtA[i] = 0x10
		}
		if x.SigningId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.SigningId))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*SigningExpiration)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: SigningExpiration: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: SigningExpiration: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SigningId", wireType)
				}
				x.SigningId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.SigningId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SigningAttempt", wireType)
				}
				x.SigningAttempt = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.SigningAttempt |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_SigningExpirations_1_list)(nil)

type _SigningExpirations_1_list struct {
	list *[]*SigningExpiration
}

func (x *_SigningExpirations_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_SigningExpirations_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_SigningExpirations_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*SigningExpiration)
	(*x.list)[i] = concreteValue
}

func (x *_SigningExpirations_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*SigningExpiration)
	*x.list = append(*x.list, concreteValue)
}

func (x *_SigningExpirations_1_list) AppendMutable() protoreflect.Value {
	v := new(SigningExpiration)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_SigningExpirations_1_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_SigningExpirations_1_list) NewElement() protoreflect.Value {
	v := new(SigningExpiration)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_SigningExpirations_1_list) IsValid() bool {
	return x.list != nil
}

var (
	md_SigningExpirations                     protoreflect.MessageDescriptor
	fd_SigningExpirations_signing_expirations protoreflect.FieldDescriptor
)

func init() {
	file_band_tss_v1beta1_tss_proto_init()
	md_SigningExpirations = File_band_tss_v1beta1_tss_proto.Messages().ByName("SigningExpirations")
	fd_SigningExpirations_signing_expirations = md_SigningExpirations.Fields().ByName("signing_expirations")
}

var _ protoreflect.Message = (*fastReflection_SigningExpirations)(nil)

type fastReflection_SigningExpirations SigningExpirations

func (x *SigningExpirations) ProtoReflect() protoreflect.Message {
	return (*fastReflection_SigningExpirations)(x)
}

func (x *SigningExpirations) slowProtoReflect() protoreflect.Message {
	mi := &file_band_tss_v1beta1_tss_proto_msgTypes[22]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_SigningExpirations_messageType fastReflection_SigningExpirations_messageType
var _ protoreflect.MessageType = fastReflection_SigningExpirations_messageType{}

type fastReflection_SigningExpirations_messageType struct{}

func (x fastReflection_SigningExpirations_messageType) Zero() protoreflect.Message {
	return (*fastReflection_SigningExpirations)(nil)
}
func (x fastReflection_SigningExpirations_messageType) New() protoreflect.Message {
	return new(fastReflection_SigningExpirations)
}
func (x fastReflection_SigningExpirations_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_SigningExpirations
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_SigningExpirations) Descriptor() protoreflect.MessageDescriptor {
	return md_SigningExpirations
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_SigningExpirations) Type() protoreflect.MessageType {
	return _fastReflection_SigningExpirations_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_SigningExpirations) New() protoreflect.Message {
	return new(fastReflection_SigningExpirations)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_SigningExpirations) Interface() protoreflect.ProtoMessage {
	return (*SigningExpirations)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_SigningExpirations) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.SigningExpirations) != 0 {
		value := protoreflect.ValueOfList(&_SigningExpirations_1_list{list: &x.SigningExpirations})
		if !f(fd_SigningExpirations_signing_expirations, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_SigningExpirations) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "band.tss.v1beta1.SigningExpirations.signing_expirations":
		return len(x.SigningExpirations) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.SigningExpirations"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.SigningExpirations does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SigningExpirations) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "band.tss.v1beta1.SigningExpirations.signing_expirations":
		x.SigningExpirations = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.SigningExpirations"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.SigningExpirations does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_SigningExpirations) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "band.tss.v1beta1.SigningExpirations.signing_expirations":
		if len(x.SigningExpirations) == 0 {
			return protoreflect.ValueOfList(&_SigningExpirations_1_list{})
		}
		listValue := &_SigningExpirations_1_list{list: &x.SigningExpirations}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.SigningExpirations"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.SigningExpirations does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SigningExpirations) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "band.tss.v1beta1.SigningExpirations.signing_expirations":
		lv := value.List()
		clv := lv.(*_SigningExpirations_1_list)
		x.SigningExpirations = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.SigningExpirations"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.SigningExpirations does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SigningExpirations) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.SigningExpirations.signing_expirations":
		if x.SigningExpirations == nil {
			x.SigningExpirations = []*SigningExpiration{}
		}
		value := &_SigningExpirations_1_list{list: &x.SigningExpirations}
		return protoreflect.ValueOfList(value)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.SigningExpirations"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.SigningExpirations does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_SigningExpirations) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "band.tss.v1beta1.SigningExpirations.signing_expirations":
		list := []*SigningExpiration{}
		return protoreflect.ValueOfList(&_SigningExpirations_1_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: band.tss.v1beta1.SigningExpirations"))
		}
		panic(fmt.Errorf("message band.tss.v1beta1.SigningExpirations does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_SigningExpirations) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in band.tss.v1beta1.SigningExpirations", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_SigningExpirations) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SigningExpirations) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_SigningExpirations) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_SigningExpirations) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*SigningExpirations)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.SigningExpirations) > 0 {
			for _, e := range x.SigningExpirations {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*SigningExpirations)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.SigningExpirations) > 0 {
			for iNdEx := len(x.SigningExpirations) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.SigningExpirations[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0xa
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*SigningExpirations)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: SigningExpirations: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: SigningExpirations: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SigningExpirations", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SigningExpirations = append(x.SigningExpirations, &SigningExpiration{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.SigningExpirations[len(x.SigningExpirations)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.27.0
// 	protoc        (unknown)
// source: band/tss/v1beta1/tss.proto

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// SigningStatus is an enumeration of the possible statuses of a signing.
type SigningStatus int32

const (
	// SIGNING_STATUS_UNSPECIFIED is the status of a signing that has not been specified.
	SigningStatus_SIGNING_STATUS_UNSPECIFIED SigningStatus = 0
	// SIGNING_STATUS_WAITING is the status of a signing that is waiting to be signed in the protocol.
	SigningStatus_SIGNING_STATUS_WAITING SigningStatus = 1
	// SIGNING_STATUS_SUCCESS is the status of a signing that has success in the protocol.
	SigningStatus_SIGNING_STATUS_SUCCESS SigningStatus = 2
	// SIGNING_STATUS_FALLEN is the status of a signing that has fallen out of the protocol.
	SigningStatus_SIGNING_STATUS_FALLEN SigningStatus = 3
)

// Enum value maps for SigningStatus.
var (
	SigningStatus_name = map[int32]string{
		0: "SIGNING_STATUS_UNSPECIFIED",
		1: "SIGNING_STATUS_WAITING",
		2: "SIGNING_STATUS_SUCCESS",
		3: "SIGNING_STATUS_FALLEN",
	}
	SigningStatus_value = map[string]int32{
		"SIGNING_STATUS_UNSPECIFIED": 0,
		"SIGNING_STATUS_WAITING":     1,
		"SIGNING_STATUS_SUCCESS":     2,
		"SIGNING_STATUS_FALLEN":      3,
	}
)

func (x SigningStatus) Enum() *SigningStatus {
	p := new(SigningStatus)
	*p = x
	return p
}

func (x SigningStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SigningStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_band_tss_v1beta1_tss_proto_enumTypes[0].Descriptor()
}

func (SigningStatus) Type() protoreflect.EnumType {
	return &file_band_tss_v1beta1_tss_proto_enumTypes[0]
}

func (x SigningStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SigningStatus.Descriptor instead.
func (SigningStatus) EnumDescriptor() ([]byte, []int) {
	return file_band_tss_v1beta1_tss_proto_rawDescGZIP(), []int{0}
}

// GroupStatus is an enumeration of the possible statuses of a group.
type GroupStatus int32

const (
	// GROUP_STATUS_UNSPECIFIED is the status of a group that has not been specified.
	GroupStatus_GROUP_STATUS_UNSPECIFIED GroupStatus = 0
	// GROUP_STATUS_ROUND_1 is the status of a group that is in the first round of the protocol.
	GroupStatus_GROUP_STATUS_ROUND_1 GroupStatus = 1
	// GROUP_STATUS_ROUND_2 is the status of a group that is in the second round of the protocol.
	GroupStatus_GROUP_STATUS_ROUND_2 GroupStatus = 2
	// GROUP_STATUS_ROUND_3 is the status of a group that is in the third round of the protocol.
	GroupStatus_GROUP_STATUS_ROUND_3 GroupStatus = 3
	// GROUP_STATUS_ACTIVE is the status of a group that is actively participating in the protocol.
	GroupStatus_GROUP_STATUS_ACTIVE GroupStatus = 4
	// GROUP_STATUS_EXPIRED is the status of a group that has expired in the protocol.
	GroupStatus_GROUP_STATUS_EXPIRED GroupStatus = 5
	// GROUP_STATUS_FALLEN is the status of a group that has fallen out of the protocol.
	GroupStatus_GROUP_STATUS_FALLEN GroupStatus = 6
)

// Enum value maps for GroupStatus.
var (
	GroupStatus_name = map[int32]string{
		0: "GROUP_STATUS_UNSPECIFIED",
		1: "GROUP_STATUS_ROUND_1",
		2: "GROUP_STATUS_ROUND_2",
		3: "GROUP_STATUS_ROUND_3",
		4: "GROUP_STATUS_ACTIVE",
		5: "GROUP_STATUS_EXPIRED",
		6: "GROUP_STATUS_FALLEN",
	}
	GroupStatus_value = map[string]int32{
		"GROUP_STATUS_UNSPECIFIED": 0,
		"GROUP_STATUS_ROUND_1":     1,
		"GROUP_STATUS_ROUND_2":     2,
		"GROUP_STATUS_ROUND_3":     3,
		"GROUP_STATUS_ACTIVE":      4,
		"GROUP_STATUS_EXPIRED":     5,
		"GROUP_STATUS_FALLEN":      6,
	}
)

func (x GroupStatus) Enum() *GroupStatus {
	p := new(GroupStatus)
	*p = x
	return p
}

func (x GroupStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (GroupStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_band_tss_v1beta1_tss_proto_enumTypes[1].Descriptor()
}

func (GroupStatus) Type() protoreflect.EnumType {
	return &file_band_tss_v1beta1_tss_proto_enumTypes[1]
}

func (x GroupStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use GroupStatus.Descriptor instead.
func (GroupStatus) EnumDescriptor() ([]byte, []int) {
	return file_band_tss_v1beta1_tss_proto_rawDescGZIP(), []int{1}
}

// ComplaintStatus represents the status of a complaint.
type ComplaintStatus int32

const (
	// COMPLAINT_STATUS_UNSPECIFIED represents an undefined status of the complaint.
	ComplaintStatus_COMPLAINT_STATUS_UNSPECIFIED ComplaintStatus = 0
	// COMPLAINT_STATUS_SUCCESS represents a successful complaint.
	ComplaintStatus_COMPLAINT_STATUS_SUCCESS ComplaintStatus = 1
	// COMPLAINT_STATUS_FAILED represents a failed complaint.
	ComplaintStatus_COMPLAINT_STATUS_FAILED ComplaintStatus = 2
)

// Enum value maps for ComplaintStatus.
var (
	ComplaintStatus_name = map[int32]string{
		0: "COMPLAINT_STATUS_UNSPECIFIED",
		1: "COMPLAINT_STATUS_SUCCESS",
		2: "COMPLAINT_STATUS_FAILED",
	}
	ComplaintStatus_value = map[string]int32{
		"COMPLAINT_STATUS_UNSPECIFIED": 0,
		"COMPLAINT_STATUS_SUCCESS":     1,
		"COMPLAINT_STATUS_FAILED":      2,
	}
)

func (x ComplaintStatus) Enum() *ComplaintStatus {
	p := new(ComplaintStatus)
	*p = x
	return p
}

func (x ComplaintStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ComplaintStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_band_tss_v1beta1_tss_proto_enumTypes[2].Descriptor()
}

func (ComplaintStatus) Type() protoreflect.EnumType {
	return &file_band_tss_v1beta1_tss_proto_enumTypes[2]
}

func (x ComplaintStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ComplaintStatus.Descriptor instead.
func (ComplaintStatus) EnumDescriptor() ([]byte, []int) {
	return file_band_tss_v1beta1_tss_proto_rawDescGZIP(), []int{2}
}

// Group is a type representing a participant group in a Distributed Key Generation or signing process.
type Group struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// id is the unique identifier of the group.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// size is the number of members in the group.
	Size uint64 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	// threshold is the minimum number of members needed to generate a valid signature.
	Threshold uint64 `protobuf:"varint,3,opt,name=threshold,proto3" json:"threshold,omitempty"`
	// pub_key is the public key generated by the group after successful completion of the DKG process.
	PubKey []byte `protobuf:"bytes,4,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
	// status represents the current stage of the group in the DKG or signing process.
	Status GroupStatus `protobuf:"varint,5,opt,name=status,proto3,enum=band.tss.v1beta1.GroupStatus" json:"status,omitempty"`
	// created_height is the block height when the group was created.
	CreatedHeight uint64 `protobuf:"varint,6,opt,name=created_height,json=createdHeight,proto3" json:"created_height,omitempty"`
	// module_owner is the module that creates this group.
	ModuleOwner string `protobuf:"bytes,7,opt,name=module_owner,json=moduleOwner,proto3" json:"module_owner,omitempty"`
}

func (x *Group) Reset() {
	*x = Group{}
	if protoimpl.UnsafeEnabled {
		mi := &file_band_tss_v1beta1_tss_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Group) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Group) ProtoMessage() {}

// Deprecated: Use Group.ProtoReflect.Descriptor instead.
func (*Group) Descriptor() ([]byte, []int) {
	return file_band_tss_v1beta1_tss_proto_rawDescGZIP(), []int{0}
}

func (x *Group) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Group) GetSize() uint64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *Group) GetThreshold() uint64 {
	if x != nil {
		return x.Threshold
	}
	return 0
}

func (x *Group) GetPubKey() []byte {
	if x != nil {
		return x.PubKey
	}
	return nil
}

func (x *Group) GetStatus() GroupStatus {
	if x != nil {
		return x.Status
	}
	return GroupStatus_GROUP_STATUS_UNSPECIFIED
}

func (x *Group) GetCreatedHeight() uint64 {
	if x != nil {
		return x.CreatedHeight
	}
	return 0
}

func (x *Group) GetModuleOwner() string {
	if x != nil {
		return x.ModuleOwner
	}
	return ""
}

// GroupResult is a tss group result from querying tss group information.
type GroupResult struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// group defines the group object containing group information.
	Group *Group `protobuf:"bytes,1,opt,name=group,proto3" json:"group,omitempty"`
	// dkg_context defines the DKG context data.
	DkgContext []byte `protobuf:"bytes,2,opt,name=dkg_context,json=dkgContext,proto3" json:"dkg_context,omitempty"`
	// members is the list of members in the group.
	Members []*Member `protobuf:"bytes,3,rep,name=members,proto3" json:"members,omitempty"`
	// round1_infos is the list of Round 1 information.
	Round1Infos []*Round1Info `protobuf:"bytes,4,rep,name=round1_infos,json=round1Infos,proto3" json:"round1_infos,omitempty"`
	// round2_infos is the list of Round 2 information.
	Round2Infos []*Round2Info `protobuf:"bytes,5,rep,name=round2_infos,json=round2Infos,proto3" json:"round2_infos,omitempty"`
	// complaints_with_status is the list of complaints with status.
	ComplaintsWithStatus []*ComplaintsWithStatus `protobuf:"bytes,6,rep,name=complaints_with_status,json=complaintsWithStatus,proto3" json:"complaints_with_status,omitempty"`
	// confirms is the list of confirms.
	Confirms []*Confirm `protobuf:"bytes,7,rep,name=confirms,proto3" json:"confirms,omitempty"`
}

func (x *GroupResult) Reset() {
	*x = GroupResult{}
	if protoimpl.UnsafeEnabled {
		mi := &file_band_tss_v1beta1_tss_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GroupResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GroupResult) ProtoMessage() {}

// Deprecated: Use GroupResult.ProtoReflect.Descriptor instead.
func (*GroupResult) Descriptor() ([]byte, []int) {
	return file_band_tss_v1beta1_tss_proto_rawDescGZIP(), []int{1}
}

func (x *GroupResult) GetGroup() *Group {
	if x != nil {
		return x.Group
	}
	return nil
}

func (x *GroupResult) GetDkgContext() []byte {
	if x != nil {
		return x.DkgContext
	}
	return nil
}

func (x *GroupResult) GetMembers() []*Member {
	if x != nil {
		return x.Members
	}
	return nil
}

func (x *GroupResult) GetRound1Infos() []*Round1Info {
	if x != nil {
		return x.Round1Infos
	}
	return nil
}

func (x *GroupResult) GetRound2Infos() []*Round2Info {
	if x != nil {
		return x.Round2Infos
	}
	return nil
}

func (x *GroupResult) GetComplaintsWithStatus() []*ComplaintsWithStatus {
	if x != nil {
		return x.ComplaintsWithStatus
	}
	return nil
}

func (x *GroupResult) GetConfirms() []*Confirm {
	if x != nil {
		return x.Confirms
	}
	return nil
}

// Round1Info contains all necessary information for handling round 1 of the DKG process.
type Round1Info struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// member_id is the unique identifier of a group member.
	MemberId uint64 `protobuf:"varint,1,opt,name=member_id,json=memberId,proto3" json:"member_id,omitempty"`
	// coefficients_commits is a list of commitments to the coefficients of the member's secret polynomial.
	CoefficientCommits [][]byte `protobuf:"bytes,2,rep,name=coefficient_commits,json=coefficientCommits,proto3" json:"coefficient_commits,omitempty"`
	// one_time_pub_key is the one-time public key used by the member to encrypt secret shares.
	OneTimePubKey []byte `protobuf:"bytes,3,opt,name=one_time_pub_key,json=oneTimePubKey,proto3" json:"one_time_pub_key,omitempty"`
	// a0_signature is the member's signature on the first coefficient of its secret polynomial.
	A0Signature []byte `protobuf:"bytes,4,opt,name=a0_signature,json=a0Signature,proto3" json:"a0_signature,omitempty"`
	// one_time_signature is the member's signature on its one-time public key.
	OneTimeSignature []byte `protobuf:"bytes,5,opt,name=one_time_signature,json=oneTimeSignature,proto3" json:"one_time_signature,omitempty"`
}

func (x *Round1Info) Reset() {
	*x = Round1Info{}
	if protoimpl.UnsafeEnabled {
		mi := &file_band_tss_v1beta1_tss_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Round1Info) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Round1Info) ProtoMessage() {}

// Deprecated: Use Round1Info.ProtoReflect.Descriptor instead.
func (*Round1Info) Descriptor() ([]byte, []int) {
	return file_band_tss_v1beta1_tss_proto_rawDescGZIP(), []int{2}
}

func (x *Round1Info) GetMemberId() uint64 {
	if x != nil {
		return x.MemberId
	}
	return 0
}

func (x *Round1Info) GetCoefficientCommits() [][]byte {
	if x != nil {
		return x.CoefficientCommits
	}
	return nil
}

func (x *Round1Info) GetOneTimePubKey() []byte {
	if x != nil {
		return x.OneTimePubKey
	}
	return nil
}

func (x *Round1Info) GetA0Signature() []byte {
	if x != nil {
		return x.A0Signature
	}
	return nil
}

func (x *Round1Info) GetOneTimeSignature() []byte {
	if x != nil {
		return x.OneTimeSignature
	}
	return nil
}

// Round2Info contains all necessary information for handling round 2 of the DKG process.
type Round2Info struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// member_id is the unique identifier of a group member.
	MemberId uint64 `protobuf:"varint,1,opt,name=member_id,json=memberId,proto3" json:"member_id,omitempty"`
	// encrypted_secret_shares is a list of secret shares encrypted under the public keys of other members.
	EncryptedSecretShares [][]byte `protobuf:"bytes,2,rep,name=encrypted_secret_shares,json=encryptedSecretShares,proto3" json:"encrypted_secret_shares,omitempty"`
}

func (x *Round2Info) Reset() {
	*x = Round2Info{}
	if protoimpl.UnsafeEnabled {
		mi := &file_band_tss_v1beta1_tss_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Round2Info) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Round2Info) ProtoMessage() {}

// Deprecated: Use Round2Info.ProtoReflect.Descriptor instead.
func (*Round2Info) Descriptor() ([]byte, []int) {
	return file_band_tss_v1beta1_tss_proto_rawDescGZIP(), []int{3}
}

func (x *Round2Info) GetMemberId() uint64 {
	if x != nil {
		return x.MemberId
	}
	return 0
}

func (x *Round2Info) GetEncryptedSecretShares() [][]byte {
	if x != nil {
		return x.EncryptedSecretShares
	}
	return nil
}

// DE contains the public parts of a member's decryption and encryption keys.
type DE struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// pub_d is the public value of own commitment (D).
	PubD []byte `protobuf:"bytes,1,opt,name=pub_d,json=pubD,proto3" json:"pub_d,omitempty"`
	// pub_e is the public value of own commitment (E).
	PubE []byte `protobuf:"bytes,2,opt,name=pub_e,json=pubE,proto3" json:"pub_e,omitempty"`
}

func (x *DE) Reset() {
	*x = DE{}
	if protoimpl.UnsafeEnabled {
		mi := &file_band_tss_v1beta1_tss_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DE) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DE) ProtoMessage() {}

// Deprecated: Use DE.ProtoReflect.Descriptor instead.
func (*DE) Descriptor() ([]byte, []int) {
	return file_band_tss_v1beta1_tss_proto_rawDescGZIP(), []int{4}
}

func (x *DE) GetPubD() []byte {
	if x != nil {
		return x.PubD
	}
	return nil
}

func (x *DE) GetPubE() []byte {
	if x != nil {
		return x.PubE
	}
	return nil
}

// DEQueue is a simple queue data structure contains index of existing DE objects of each member.
type DEQueue struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// head is the current index of the first element in the queue.
	Head uint64 `protobuf:"varint,1,opt,name=head,proto3" json:"head,omitempty"`
	// tail is the current index of the last element in the queue.
	Tail uint64 `protobuf:"varint,2,opt,name=tail,proto3" json:"tail,omitempty"`
}

func (x *DEQueue) Reset() {
	*x = DEQueue{}
	if protoimpl.UnsafeEnabled {
		mi := &file_band_tss_v1beta1_tss_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DEQueue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DEQueue) ProtoMessage() {}

// Deprecated: Use DEQueue.ProtoReflect.Descriptor instead.
func (*DEQueue) Descriptor() ([]byte, []int) {
	return file_band_tss_v1beta1_tss_proto_rawDescGZIP(), []int{5}
}

func (x *DEQueue) GetHead() uint64 {
	if x != nil {
		return x.Head
	}
	return 0
}

func (x *DEQueue) GetTail() uint64 {
	if x != nil {
		return x.Tail
	}
	return 0
}

// Signing contains all necessary information for handling a signing request.
type Signing struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// id is the unique identifier of the signing.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// current_attempt is the latest round number that signing has been attempted.
	CurrentAttempt uint64 `protobuf:"varint,2,opt,name=current_attempt,json=currentAttempt,proto3" json:"current_attempt,omitempty"`
	// group_id is the unique identifier of the group.
	GroupId uint64 `protobuf:"varint,3,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	// group_pub_key is the public key of the group that sign this message.
	GroupPubKey []byte `protobuf:"bytes,4,opt,name=group_pub_key,json=groupPubKey,proto3" json:"group_pub_key,omitempty"`
	// message is the message to be signed.
	Message []byte `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	// group_pub_nonce is the public nonce generated by the group for this signing process.
	GroupPubNonce []byte `protobuf:"bytes,6,opt,name=group_pub_nonce,json=groupPubNonce,proto3" json:"group_pub_nonce,omitempty"`
	// signature is the group's signature on the message.
	Signature []byte `protobuf:"bytes,7,opt,name=signature,proto3" json:"signature,omitempty"`
	// status represents the current stage of the signing in the signing process.
	Status SigningStatus `protobuf:"varint,8,opt,name=status,proto3,enum=band.tss.v1beta1.SigningStatus" json:"status,omitempty"`
	// created_height is the block height when the signing was created.
	CreatedHeight uint64 `protobuf:"varint,9,opt,name=created_height,json=createdHeight,proto3" json:"created_height,omitempty"`
	// created_timestamp is the block timestamp when the signing was created.
	CreatedTimestamp *timestamppb.Timestamp `protobuf:"bytes,10,opt,name=created_timestamp,json=createdTimestamp,proto3" json:"created_timestamp,omitempty"`
}

func (x *Signing) Reset() {
	*x = Signing{}
	if protoimpl.UnsafeEnabled {
		mi := &file_band_tss_v1beta1_tss_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Signing) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Signing) ProtoMessage() {}

// Deprecated: Use Signing.ProtoReflect.Descriptor instead.
func (*Signing) Descriptor() ([]byte, []int) {
	return file_band_tss_v1beta1_tss_proto_rawDescGZIP(), []int{6}
}

func (x *Signing) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Signing) GetCurrentAttempt() uint64 {
	if x != nil {
		return x.CurrentAttempt
	}
	return 0
}

func (x *Signing) GetGroupId() uint64 {
	if x != nil {
		return x.GroupId
	}
	return 0
}

func (x *Signing) GetGroupPubKey() []byte {
	if x != nil {
		return x.GroupPubKey
	}
	return nil
}

func (x *Signing) GetMessage() []byte {
	if x != nil {
		return x.Message
	}
	return nil
}

func (x *Signing) GetGroupPubNonce() []byte {
	if x != nil {
		return x.GroupPubNonce
	}
	return nil
}

func (x *Signing) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *Signing) GetStatus() SigningStatus {
	if x != nil {
		return x.Status
	}
	return SigningStatus_SIGNING_STATUS_UNSPECIFIED
}

func (x *Signing) GetCreatedHeight() uint64 {
	if x != nil {
		return x.CreatedHeight
	}
	return 0
}

func (x *Signing) GetCreatedTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedTimestamp
	}
	return nil
}

// SigningAttempt contains a member that has been assigned to and expiration block height of
// the specific attempt.
type SigningAttempt struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// signing_id is the unique identifier of the signing.
	SigningId uint64 `protobuf:"varint,1,opt,name=signing_id,json=signingId,proto3" json:"signing_id,omitempty"`
	// attempt is the number of round that this signing has been attempted.
	Attempt uint64 `protobuf:"varint,2,opt,name=attempt,proto3" json:"attempt,omitempty"`
	// expired_height is the block height when this signing attempt was expired.
	ExpiredHeight uint64 `protobuf:"varint,3,opt,name=expired_height,json=expiredHeight,proto3" json:"expired_height,omitempty"`
	// assigned_members is a list of members assigned to the signing process.
	AssignedMembers []*AssignedMember `protobuf:"bytes,4,rep,name=assigned_members,json=assignedMembers,proto3" json:"assigned_members,omitempty"`
}

func (x *SigningAttempt) Reset() {
	*x = SigningAttempt{}
	if protoimpl.UnsafeEnabled {
		mi := &file_band_tss_v1beta1_tss_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SigningAttempt) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SigningAttempt) ProtoMessage() {}

// Deprecated: Use SigningAttempt.ProtoReflect.Descriptor instead.
func (*SigningAttempt) Descriptor() ([]byte, []int) {
	return file_band_tss_v1beta1_tss_proto_rawDescGZIP(), []int{7}
}

func (x *SigningAttempt) GetSigningId() uint64 {
	if x != nil {
		return x.SigningId
	}
	return 0
}

func (x *SigningAttempt) GetAttempt() uint64 {
	if x != nil {
		return x.Attempt
	}
	return 0
}

func (x *SigningAttempt) GetExpiredHeight() uint64 {
	if x != nil {
		return x.ExpiredHeight
	}
	return 0
}

func (x *SigningAttempt) GetAssignedMembers() []*AssignedMember {
	if x != nil {
		return x.AssignedMembers
	}
	return nil
}

// AssignedMember is a type representing a member that has been assigned to a signing process.
type AssignedMember struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// member_id is the unique identifier of the member.
	MemberId uint64 `protobuf:"varint,1,opt,name=member_id,json=memberId,proto3" json:"member_id,omitempty"`
	// member is the human-readable name of the member.
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	// pub_key is the public part of a member.
	PubKey []byte `protobuf:"bytes,3,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
	// pub_d is the public part of a member's decryption key.
	PubD []byte `protobuf:"bytes,4,opt,name=pub_d,json=pubD,proto3" json:"pub_d,omitempty"`
	// pub_e is the public part of a member's encryption key.
	PubE []byte `protobuf:"bytes,5,opt,name=pub_e,json=pubE,proto3" json:"pub_e,omitempty"`
	// binding_factor is the binding factor of the member for the signing process.
	BindingFactor []byte `protobuf:"bytes,6,opt,name=binding_factor,json=bindingFactor,proto3" json:"binding_factor,omitempty"`
	// pub_nonce is the public nonce of the member for the signing process.
	PubNonce []byte `protobuf:"bytes,7,opt,name=pub_nonce,json=pubNonce,proto3" json:"pub_nonce,omitempty"`
}

func (x *AssignedMember) Reset() {
	*x = AssignedMember{}
	if protoimpl.UnsafeEnabled {
		mi := &file_band_tss_v1beta1_tss_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AssignedMember) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AssignedMember) ProtoMessage() {}

// Deprecated: Use AssignedMember.ProtoReflect.Descriptor instead.
func (*AssignedMember) Descriptor() ([]byte, []int) {
	return file_band_tss_v1beta1_tss_proto_rawDescGZIP(), []int{8}
}

func (x *AssignedMember) GetMemberId() uint64 {
	if x != nil {
		return x.MemberId
	}
	return 0
}

func (x *AssignedMember) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *AssignedMember) GetPubKey() []byte {
	if x != nil {
		return x.PubKey
	}
	return nil
}

func (x *AssignedMember) GetPubD() []byte {
	if x != nil {
		return x.PubD
	}
	return nil
}

func (x *AssignedMember) GetPubE() []byte {
	if x != nil {
		return x.PubE
	}
	return nil
}

func (x *AssignedMember) GetBindingFactor() []byte {
	if x != nil {
		return x.BindingFactor
	}
	return nil
}

func (x *AssignedMember) GetPubNonce() []byte {
	if x != nil {
		return x.PubNonce
	}
	return nil
}

// PendingSignings is a list of all signing processes that are currently pending.
type PendingSignings struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// signing_ids is a list of identifiers for the signing processes.
	SigningIds []uint64 `protobuf:"varint,1,rep,packed,name=signing_ids,json=signingIds,proto3" json:"signing_ids,omitempty"`
}

func (x *PendingSignings) Reset() {
	*x = PendingSignings{}
	if protoimpl.UnsafeEnabled {
		mi := &file_band_tss_v1beta1_tss_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PendingSignings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PendingSignings) ProtoMessage() {}

// Deprecated: Use PendingSignings.ProtoReflect.Descriptor instead.
func (*PendingSignings) Descriptor() ([]byte, []int) {
	return file_band_tss_v1beta1_tss_proto_rawDescGZIP(), []int{9}
}

func (x *PendingSignings) GetSigningIds() []uint64 {
	if x != nil {
		return x.SigningIds
	}
	return nil
}

// Member is a type representing a member of the group.
type Member struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// id is the unique identifier of a member.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// group_id is the group id of this member.
	GroupId uint64 `protobuf:"varint,2,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	// address is the address of the member.
	Address string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	// pub_key is the public key of the member.
	PubKey []byte `protobuf:"bytes,4,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
	// is_malicious is a boolean flag indicating whether the member is considered malicious.
	IsMalicious bool `protobuf:"varint,5,opt,name=is_malicious,json=isMalicious,proto3" json:"is_malicious,omitempty"`
	// is_active is a boolean flag indicating whether the member is currently active in the protocol.
	IsActive bool `protobuf:"varint,6,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
}

func (x *Member) Reset() {
	*x = Member{}
	if protoimpl.UnsafeEnabled {
		mi := &file_band_tss_v1beta1_tss_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Member) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Member) ProtoMessage() {}

// Deprecated: Use Member.ProtoReflect.Descriptor instead.
func (*Member) Descriptor() ([]byte, []int) {
	return file_band_tss_v1beta1_tss_proto_rawDescGZIP(), []int{10}
}

func (x *Member) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Member) GetGroupId() uint64 {
	if x != nil {
		return x.GroupId
	}
	return 0
}

func (x *Member) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *Member) GetPubKey() []byte {
	if x != nil {
		return x.PubKey
	}
	return nil
}

func (x *Member) GetIsMalicious() bool {
	if x != nil {
		return x.IsMalicious
	}
	return false
}

func (x *Member) GetIsActive() bool {
	if x != nil {
		return x.IsActive
	}
	return false
}

// Confirm is a message type used to confirm participation in the protocol.
type Confirm struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// member_id is the unique identifier of a group member.
	MemberId uint64 `protobuf:"varint,1,opt,name=member_id,json=memberId,proto3" json:"member_id,omitempty"`
	// own_pub_key_sig is a signature over the member's own public key.
	OwnPubKeySig []byte `protobuf:"bytes,2,opt,name=own_pub_key_sig,json=ownPubKeySig,proto3" json:"own_pub_key_sig,omitempty"`
}

func (x *Confirm) Reset() {
	*x = Confirm{}
	if protoimpl.UnsafeEnabled {
		mi := &file_band_tss_v1beta1_tss_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Confirm) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Confirm) ProtoMessage() {}

// Deprecated: Use Confirm.ProtoReflect.Descriptor instead.
func (*Confirm) Descriptor() ([]byte, []int) {
	return file_band_tss_v1beta1_tss_proto_rawDescGZIP(), []int{11}
}

func (x *Confirm) GetMemberId() uint64 {
	if x != nil {
		return x.MemberId
	}
	return 0
}

func (x *Confirm) GetOwnPubKeySig() []byte {
	if x != nil {
		return x.OwnPubKeySig
	}
	return nil
}

// Complaint is a message type used to issue a complaint against a member.
type Complaint struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// complainant is the member issuing the complaint.
	Complainant uint64 `protobuf:"varint,1,opt,name=complainant,proto3" json:"complainant,omitempty"`
	// respondent is the member against whom the complaint is issued.
	Respondent uint64 `protobuf:"varint,2,opt,name=respondent,proto3" json:"respondent,omitempty"`
	// key_sym is a symmetric key between respondent's private key and respondent's public key.
	KeySym []byte `protobuf:"bytes,3,opt,name=key_sym,json=keySym,proto3" json:"key_sym,omitempty"`
	// signature is the complaint signature that can do a symmetric key validation and complaint verification.
	Signature []byte `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (x *Complaint) Reset() {
	*x = Complaint{}
	if protoimpl.UnsafeEnabled {
		mi := &file_band_tss_v1beta1_tss_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Complaint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Complaint) ProtoMessage() {}

// Deprecated: Use Complaint.ProtoReflect.Descriptor instead.
func (*Complaint) Descriptor() ([]byte, []int) {
	return file_band_tss_v1beta1_tss_proto_rawDescGZIP(), []int{12}
}

func (x *Complaint) GetComplainant() uint64 {
	if x != nil {
		return x.Complainant
	}
	return 0
}

func (x *Complaint) GetRespondent() uint64 {
	if x != nil {
		return x.Respondent
	}
	return 0
}

func (x *Complaint) GetKeySym() []byte {
	if x != nil {
		return x.KeySym
	}
	return nil
}

func (x *Complaint) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

// ComplaintWithStatus contains information about a complaint with its status.
type ComplaintWithStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// complaint is the information about the complaint.
	Complaint *Complaint `protobuf:"bytes,1,opt,name=complaint,proto3" json:"complaint,omitempty"`
	// complaint_status is the status of the complaint.
	ComplaintStatus ComplaintStatus `protobuf:"varint,2,opt,name=complaint_status,json=complaintStatus,proto3,enum=band.tss.v1beta1.ComplaintStatus" json:"complaint_status,omitempty"`
}

func (x *ComplaintWithStatus) Reset() {
	*x = ComplaintWithStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_band_tss_v1beta1_tss_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ComplaintWithStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ComplaintWithStatus) ProtoMessage() {}

// Deprecated: Use ComplaintWithStatus.ProtoReflect.Descriptor instead.
func (*ComplaintWithStatus) Descriptor() ([]byte, []int) {
	return file_band_tss_v1beta1_tss_proto_rawDescGZIP(), []int{13}
}

func (x *ComplaintWithStatus) GetComplaint() *Complaint {
	if x != nil {
		return x.Complaint
	}
	return nil
}

func (x *ComplaintWithStatus) GetComplaintStatus() ComplaintStatus {
	if x != nil {
		return x.ComplaintStatus
	}
	return ComplaintStatus_COMPLAINT_STATUS_UNSPECIFIED
}

// ComplaintsWithStatus contains information about multiple complaints and their status from a single member.
type ComplaintsWithStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// member_id is the identifier of the member filing the complaints.
	MemberId uint64 `protobuf:"varint,1,opt,name=member_id,json=memberId,proto3" json:"member_id,omitempty"`
	// complaints_with_status is the list of complaints with their status from this member.
	ComplaintsWithStatus []*ComplaintWithStatus `protobuf:"bytes,2,rep,name=complaints_with_status,json=complaintsWithStatus,proto3" json:"complaints_with_status,omitempty"`
}

func (x *ComplaintsWithStatus) Reset() {
	*x = ComplaintsWithStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_band_tss_v1beta1_tss_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ComplaintsWithStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ComplaintsWithStatus) ProtoMessage() {}

// Deprecated: Use ComplaintsWithStatus.ProtoReflect.Descriptor instead.
func (*ComplaintsWithStatus) Descriptor() ([]byte, []int) {
	return file_band_tss_v1beta1_tss_proto_rawDescGZIP(), []int{14}
}

func (x *ComplaintsWithStatus) GetMemberId() uint64 {
	if x != nil {
		return x.MemberId
	}
	return 0
}

func (x *ComplaintsWithStatus) GetComplaintsWithStatus() []*ComplaintWithStatus {
	if x != nil {
		return x.ComplaintsWithStatus
	}
	return nil
}

// PendingProcessGroups is a list of groups that are waiting to be processed.
type PendingProcessGroups struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// group_ids is a list of group IDs.
	GroupIds []uint64 `protobuf:"varint,1,rep,packed,name=group_ids,json=groupIds,proto3" json:"group_ids,omitempty"`
}

func (x *PendingProcessGroups) Reset() {
	*x = PendingProcessGroups{}
	if protoimpl.UnsafeEnabled {
		mi := &file_band_tss_v1beta1_tss_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PendingProcessGroups) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PendingProcessGroups) ProtoMessage() {}

// Deprecated: Use PendingProcessGroups.ProtoReflect.Descriptor instead.
func (*PendingProcessGroups) Descriptor() ([]byte, []int) {
	return file_band_tss_v1beta1_tss_proto_rawDescGZIP(), []int{15}
}

func (x *PendingProcessGroups) GetGroupIds() []uint64 {
	if x != nil {
		return x.GroupIds
	}
	return nil
}

// PendingProcessSignigns is a list of signings that are waiting to be processed.
type PendingProcessSignings struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// signing_ids is a list of signing IDs.
	SigningIds []uint64 `protobuf:"varint,1,rep,packed,name=signing_ids,json=signingIds,proto3" json:"signing_ids,omitempty"`
}

func (x *PendingProcessSignings) Reset() {
	*x = PendingProcessSignings{}
	if protoimpl.UnsafeEnabled {
		mi := &file_band_tss_v1beta1_tss_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PendingProcessSignings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PendingProcessSignings) ProtoMessage() {}

// Deprecated: Use PendingProcessSignings.ProtoReflect.Descriptor instead.
func (*PendingProcessSignings) Descriptor() ([]byte, []int) {
	return file_band_tss_v1beta1_tss_proto_rawDescGZIP(), []int{16}
}

func (x *PendingProcessSignings) GetSigningIds() []uint64 {
	if x != nil {
		return x.SigningIds
	}
	return nil
}

// PartialSignature contains information about a member's partial signature.
type PartialSignature struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// signing_id is the unique identifier of the signing.
	SigningId uint64 `protobuf:"varint,1,opt,name=signing_id,json=signingId,proto3" json:"signing_id,omitempty"`
	// signing_attempt is the number of attempts for this signing.
	SigningAttempt uint64 `protobuf:"varint,2,opt,name=signing_attempt,json=signingAttempt,proto3" json:"signing_attempt,omitempty"`
	// member_id is the identifier of the member providing the partial signature.
	MemberId uint64 `protobuf:"varint,3,opt,name=member_id,json=memberId,proto3" json:"member_id,omitempty"`
	// signature is the partial signature provided by this member.
	Signature []byte `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (x *PartialSignature) Reset() {
	*x = PartialSignature{}
	if protoimpl.UnsafeEnabled {
		mi := &file_band_tss_v1beta1_tss_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PartialSignature) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PartialSignature) ProtoMessage() {}

// Deprecated: Use PartialSignature.ProtoReflect.Descriptor instead.
func (*PartialSignature) Descriptor() ([]byte, []int) {
	return file_band_tss_v1beta1_tss_proto_rawDescGZIP(), []int{17}
}

func (x *PartialSignature) GetSigningId() uint64 {
	if x != nil {
		return x.SigningId
	}
	return 0
}

func (x *PartialSignature) GetSigningAttempt() uint64 {
	if x != nil {
		return x.SigningAttempt
	}
	return 0
}

func (x *PartialSignature) GetMemberId() uint64 {
	if x != nil {
		return x.MemberId
	}
	return 0
}

func (x *PartialSignature) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

// TextSignatureOrder defines a general text signature order.
type TextSignatureOrder struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// message is the data that needs to be signed.
	Message []byte `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *TextSignatureOrder) Reset() {
	*x = TextSignatureOrder{}
	if protoimpl.UnsafeEnabled {
		mi := &file_band_tss_v1beta1_tss_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TextSignatureOrder) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TextSignatureOrder) ProtoMessage() {}

// Deprecated: Use TextSignatureOrder.ProtoReflect.Descriptor instead.
func (*TextSignatureOrder) Descriptor() ([]byte, []int) {
	return file_band_tss_v1beta1_tss_proto_rawDescGZIP(), []int{18}
}

func (x *TextSignatureOrder) GetMessage() []byte {
	if x != nil {
		return x.Message
	}
	return nil
}

// EVMSignature defines a signature in the EVM format.
type EVMSignature struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// r_address is the address of the nonce for using in the contract.
	RAddress []byte `protobuf:"bytes,1,opt,name=r_address,json=rAddress,proto3" json:"r_address,omitempty"`
	// signature is the signature part for using in the contract.
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (x *EVMSignature) Reset() {
	*x = EVMSignature{}
	if protoimpl.UnsafeEnabled {
		mi := &file_band_tss_v1beta1_tss_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EVMSignature) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EVMSignature) ProtoMessage() {}

// Deprecated: Use EVMSignature.ProtoReflect.Descriptor instead.
func (*EVMSignature) Descriptor() ([]byte, []int) {
	return file_band_tss_v1beta1_tss_proto_rawDescGZIP(), []int{19}
}

func (x *EVMSignature) GetRAddress() []byte {
	if x != nil {
		return x.RAddress
	}
	return nil
}

func (x *EVMSignature) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

// SigningResult is a tss signing result from querying tss signing information.
type SigningResult struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// signing is the tss signing result.
	Signing *Signing `protobuf:"bytes,1,opt,name=signing,proto3" json:"signing,omitempty"`
	// current_signing_attempt is the current attempt information of the signing.
	CurrentSigningAttempt *SigningAttempt `protobuf:"bytes,2,opt,name=current_signing_attempt,json=currentSigningAttempt,proto3" json:"current_signing_attempt,omitempty"`
	// evm_signature is the signature in the format that can use directly in EVM.
	EvmSignature *EVMSignature `protobuf:"bytes,3,opt,name=evm_signature,json=evmSignature,proto3" json:"evm_signature,omitempty"`
	// received_partial_signatures is a list of received partial signatures.
	ReceivedPartialSignatures []*PartialSignature `protobuf:"bytes,4,rep,name=received_partial_signatures,json=receivedPartialSignatures,proto3" json:"received_partial_signatures,omitempty"`
}

func (x *SigningResult) Reset() {
	*x = SigningResult{}
	if protoimpl.UnsafeEnabled {
		mi := &file_band_tss_v1beta1_tss_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SigningResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SigningResult) ProtoMessage() {}

// Deprecated: Use SigningResult.ProtoReflect.Descriptor instead.
func (*SigningResult) Descriptor() ([]byte, []int) {
	return file_band_tss_v1beta1_tss_proto_rawDescGZIP(), []int{20}
}

func (x *SigningResult) GetSigning() *Signing {
	if x != nil {
		return x.Signing
	}
	return nil
}

func (x *SigningResult) GetCurrentSigningAttempt() *SigningAttempt {
	if x != nil {
		return x.CurrentSigningAttempt
	}
	return nil
}

func (x *SigningResult) GetEvmSignature() *EVMSignature {
	if x != nil {
		return x.EvmSignature
	}
	return nil
}

func (x *SigningResult) GetReceivedPartialSignatures() []*PartialSignature {
	if x != nil {
		return x.ReceivedPartialSignatures
	}
	return nil
}

// SigningExpiration defines the expiration time of the signing.
type SigningExpiration struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// signing_id is the id of the signing.
	SigningId uint64 `protobuf:"varint,1,opt,name=signing_id,json=signingId,proto3" json:"signing_id,omitempty"`
	// signing_attempt is the number of attempts of the signing.
	SigningAttempt uint64 `protobuf:"varint,2,opt,name=signing_attempt,json=signingAttempt,proto3" json:"signing_attempt,omitempty"`
}

func (x *SigningExpiration) Reset() {
	*x = SigningExpiration{}
	if protoimpl.UnsafeEnabled {
		mi := &file_band_tss_v1beta1_tss_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SigningExpiration) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SigningExpiration) ProtoMessage() {}

// Deprecated: Use SigningExpiration.ProtoReflect.Descriptor instead.
func (*SigningExpiration) Descriptor() ([]byte, []int) {
	return file_band_tss_v1beta1_tss_proto_rawDescGZIP(), []int{21}
}

func (x *SigningExpiration) GetSigningId() uint64 {
	if x != nil {
		return x.SigningId
	}
	return 0
}

func (x *SigningExpiration) GetSigningAttempt() uint64 {
	if x != nil {
		return x.SigningAttempt
	}
	return 0
}

// SigningExpirations is a list of signing expiration information that are waiting in the queue.
type SigningExpirations struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// signing_expirations is a list of SigningExpiration object.
	SigningExpirations []*SigningExpiration `protobuf:"bytes,1,rep,name=signing_expirations,json=signingExpirations,proto3" json:"signing_expirations,omitempty"`
}

func (x *SigningExpirations) Reset() {
	*x = SigningExpirations{}
	if protoimpl.UnsafeEnabled {
		mi := &file_band_tss_v1beta1_tss_proto_msgTypes[22]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SigningExpirations) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SigningExpirations) ProtoMessage() {}

// Deprecated: Use SigningExpirations.ProtoReflect.Descriptor instead.
func (*SigningExpirations) Descriptor() ([]byte, []int) {
	return file_band_tss_v1beta1_tss_proto_rawDescGZIP(), []int{22}
}

func (x *SigningExpirations) GetSigningExpirations() []*SigningExpiration {
	if x != nil {
		return x.SigningExpirations
	}
	return nil
}

var File_band_tss_v1beta1_tss_proto protoreflect.FileDescriptor

var file_band_tss_v1beta1_tss_proto_rawDesc = []byte{
	0x0a, 0x1a, 0x62, 0x61, 0x6e, 0x64, 0x2f, 0x74, 0x73, 0x73, 0x2f, 0x76, 0x31, 0x62, 0x65, 0x74,
	0x61, 0x31, 0x2f, 0x74, 0x73, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x10, 0x62, 0x61,
	0x6e, 0x64, 0x2e, 0x74, 0x73, 0x73, 0x2e, 0x76, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x1a, 0x14,
	0x67, 0x6f, 0x67, 0x6f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x67, 0x6f, 0x67, 0x6f, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x19, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x5f, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x2f, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a,
	0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
	0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x22, 0xd3, 0x02, 0x0a, 0x05, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x12, 0x4a, 0x0a, 0x02, 0x69, 0x64,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x42, 0x3a, 0xe2, 0xde, 0x1f, 0x02, 0x49, 0x44, 0xfa, 0xde,
	0x1f, 0x30, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61, 0x6e,
	0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f,
	0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e, 0x47, 0x72, 0x6f, 0x75, 0x70,
	0x49, 0x44, 0x52, 0x02, 0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x04, 0x52, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x68,
	0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x52, 0x09, 0x74,
	0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64, 0x12, 0x4b, 0x0a, 0x07, 0x70, 0x75, 0x62, 0x5f,
	0x6b, 0x65, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x32, 0xfa, 0xde, 0x1f, 0x2e, 0x67,
	0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33, 0x2f,
	0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x52, 0x06, 0x70,
	0x75, 0x62, 0x4b, 0x65, 0x79, 0x12, 0x35, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18,
	0x05, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1d, 0x2e, 0x62, 0x61, 0x6e, 0x64, 0x2e, 0x74, 0x73, 0x73,
	0x2e, 0x76, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x2e, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x53, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x25, 0x0a, 0x0e,
	0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x18, 0x06,
	0x20, 0x01, 0x28, 0x04, 0x52, 0x0d, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x48, 0x65, 0x69,
	0x67, 0x68, 0x74, 0x12, 0x21, 0x0a, 0x0c, 0x6d, 0x6f, 0x64, 0x75, 0x6c, 0x65, 0x5f, 0x6f, 0x77,
	0x6e, 0x65, 0x72, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x6d, 0x6f, 0x64, 0x75, 0x6c,
	0x65, 0x4f, 0x77, 0x6e, 0x65, 0x72, 0x22, 0x90, 0x04, 0x0a, 0x0b, 0x47, 0x72, 0x6f, 0x75, 0x70,
	0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x33, 0x0a, 0x05, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x62, 0x61, 0x6e, 0x64, 0x2e, 0x74, 0x73, 0x73,
	0x2e, 0x76, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x2e, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x42, 0x04,
	0xc8, 0xde, 0x1f, 0x00, 0x52, 0x05, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x12, 0x63, 0x0a, 0x0b, 0x64,
	0x6b, 0x67, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c,
	0x42, 0x42, 0xe2, 0xde, 0x1f, 0x0a, 0x44, 0x4b, 0x47, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74,
	0xfa, 0xde, 0x1f, 0x30, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63,
	0x6f, 0x6d, 0x65, 0x74, 0x62, 0x66, 0x74, 0x2f, 0x63, 0x6f, 0x6d, 0x65, 0x74, 0x62, 0x66, 0x74,
	0x2f, 0x6c, 0x69, 0x62, 0x73, 0x2f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x2e, 0x48, 0x65, 0x78, 0x42,
	0x79, 0x74, 0x65, 0x73, 0x52, 0x0a, 0x64, 0x6b, 0x67, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74,
	0x12, 0x38, 0x0a, 0x07, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x18, 0x2e, 0x62, 0x61, 0x6e, 0x64, 0x2e, 0x74, 0x73, 0x73, 0x2e, 0x76, 0x31, 0x62,
	0x65, 0x74, 0x61, 0x31, 0x2e, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x42, 0x04, 0xc8, 0xde, 0x1f,
	0x00, 0x52, 0x07, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x12, 0x45, 0x0a, 0x0c, 0x72, 0x6f,
	0x75, 0x6e, 0x64, 0x31, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x1c, 0x2e, 0x62, 0x61, 0x6e, 0x64, 0x2e, 0x74, 0x73, 0x73, 0x2e, 0x76, 0x31, 0x62, 0x65,
	0x74, 0x61, 0x31, 0x2e, 0x52, 0x6f, 0x75, 0x6e, 0x64, 0x31, 0x49, 0x6e, 0x66, 0x6f, 0x42, 0x04,
	0xc8, 0xde, 0x1f, 0x00, 0x52, 0x0b, 0x72, 0x6f, 0x75, 0x6e, 0x64, 0x31, 0x49, 0x6e, 0x66, 0x6f,
	0x73, 0x12, 0x45, 0x0a, 0x0c, 0x72, 0x6f, 0x75, 0x6e, 0x64, 0x32, 0x5f, 0x69, 0x6e, 0x66, 0x6f,
	0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x62, 0x61, 0x6e, 0x64, 0x2e, 0x74,
	0x73, 0x73, 0x2e, 0x76, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x2e, 0x52, 0x6f, 0x75, 0x6e, 0x64,
	0x32, 0x49, 0x6e, 0x66, 0x6f, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x0b, 0x72, 0x6f, 0x75,
	0x6e, 0x64, 0x32, 0x49, 0x6e, 0x66, 0x6f, 0x73, 0x12, 0x62, 0x0a, 0x16, 0x63, 0x6f, 0x6d, 0x70,
	0x6c, 0x61, 0x69, 0x6e, 0x74, 0x73, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x73, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x62, 0x61, 0x6e, 0x64, 0x2e,
	0x74, 0x73, 0x73, 0x2e, 0x76, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x2e, 0x43, 0x6f, 0x6d, 0x70,
	0x6c, 0x61, 0x69, 0x6e, 0x74, 0x73, 0x57, 0x69, 0x74, 0x68, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x14, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x61, 0x69, 0x6e,
	0x74, 0x73, 0x57, 0x69, 0x74, 0x68, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x3b, 0x0a, 0x08,
	0x63, 0x6f, 0x6e, 0x66, 0x69, 0x72, 0x6d, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19,
	0x2e, 0x62, 0x61, 0x6e, 0x64, 0x2e, 0x74, 0x73, 0x73, 0x2e, 0x76, 0x31, 0x62, 0x65, 0x74, 0x61,
	0x31, 0x2e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x72, 0x6d, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52,
	0x08, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x72, 0x6d, 0x73, 0x22, 0xf0, 0x03, 0x0a, 0x0a, 0x52, 0x6f,
	0x75, 0x6e, 0x64, 0x31, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x5e, 0x0a, 0x09, 0x6d, 0x65, 0x6d, 0x62,
	0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x42, 0x41, 0xe2, 0xde, 0x1f,
	0x08, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x49, 0x44, 0xfa, 0xde, 0x1f, 0x31, 0x67, 0x69, 0x74,
	0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b,
	0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x49, 0x44, 0x52, 0x08,
	0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x49, 0x64, 0x12, 0x64, 0x0a, 0x13, 0x63, 0x6f, 0x65, 0x66,
	0x66, 0x69, 0x63, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x73, 0x18,
	0x02, 0x20, 0x03, 0x28, 0x0c, 0x42, 0x33, 0xaa, 0xdf, 0x1f, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75,
	0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63,
	0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67, 0x2f,
	0x74, 0x73, 0x73, 0x2e, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x73, 0x52, 0x12, 0x63, 0x6f, 0x65, 0x66,
	0x66, 0x69, 0x63, 0x69, 0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x73, 0x12, 0x5b,
	0x0a, 0x10, 0x6f, 0x6e, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x70, 0x75, 0x62, 0x5f, 0x6b,
	0x65, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x32, 0xfa, 0xde, 0x1f, 0x2e, 0x67, 0x69,
	0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70,
	0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x52, 0x0d, 0x6f, 0x6e,
	0x65, 0x54, 0x69, 0x6d, 0x65, 0x50, 0x75, 0x62, 0x4b, 0x65, 0x79, 0x12, 0x59, 0x0a, 0x0c, 0x61,
	0x30, 0x5f, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x0c, 0x42, 0x36, 0xfa, 0xde, 0x1f, 0x32, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f,
	0x6d, 0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63,
	0x68, 0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e,
	0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x52, 0x0b, 0x61, 0x30, 0x53, 0x69, 0x67,
	0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x12, 0x64, 0x0a, 0x12, 0x6f, 0x6e, 0x65, 0x5f, 0x74, 0x69,
	0x6d, 0x65, 0x5f, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x0c, 0x42, 0x36, 0xfa, 0xde, 0x1f, 0x32, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63,
	0x6f, 0x6d, 0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f,
	0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73,
	0x2e, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x52, 0x10, 0x6f, 0x6e, 0x65, 0x54,
	0x69, 0x6d, 0x65, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x22, 0xe2, 0x01, 0x0a,
	0x0a, 0x52, 0x6f, 0x75, 0x6e, 0x64, 0x32, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x5e, 0x0a, 0x09, 0x6d,
	0x65, 0x6d, 0x62, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x42, 0x41,
	0xe2, 0xde, 0x1f, 0x08, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x49, 0x44, 0xfa, 0xde, 0x1f, 0x31,
	0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33,
	0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x49,
	0x44, 0x52, 0x08, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x49, 0x64, 0x12, 0x74, 0x0a, 0x17, 0x65,
	0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x5f, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x5f,
	0x73, 0x68, 0x61, 0x72, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0c, 0x42, 0x3c, 0xaa, 0xdf,
	0x1f, 0x38, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61, 0x6e,
	0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f,
	0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e, 0x45, 0x6e, 0x63, 0x53, 0x65,
	0x63, 0x72, 0x65, 0x74, 0x53, 0x68, 0x61, 0x72, 0x65, 0x73, 0x52, 0x15, 0x65, 0x6e, 0x63, 0x72,
	0x79, 0x70, 0x74, 0x65, 0x64, 0x53, 0x65, 0x63, 0x72, 0x65, 0x74, 0x53, 0x68, 0x61, 0x72, 0x65,
	0x73, 0x22, 0x96, 0x01, 0x0a, 0x02, 0x44, 0x45, 0x12, 0x47, 0x0a, 0x05, 0x70, 0x75, 0x62, 0x5f,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x32, 0xfa, 0xde, 0x1f, 0x2e, 0x67, 0x69, 0x74,
	0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b,
	0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x52, 0x04, 0x70, 0x75, 0x62,
	0x44, 0x12, 0x47, 0x0a, 0x05, 0x70, 0x75, 0x62, 0x5f, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c,
	0x42, 0x32, 0xfa, 0xde, 0x1f, 0x2e, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
	0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68,
	0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e, 0x50,
	0x6f, 0x69, 0x6e, 0x74, 0x52, 0x04, 0x70, 0x75, 0x62, 0x45, 0x22, 0x31, 0x0a, 0x07, 0x44, 0x45,
	0x51, 0x75, 0x65, 0x75, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x68, 0x65, 0x61, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x04, 0x52, 0x04, 0x68, 0x65, 0x61, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x61, 0x69,
	0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x04, 0x74, 0x61, 0x69, 0x6c, 0x22, 0xe9, 0x05,
	0x0a, 0x07, 0x53, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x12, 0x4c, 0x0a, 0x02, 0x69, 0x64, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x04, 0x42, 0x3c, 0xe2, 0xde, 0x1f, 0x02, 0x49, 0x44, 0xfa, 0xde, 0x1f,
	0x32, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61, 0x6e, 0x64,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x76,
	0x33, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e, 0x53, 0x69, 0x67, 0x6e, 0x69, 0x6e,
	0x67, 0x49, 0x44, 0x52, 0x02, 0x69, 0x64, 0x12, 0x27, 0x0a, 0x0f, 0x63, 0x75, 0x72, 0x72, 0x65,
	0x6e, 0x74, 0x5f, 0x61, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04,
	0x52, 0x0e, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x41, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74,
	0x12, 0x5a, 0x0a, 0x08, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x04, 0x42, 0x3f, 0xe2, 0xde, 0x1f, 0x07, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x49, 0x44, 0xfa,
	0xde, 0x1f, 0x30, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61,
	0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e,
	0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e, 0x47, 0x72, 0x6f, 0x75,
	0x70, 0x49, 0x44, 0x52, 0x07, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x49, 0x64, 0x12, 0x56, 0x0a, 0x0d,
	0x67, 0x72, 0x6f, 0x75, 0x70, 0x5f, 0x70, 0x75, 0x62, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x0c, 0x42, 0x32, 0xfa, 0xde, 0x1f, 0x2e, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e,
	0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c,
	0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73,
	0x73, 0x2e, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x52, 0x0b, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x50, 0x75,
	0x62, 0x4b, 0x65, 0x79, 0x12, 0x4e, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18,
	0x05, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x34, 0xfa, 0xde, 0x1f, 0x30, 0x67, 0x69, 0x74, 0x68, 0x75,
	0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x6f, 0x6d, 0x65, 0x74, 0x62, 0x66, 0x74, 0x2f, 0x63,
	0x6f, 0x6d, 0x65, 0x74, 0x62, 0x66, 0x74, 0x2f, 0x6c, 0x69, 0x62, 0x73, 0x2f, 0x62, 0x79, 0x74,
	0x65, 0x73, 0x2e, 0x48, 0x65, 0x78, 0x42, 0x79, 0x74, 0x65, 0x73, 0x52, 0x07, 0x6d, 0x65, 0x73,
	0x73, 0x61, 0x67, 0x65, 0x12, 0x5a, 0x0a, 0x0f, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x5f, 0x70, 0x75,
	0x62, 0x5f, 0x6e, 0x6f, 0x6e, 0x63, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x32, 0xfa,
	0xde, 0x1f, 0x2e, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61,
	0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e,
	0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e, 0x50, 0x6f, 0x69, 0x6e,
	0x74, 0x52, 0x0d, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x50, 0x75, 0x62, 0x4e, 0x6f, 0x6e, 0x63, 0x65,
	0x12, 0x54, 0x0a, 0x09, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x18, 0x07, 0x20,
	0x01, 0x28, 0x0c, 0x42, 0x36, 0xfa, 0xde, 0x1f, 0x32, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e,
	0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c,
	0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73,
	0x73, 0x2e, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x52, 0x09, 0x73, 0x69, 0x67,
	0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x12, 0x37, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x18, 0x08, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1f, 0x2e, 0x62, 0x61, 0x6e, 0x64, 0x2e, 0x74, 0x73,
	0x73, 0x2e, 0x76, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x2e, 0x53, 0x69, 0x67, 0x6e, 0x69, 0x6e,
	0x67, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12,
	0x25, 0x0a, 0x0e, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x68, 0x65, 0x69, 0x67, 0x68,
	0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0d, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64,
	0x48, 0x65, 0x69, 0x67, 0x68, 0x74, 0x12, 0x51, 0x0a, 0x11, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65,
	0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x0a, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x42, 0x08, 0xc8,
	0xde, 0x1f, 0x00, 0x90, 0xdf, 0x1f, 0x01, 0x52, 0x10, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64,
	0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x22, 0x88, 0x02, 0x0a, 0x0e, 0x53, 0x69,
	0x67, 0x6e, 0x69, 0x6e, 0x67, 0x41, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x12, 0x62, 0x0a, 0x0a,
	0x73, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04,
	0x42, 0x43, 0xe2, 0xde, 0x1f, 0x09, 0x53, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x49, 0x44, 0xfa,
	0xde, 0x1f, 0x32, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61,
	0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e,
	0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e, 0x53, 0x69, 0x67, 0x6e,
	0x69, 0x6e, 0x67, 0x49, 0x44, 0x52, 0x09, 0x73, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x49, 0x64,
	0x12, 0x18, 0x0a, 0x07, 0x61, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x04, 0x52, 0x07, 0x61, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x12, 0x25, 0x0a, 0x0e, 0x65, 0x78,
	0x70, 0x69, 0x72, 0x65, 0x64, 0x5f, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x04, 0x52, 0x0d, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x64, 0x48, 0x65, 0x69, 0x67, 0x68,
	0x74, 0x12, 0x51, 0x0a, 0x10, 0x61, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x5f, 0x6d, 0x65,
	0x6d, 0x62, 0x65, 0x72, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x62, 0x61,
	0x6e, 0x64, 0x2e, 0x74, 0x73, 0x73, 0x2e, 0x76, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x2e, 0x41,
	0x73, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x42, 0x04, 0xc8,
	0xde, 0x1f, 0x00, 0x52, 0x0f, 0x61, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x4d, 0x65, 0x6d,
	0x62, 0x65, 0x72, 0x73, 0x22, 0x96, 0x04, 0x0a, 0x0e, 0x41, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x65,
	0x64, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x12, 0x5e, 0x0a, 0x09, 0x6d, 0x65, 0x6d, 0x62, 0x65,
	0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x42, 0x41, 0xe2, 0xde, 0x1f, 0x08,
	0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x49, 0x44, 0xfa, 0xde, 0x1f, 0x31, 0x67, 0x69, 0x74, 0x68,
	0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67,
	0x2f, 0x74, 0x73, 0x73, 0x2e, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x49, 0x44, 0x52, 0x08, 0x6d,
	0x65, 0x6d, 0x62, 0x65, 0x72, 0x49, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73,
	0x73, 0x12, 0x4b, 0x0a, 0x07, 0x70, 0x75, 0x62, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0c, 0x42, 0x32, 0xfa, 0xde, 0x1f, 0x2e, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63,
	0x6f, 0x6d, 0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f,
	0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73,
	0x2e, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x52, 0x06, 0x70, 0x75, 0x62, 0x4b, 0x65, 0x79, 0x12, 0x47,
	0x0a, 0x05, 0x70, 0x75, 0x62, 0x5f, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x32, 0xfa,
	0xde, 0x1f, 0x2e, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61,
	0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e,
	0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e, 0x50, 0x6f, 0x69, 0x6e,
	0x74, 0x52, 0x04, 0x70, 0x75, 0x62, 0x44, 0x12, 0x47, 0x0a, 0x05, 0x70, 0x75, 0x62, 0x5f, 0x65,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x32, 0xfa, 0xde, 0x1f, 0x2e, 0x67, 0x69, 0x74, 0x68,
	0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67,
	0x2f, 0x74, 0x73, 0x73, 0x2e, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x52, 0x04, 0x70, 0x75, 0x62, 0x45,
	0x12, 0x5a, 0x0a, 0x0e, 0x62, 0x69, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x5f, 0x66, 0x61, 0x63, 0x74,
	0x6f, 0x72, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x33, 0xfa, 0xde, 0x1f, 0x2f, 0x67, 0x69,
	0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70,
	0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e, 0x53, 0x63, 0x61, 0x6c, 0x61, 0x72, 0x52, 0x0d, 0x62,
	0x69, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x46, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x4f, 0x0a, 0x09,
	0x70, 0x75, 0x62, 0x5f, 0x6e, 0x6f, 0x6e, 0x63, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0c, 0x42,
	0x32, 0xfa, 0xde, 0x1f, 0x2e, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f,
	0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61,
	0x69, 0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e, 0x50, 0x6f,
	0x69, 0x6e, 0x74, 0x52, 0x08, 0x70, 0x75, 0x62, 0x4e, 0x6f, 0x6e, 0x63, 0x65, 0x22, 0x32, 0x0a,
	0x0f, 0x50, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x53, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x73,
	0x12, 0x1f, 0x0a, 0x0b, 0x73, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x5f, 0x69, 0x64, 0x73, 0x18,
	0x01, 0x20, 0x03, 0x28, 0x04, 0x52, 0x0a, 0x73, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x49, 0x64,
	0x73, 0x22, 0xd8, 0x02, 0x0a, 0x06, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x12, 0x4b, 0x0a, 0x02,
	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x42, 0x3b, 0xe2, 0xde, 0x1f, 0x02, 0x49, 0x44,
	0xfa, 0xde, 0x1f, 0x31, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62,
	0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69,
	0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e, 0x4d, 0x65, 0x6d,
	0x62, 0x65, 0x72, 0x49, 0x44, 0x52, 0x02, 0x69, 0x64, 0x12, 0x5a, 0x0a, 0x08, 0x67, 0x72, 0x6f,
	0x75, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x42, 0x3f, 0xe2, 0xde, 0x1f,
	0x07, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x49, 0x44, 0xfa, 0xde, 0x1f, 0x30, 0x67, 0x69, 0x74, 0x68,
	0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67,
	0x2f, 0x74, 0x73, 0x73, 0x2e, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x49, 0x44, 0x52, 0x07, 0x67, 0x72,
	0x6f, 0x75, 0x70, 0x49, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12,
	0x4b, 0x0a, 0x07, 0x70, 0x75, 0x62, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c,
	0x42, 0x32, 0xfa, 0xde, 0x1f, 0x2e, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
	0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68,
	0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e, 0x50,
	0x6f, 0x69, 0x6e, 0x74, 0x52, 0x06, 0x70, 0x75, 0x62, 0x4b, 0x65, 0x79, 0x12, 0x21, 0x0a, 0x0c,
	0x69, 0x73, 0x5f, 0x6d, 0x61, 0x6c, 0x69, 0x63, 0x69, 0x6f, 0x75, 0x73, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x0b, 0x69, 0x73, 0x4d, 0x61, 0x6c, 0x69, 0x63, 0x69, 0x6f, 0x75, 0x73, 0x12,
	0x1b, 0x0a, 0x09, 0x69, 0x73, 0x5f, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x18, 0x06, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x08, 0x69, 0x73, 0x41, 0x63, 0x74, 0x69, 0x76, 0x65, 0x22, 0xc8, 0x01, 0x0a,
	0x07, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x72, 0x6d, 0x12, 0x5e, 0x0a, 0x09, 0x6d, 0x65, 0x6d, 0x62,
	0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x42, 0x41, 0xe2, 0xde, 0x1f,
	0x08, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x49, 0x44, 0xfa, 0xde, 0x1f, 0x31, 0x67, 0x69, 0x74,
	0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b,
	0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x49, 0x44, 0x52, 0x08,
	0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x49, 0x64, 0x12, 0x5d, 0x0a, 0x0f, 0x6f, 0x77, 0x6e, 0x5f,
	0x70, 0x75, 0x62, 0x5f, 0x6b, 0x65, 0x79, 0x5f, 0x73, 0x69, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0c, 0x42, 0x36, 0xfa, 0xde, 0x1f, 0x32, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f,
	0x6d, 0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63,
	0x68, 0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e,
	0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x52, 0x0c, 0x6f, 0x77, 0x6e, 0x50, 0x75,
	0x62, 0x4b, 0x65, 0x79, 0x53, 0x69, 0x67, 0x22, 0xe7, 0x02, 0x0a, 0x09, 0x43, 0x6f, 0x6d, 0x70,
	0x6c, 0x61, 0x69, 0x6e, 0x74, 0x12, 0x57, 0x0a, 0x0b, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x61, 0x69,
	0x6e, 0x61, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x42, 0x35, 0xfa, 0xde, 0x1f, 0x31,
	0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33,
	0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x49,
	0x44, 0x52, 0x0b, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x61, 0x69, 0x6e, 0x61, 0x6e, 0x74, 0x12, 0x55,
	0x0a, 0x0a, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x64, 0x65, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x04, 0x42, 0x35, 0xfa, 0xde, 0x1f, 0x31, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63,
	0x6f, 0x6d, 0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f,
	0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73,
	0x2e, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x49, 0x44, 0x52, 0x0a, 0x72, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x64, 0x65, 0x6e, 0x74, 0x12, 0x4b, 0x0a, 0x07, 0x6b, 0x65, 0x79, 0x5f, 0x73, 0x79, 0x6d,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x32, 0xfa, 0xde, 0x1f, 0x2e, 0x67, 0x69, 0x74, 0x68,
	0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67,
	0x2f, 0x74, 0x73, 0x73, 0x2e, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x52, 0x06, 0x6b, 0x65, 0x79, 0x53,
	0x79, 0x6d, 0x12, 0x5d, 0x0a, 0x09, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x3f, 0xfa, 0xde, 0x1f, 0x3b, 0x67, 0x69, 0x74, 0x68, 0x75,
	0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63,
	0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67, 0x2f,
	0x74, 0x73, 0x73, 0x2e, 0x43, 0x6f, 0x6d, 0x70, 0x6c, 0x61, 0x69, 0x6e, 0x74, 0x53, 0x69, 0x67,
	0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x52, 0x09, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72,
	0x65, 0x22, 0xa4, 0x01, 0x0a, 0x13, 0x43, 0x6f, 0x6d, 0x70, 0x6c, 0x61, 0x69, 0x6e, 0x74, 0x57,
	0x69, 0x74, 0x68, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x3f, 0x0a, 0x09, 0x63, 0x6f, 0x6d,
	0x70, 0x6c, 0x61, 0x69, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x62,
	0x61, 0x6e, 0x64, 0x2e, 0x74, 0x73, 0x73, 0x2e, 0x76, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x2e,
	0x43, 0x6f, 0x6d, 0x70, 0x6c, 0x61, 0x69, 0x6e, 0x74, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52,
	0x09, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x61, 0x69, 0x6e, 0x74, 0x12, 0x4c, 0x0a, 0x10, 0x63, 0x6f,
	0x6d, 0x70, 0x6c, 0x61, 0x69, 0x6e, 0x74, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0e, 0x32, 0x21, 0x2e, 0x62, 0x61, 0x6e, 0x64, 0x2e, 0x74, 0x73, 0x73, 0x2e,
	0x76, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x2e, 0x43, 0x6f, 0x6d, 0x70, 0x6c, 0x61, 0x69, 0x6e,
	0x74, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x0f, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x61, 0x69,
	0x6e, 0x74, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0xd9, 0x01, 0x0a, 0x14, 0x43, 0x6f, 0x6d,
	0x70, 0x6c, 0x61, 0x69, 0x6e, 0x74, 0x73, 0x57, 0x69, 0x74, 0x68, 0x53, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x12, 0x5e, 0x0a, 0x09, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x04, 0x42, 0x41, 0xe2, 0xde, 0x1f, 0x08, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72,
	0x49, 0x44, 0xfa, 0xde, 0x1f, 0x31, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
	0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68,
	0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e, 0x4d,
	0x65, 0x6d, 0x62, 0x65, 0x72, 0x49, 0x44, 0x52, 0x08, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x49,
	0x64, 0x12, 0x61, 0x0a, 0x16, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x61, 0x69, 0x6e, 0x74, 0x73, 0x5f,
	0x77, 0x69, 0x74, 0x68, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x25, 0x2e, 0x62, 0x61, 0x6e, 0x64, 0x2e, 0x74, 0x73, 0x73, 0x2e, 0x76, 0x31, 0x62,
	0x65, 0x74, 0x61, 0x31, 0x2e, 0x43, 0x6f, 0x6d, 0x70, 0x6c, 0x61, 0x69, 0x6e, 0x74, 0x57, 0x69,
	0x74, 0x68, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x14,
	0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x61, 0x69, 0x6e, 0x74, 0x73, 0x57, 0x69, 0x74, 0x68, 0x53, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x22, 0x75, 0x0a, 0x14, 0x50, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x50,
	0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x73, 0x12, 0x5d, 0x0a, 0x09,
	0x67, 0x72, 0x6f, 0x75, 0x70, 0x5f, 0x69, 0x64, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x04, 0x42,
	0x40, 0xe2, 0xde, 0x1f, 0x08, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x49, 0x44, 0x73, 0xfa, 0xde, 0x1f,
	0x30, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61, 0x6e, 0x64,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x76,
	0x33, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x49,
	0x44, 0x52, 0x08, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x49, 0x64, 0x73, 0x22, 0x7f, 0x0a, 0x16, 0x50,
	0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x53, 0x69, 0x67,
	0x6e, 0x69, 0x6e, 0x67, 0x73, 0x12, 0x65, 0x0a, 0x0b, 0x73, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67,
	0x5f, 0x69, 0x64, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x04, 0x42, 0x44, 0xe2, 0xde, 0x1f, 0x0a,
	0x53, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x49, 0x44, 0x73, 0xfa, 0xde, 0x1f, 0x32, 0x67, 0x69,
	0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70,
	0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e, 0x53, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x49, 0x44,
	0x52, 0x0a, 0x73, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x49, 0x64, 0x73, 0x22, 0xd5, 0x02, 0x0a,
	0x10, 0x50, 0x61, 0x72, 0x74, 0x69, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72,
	0x65, 0x12, 0x62, 0x0a, 0x0a, 0x73, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x5f, 0x69, 0x64, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x04, 0x42, 0x43, 0xe2, 0xde, 0x1f, 0x09, 0x53, 0x69, 0x67, 0x6e, 0x69,
	0x6e, 0x67, 0x49, 0x44, 0xfa, 0xde, 0x1f, 0x32, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63,
	0x6f, 0x6d, 0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f,
	0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73,
	0x2e, 0x53, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x49, 0x44, 0x52, 0x09, 0x73, 0x69, 0x67, 0x6e,
	0x69, 0x6e, 0x67, 0x49, 0x64, 0x12, 0x27, 0x0a, 0x0f, 0x73, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67,
	0x5f, 0x61, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0e,
	0x73, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x41, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x12, 0x5e,
	0x0a, 0x09, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x04, 0x42, 0x41, 0xe2, 0xde, 0x1f, 0x08, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x49, 0x44, 0xfa,
	0xde, 0x1f, 0x31, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61,
	0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e,
	0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e, 0x4d, 0x65, 0x6d, 0x62,
	0x65, 0x72, 0x49, 0x44, 0x52, 0x08, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x49, 0x64, 0x12, 0x54,
	0x0a, 0x09, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x0c, 0x42, 0x36, 0xfa, 0xde, 0x1f, 0x32, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f,
	0x6d, 0x2f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63,
	0x68, 0x61, 0x69, 0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e,
	0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x52, 0x09, 0x73, 0x69, 0x67, 0x6e, 0x61,
	0x74, 0x75, 0x72, 0x65, 0x22, 0x71, 0x0a, 0x12, 0x54, 0x65, 0x78, 0x74, 0x53, 0x69, 0x67, 0x6e,
	0x61, 0x74, 0x75, 0x72, 0x65, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x12, 0x4e, 0x0a, 0x07, 0x6d, 0x65,
	0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x34, 0xfa, 0xde, 0x1f,
	0x30, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x6f, 0x6d, 0x65,
	0x74, 0x62, 0x66, 0x74, 0x2f, 0x63, 0x6f, 0x6d, 0x65, 0x74, 0x62, 0x66, 0x74, 0x2f, 0x6c, 0x69,
	0x62, 0x73, 0x2f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x2e, 0x48, 0x65, 0x78, 0x42, 0x79, 0x74, 0x65,
	0x73, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x3a, 0x0b, 0xca, 0xb4, 0x2d, 0x07,
	0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x22, 0xb5, 0x01, 0x0a, 0x0c, 0x45, 0x56, 0x4d, 0x53,
	0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x12, 0x51, 0x0a, 0x09, 0x72, 0x5f, 0x61, 0x64,
	0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x34, 0xfa, 0xde, 0x1f,
	0x30, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x6f, 0x6d, 0x65,
	0x74, 0x62, 0x66, 0x74, 0x2f, 0x63, 0x6f, 0x6d, 0x65, 0x74, 0x62, 0x66, 0x74, 0x2f, 0x6c, 0x69,
	0x62, 0x73, 0x2f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x2e, 0x48, 0x65, 0x78, 0x42, 0x79, 0x74, 0x65,
	0x73, 0x52, 0x08, 0x72, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x52, 0x0a, 0x09, 0x73,
	0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x34,
	0xfa, 0xde, 0x1f, 0x30, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63,
	0x6f, 0x6d, 0x65, 0x74, 0x62, 0x66, 0x74, 0x2f, 0x63, 0x6f, 0x6d, 0x65, 0x74, 0x62, 0x66, 0x74,
	0x2f, 0x6c, 0x69, 0x62, 0x73, 0x2f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x2e, 0x48, 0x65, 0x78, 0x42,
	0x79, 0x74, 0x65, 0x73, 0x52, 0x09, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x22,
	0xe5, 0x02, 0x0a, 0x0d, 0x53, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x73, 0x75, 0x6c,
	0x74, 0x12, 0x39, 0x0a, 0x07, 0x73, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x19, 0x2e, 0x62, 0x61, 0x6e, 0x64, 0x2e, 0x74, 0x73, 0x73, 0x2e, 0x76, 0x31,
	0x62, 0x65, 0x74, 0x61, 0x31, 0x2e, 0x53, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x42, 0x04, 0xc8,
	0xde, 0x1f, 0x00, 0x52, 0x07, 0x73, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x12, 0x58, 0x0a, 0x17,
	0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x73, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x5f,
	0x61, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e,
	0x62, 0x61, 0x6e, 0x64, 0x2e, 0x74, 0x73, 0x73, 0x2e, 0x76, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31,
	0x2e, 0x53, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x41, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x52,
	0x15, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x53, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x41,
	0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x12, 0x55, 0x0a, 0x0d, 0x65, 0x76, 0x6d, 0x5f, 0x73, 0x69,
	0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e,
	0x62, 0x61, 0x6e, 0x64, 0x2e, 0x74, 0x73, 0x73, 0x2e, 0x76, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31,
	0x2e, 0x45, 0x56, 0x4d, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x42, 0x10, 0xe2,
	0xde, 0x1f, 0x0c, 0x45, 0x56, 0x4d, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x52,
	0x0c, 0x65, 0x76, 0x6d, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x12, 0x68, 0x0a,
	0x1b, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x5f, 0x70, 0x61, 0x72, 0x74, 0x69, 0x61,
	0x6c, 0x5f, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03,
	0x28, 0x0b, 0x32, 0x22, 0x2e, 0x62, 0x61, 0x6e, 0x64, 0x2e, 0x74, 0x73, 0x73, 0x2e, 0x76, 0x31,
	0x62, 0x65, 0x74, 0x61, 0x31, 0x2e, 0x50, 0x61, 0x72, 0x74, 0x69, 0x61, 0x6c, 0x53, 0x69, 0x67,
	0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x19, 0x72, 0x65,
	0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x50, 0x61, 0x72, 0x74, 0x69, 0x61, 0x6c, 0x53, 0x69, 0x67,
	0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x22, 0xa0, 0x01, 0x0a, 0x11, 0x53, 0x69, 0x67, 0x6e,
	0x69, 0x6e, 0x67, 0x45, 0x78, 0x70, 0x69, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x62, 0x0a,
	0x0a, 0x73, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x04, 0x42, 0x43, 0xe2, 0xde, 0x1f, 0x09, 0x53, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x49, 0x44,
	0xfa, 0xde, 0x1f, 0x32, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62,
	0x61, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69,
	0x6e, 0x2f, 0x76, 0x33, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x73, 0x73, 0x2e, 0x53, 0x69, 0x67,
	0x6e, 0x69, 0x6e, 0x67, 0x49, 0x44, 0x52, 0x09, 0x73, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x49,
	0x64, 0x12, 0x27, 0x0a, 0x0f, 0x73, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x5f, 0x61, 0x74, 0x74,
	0x65, 0x6d, 0x70, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0e, 0x73, 0x69, 0x67, 0x6e,
	0x69, 0x6e, 0x67, 0x41, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x22, 0x70, 0x0a, 0x12, 0x53, 0x69,
	0x67, 0x6e, 0x69, 0x6e, 0x67, 0x45, 0x78, 0x70, 0x69, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73,
	0x12, 0x5a, 0x0a, 0x13, 0x73, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x5f, 0x65, 0x78, 0x70, 0x69,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x23, 0x2e,
	0x62, 0x61, 0x6e, 0x64, 0x2e, 0x74, 0x73, 0x73, 0x2e, 0x76, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31,
	0x2e, 0x53, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x45, 0x78, 0x70, 0x69, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x12, 0x73, 0x69, 0x67, 0x6e, 0x69, 0x6e,
	0x67, 0x45, 0x78, 0x70, 0x69, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2a, 0x88, 0x01, 0x0a,
	0x0d, 0x53, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x1e,
	0x0a, 0x1a, 0x53, 0x49, 0x47, 0x4e, 0x49, 0x4e, 0x47, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53,
	0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x1a,
	0x0a, 0x16, 0x53, 0x49, 0x47, 0x4e, 0x49, 0x4e, 0x47, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53,
	0x5f, 0x57, 0x41, 0x49, 0x54, 0x49, 0x4e, 0x47, 0x10, 0x01, 0x12, 0x1a, 0x0a, 0x16, 0x53, 0x49,
	0x47, 0x4e, 0x49, 0x4e, 0x47, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x53, 0x55, 0x43,
	0x43, 0x45, 0x53, 0x53, 0x10, 0x02, 0x12, 0x19, 0x0a, 0x15, 0x53, 0x49, 0x47, 0x4e, 0x49, 0x4e,
	0x47, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x46, 0x41, 0x4c, 0x4c, 0x45, 0x4e, 0x10,
	0x03, 0x1a, 0x04, 0x88, 0xa3, 0x1e, 0x00, 0x2a, 0xcb, 0x01, 0x0a, 0x0b, 0x47, 0x72, 0x6f, 0x75,
	0x70, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x1c, 0x0a, 0x18, 0x47, 0x52, 0x4f, 0x55, 0x50,
	0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46,
	0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x18, 0x0a, 0x14, 0x47, 0x52, 0x4f, 0x55, 0x50, 0x5f, 0x53,
	0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x52, 0x4f, 0x55, 0x4e, 0x44, 0x5f, 0x31, 0x10, 0x01, 0x12,
	0x18, 0x0a, 0x14, 0x47, 0x52, 0x4f, 0x55, 0x50, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f,
	0x52, 0x4f, 0x55, 0x4e, 0x44, 0x5f, 0x32, 0x10, 0x02, 0x12, 0x18, 0x0a, 0x14, 0x47, 0x52, 0x4f,
	0x55, 0x50, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x52, 0x4f, 0x55, 0x4e, 0x44, 0x5f,
	0x33, 0x10, 0x03, 0x12, 0x17, 0x0a, 0x13, 0x47, 0x52, 0x4f, 0x55, 0x50, 0x5f, 0x53, 0x54, 0x41,
	0x54, 0x55, 0x53, 0x5f, 0x41, 0x43, 0x54, 0x49, 0x56, 0x45, 0x10, 0x04, 0x12, 0x18, 0x0a, 0x14,
	0x47, 0x52, 0x4f, 0x55, 0x50, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x45, 0x58, 0x50,
	0x49, 0x52, 0x45, 0x44, 0x10, 0x05, 0x12, 0x17, 0x0a, 0x13, 0x47, 0x52, 0x4f, 0x55, 0x50, 0x5f,
	0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x46, 0x41, 0x4c, 0x4c, 0x45, 0x4e, 0x10, 0x06, 0x1a,
	0x04, 0x88, 0xa3, 0x1e, 0x00, 0x2a, 0x74, 0x0a, 0x0f, 0x43, 0x6f, 0x6d, 0x70, 0x6c, 0x61, 0x69,
	0x6e, 0x74, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x20, 0x0a, 0x1c, 0x43, 0x4f, 0x4d, 0x50,
	0x4c, 0x41, 0x49, 0x4e, 0x54, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x55, 0x4e, 0x53,
	0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x1c, 0x0a, 0x18, 0x43, 0x4f,
	0x4d, 0x50, 0x4c, 0x41, 0x49, 0x4e, 0x54, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x53,
	0x55, 0x43, 0x43, 0x45, 0x53, 0x53, 0x10, 0x01, 0x12, 0x1b, 0x0a, 0x17, 0x43, 0x4f, 0x4d, 0x50,
	0x4c, 0x41, 0x49, 0x4e, 0x54, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x46, 0x41, 0x49,
	0x4c, 0x45, 0x44, 0x10, 0x02, 0x1a, 0x04, 0x88, 0xa3, 0x1e, 0x00, 0x42, 0xc8, 0x01, 0x0a, 0x14,
	0x63, 0x6f, 0x6d, 0x2e, 0x62, 0x61, 0x6e, 0x64, 0x2e, 0x74, 0x73, 0x73, 0x2e, 0x76, 0x31, 0x62,
	0x65, 0x74, 0x61, 0x31, 0x42, 0x08, 0x54, 0x73, 0x73, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01,
	0x5a, 0x40, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x61, 0x6e,
	0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f,
	0x76, 0x33, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x62, 0x61, 0x6e, 0x64, 0x2f, 0x74, 0x73, 0x73, 0x2f,
	0x76, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x3b, 0x74, 0x73, 0x73, 0x76, 0x31, 0x62, 0x65, 0x74,
	0x61, 0x31, 0xa2, 0x02, 0x03, 0x42, 0x54, 0x58, 0xaa, 0x02, 0x10, 0x42, 0x61, 0x6e, 0x64, 0x2e,
	0x54, 0x73, 0x73, 0x2e, 0x56, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0xca, 0x02, 0x10, 0x42, 0x61,
	0x6e, 0x64, 0x5c, 0x54, 0x73, 0x73, 0x5c, 0x56, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0xe2, 0x02,
	0x1c, 0x42, 0x61, 0x6e, 0x64, 0x5c, 0x54, 0x73, 0x73, 0x5c, 0x56, 0x31, 0x62, 0x65, 0x74, 0x61,
	0x31, 0x5c, 0x47, 0x50, 0x42, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0xea, 0x02, 0x12,
	0x42, 0x61, 0x6e, 0x64, 0x3a, 0x3a, 0x54, 0x73, 0x73, 0x3a, 0x3a, 0x56, 0x31, 0x62, 0x65, 0x74,
	0x61, 0x31, 0xa8, 0xe2, 0x1e, 0x01, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_band_tss_v1beta1_tss_proto_rawDescOnce sync.Once
	file_band_tss_v1beta1_tss_proto_rawDescData = file_band_tss_v1beta1_tss_proto_rawDesc
)

func file_band_tss_v1beta1_tss_proto_rawDescGZIP() []byte {
	file_band_tss_v1beta1_tss_proto_rawDescOnce.Do(func() {
		file_band_tss_v1beta1_tss_proto_rawDescData = protoimpl.X.CompressGZIP(file_band_tss_v1beta1_tss_proto_rawDescData)
	})
	return file_band_tss_v1beta1_tss_proto_rawDescData
}

var file_band_tss_v1beta1_tss_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_band_tss_v1beta1_tss_proto_msgTypes = make([]protoimpl.MessageInfo, 23)
var file_band_tss_v1beta1_tss_proto_goTypes = []interface{}{
	(SigningStatus)(0),             // 0: band.tss.v1beta1.SigningStatus
	(GroupStatus)(0),               // 1: band.tss.v1beta1.GroupStatus
	(ComplaintStatus)(0),           // 2: band.tss.v1beta1.ComplaintStatus
	(*Group)(nil),                  // 3: band.tss.v1beta1.Group
	(*GroupResult)(nil),            // 4: band.tss.v1beta1.GroupResult
	(*Round1Info)(nil),             // 5: band.tss.v1beta1.Round1Info
	(*Round2Info)(nil),             // 6: band.tss.v1beta1.Round2Info
	(*DE)(nil),                     // 7: band.tss.v1beta1.DE
	(*DEQueue)(nil),                // 8: band.tss.v1beta1.DEQueue
	(*Signing)(nil),                // 9: band.tss.v1beta1.Signing
	(*SigningAttempt)(nil),         // 10: band.tss.v1beta1.SigningAttempt
	(*AssignedMember)(nil),         // 11: band.tss.v1beta1.AssignedMember
	(*PendingSignings)(nil),        // 12: band.tss.v1beta1.PendingSignings
	(*Member)(nil),                 // 13: band.tss.v1beta1.Member
	(*Confirm)(nil),                // 14: band.tss.v1beta1.Confirm
	(*Complaint)(nil),              // 15: band.tss.v1beta1.Complaint
	(*ComplaintWithStatus)(nil),    // 16: band.tss.v1beta1.ComplaintWithStatus
	(*ComplaintsWithStatus)(nil),   // 17: band.tss.v1beta1.ComplaintsWithStatus
	(*PendingProcessGroups)(nil),   // 18: band.tss.v1beta1.PendingProcessGroups
	(*PendingProcessSignings)(nil), // 19: band.tss.v1beta1.PendingProcessSignings
	(*PartialSignature)(nil),       // 20: band.tss.v1beta1.PartialSignature
	(*TextSignatureOrder)(nil),     // 21: band.tss.v1beta1.TextSignatureOrder
	(*EVMSignature)(nil),           // 22: band.tss.v1beta1.EVMSignature
	(*SigningResult)(nil),          // 23: band.tss.v1beta1.SigningResult
	(*SigningExpiration)(nil),      // 24: band.tss.v1beta1.SigningExpiration
	(*SigningExpirations)(nil),     // 25: band.tss.v1beta1.SigningExpirations
	(*timestamppb.Timestamp)(nil),  // 26: google.protobuf.Timestamp
}
var file_band_tss_v1beta1_tss_proto_depIdxs = []int32{
	1,  // 0: band.tss.v1beta1.Group.status:type_name -> band.tss.v1beta1.GroupStatus
	3,  // 1: band.tss.v1beta1.GroupResult.group:type_name -> band.tss.v1beta1.Group
	13, // 2: band.tss.v1beta1.GroupResult.members:type_name -> band.tss.v1beta1.Member
	5,  // 3: band.tss.v1beta1.GroupResult.round1_infos:type_name -> band.tss.v1beta1.Round1Info
	6,  // 4: band.tss.v1beta1.GroupResult.round2_infos:type_name -> band.tss.v1beta1.Round2Info
	17, // 5: band.tss.v1beta1.GroupResult.complaints_with_status:type_name -> band.tss.v1beta1.ComplaintsWithStatus
	14, // 6: band.tss.v1beta1.GroupResult.confirms:type_name -> band.tss.v1beta1.Confirm
	0,  // 7: band.tss.v1beta1.Signing.status:type_name -> band.tss.v1beta1.SigningStatus
	26, // 8: band.tss.v1beta1.Signing.created_timestamp:type_name -> google.protobuf.Timestamp
	11, // 9: band.tss.v1beta1.SigningAttempt.assigned_members:type_name -> band.tss.v1beta1.AssignedMember
	15, // 10: band.tss.v1beta1.ComplaintWithStatus.complaint:type_name -> band.tss.v1beta1.Complaint
	2,  // 11: band.tss.v1beta1.ComplaintWithStatus.complaint_status:type_name -> band.tss.v1beta1.ComplaintStatus
	16, // 12: band.tss.v1beta1.ComplaintsWithStatus.complaints_with_status:type_name -> band.tss.v1beta1.ComplaintWithStatus
	9,  // 13: band.tss.v1beta1.SigningResult.signing:type_name -> band.tss.v1beta1.Signing
	10, // 14: band.tss.v1beta1.SigningResult.current_signing_attempt:type_name -> band.tss.v1beta1.SigningAttempt
	22, // 15: band.tss.v1beta1.SigningResult.evm_signature:type_name -> band.tss.v1beta1.EVMSignature
	20, // 16: band.tss.v1beta1.SigningResult.received_partial_signatures:type_name -> band.tss.v1beta1.PartialSignature
	24, // 17: band.tss.v1beta1.SigningExpirations.signing_expirations:type_name -> band.tss.v1beta1.SigningExpiration
	18, // [18:18] is the sub-list for method output_type
	18, // [18:18] is the sub-list for method input_type
	18, // [18:18] is the sub-list for extension type_name
	18, // [18:18] is the sub-list for extension extendee
	0,  // [0:18] is the sub-list for field type_name
}

func init() { file_band_tss_v1beta1_tss_proto_init() }
func file_band_tss_v1beta1_tss_proto_init() {
	if File_band_tss_v1beta1_tss_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_band_tss_v1beta1_tss_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Group); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_band_tss_v1beta1_tss_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GroupResult); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_band_tss_v1beta1_tss_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Round1Info); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_band_tss_v1beta1_tss_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Round2Info); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_band_tss_v1beta1_tss_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DE); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_band_tss_v1beta1_tss_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DEQueue); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_band_tss_v1beta1_tss_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Signing); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_band_tss_v1beta1_tss_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SigningAttempt); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_band_tss_v1beta1_tss_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AssignedMember); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_band_tss_v1beta1_tss_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PendingSignings); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_band_tss_v1beta1_tss_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Member); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_band_tss_v1beta1_tss_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Confirm); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_band_tss_v1beta1_tss_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Complaint); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_band_tss_v1beta1_tss_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ComplaintWithStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_band_tss_v1beta1_tss_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ComplaintsWithStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_band_tss_v1beta1_tss_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PendingProcessGroups); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_band_tss_v1beta1_tss_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PendingProcessSignings); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_band_tss_v1beta1_tss_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PartialSignature); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_band_tss_v1beta1_tss_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TextSignatureOrder); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_band_tss_v1beta1_tss_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EVMSignature); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_band_tss_v1beta1_tss_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SigningResult); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_band_tss_v1beta1_tss_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SigningExpiration); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_band_tss_v1beta1_tss_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SigningExpirations); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_band_tss_v1beta1_tss_proto_rawDesc,
			NumEnums:      3,
			NumMessages:   23,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_band_tss_v1beta1_tss_proto_goTypes,
		DependencyIndexes: file_band_tss_v1beta1_tss_proto_depIdxs,
		EnumInfos:         file_band_tss_v1beta1_tss_proto_enumTypes,
		MessageInfos:      file_band_tss_v1beta1_tss_proto_msgTypes,
	}.Build()
	File_band_tss_v1beta1_tss_proto = out.File
	file_band_tss_v1beta1_tss_proto_rawDesc = nil
	file_band_tss_v1beta1_tss_proto_goTypes = nil
	file_band_tss_v1beta1_tss_proto_depIdxs = nil
}
